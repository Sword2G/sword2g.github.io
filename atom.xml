<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>No root,no fruit</title>
  <subtitle>just do it！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://github.com/Sword2G/sword2g.github.io/"/>
  <updated>2017-03-10T09:17:03.191Z</updated>
  <id>https://github.com/Sword2G/sword2g.github.io/</id>
  
  <author>
    <name>sword2g</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Nginx安装Modsecurity</title>
    <link href="https://github.com/Sword2G/sword2g.github.io/2016/09/01/how-to-install-modsecurity-on-Nginx/"/>
    <id>https://github.com/Sword2G/sword2g.github.io/2016/09/01/how-to-install-modsecurity-on-Nginx/</id>
    <published>2016-09-01T09:03:09.000Z</published>
    <updated>2017-03-10T09:17:03.191Z</updated>
    
    <content type="html"><![CDATA[<p>Nginxz增加modsecurity，实现WAF。<br><a id="more"></a></p>
<h2 id="系统"><a href="#系统" class="headerlink" title="系统"></a>系统</h2><p>OS : Ubuntu 14.04 LTS<br>Nginx : nginx-1.9.9  nginx.org/download/nginx-1.9.9.tar.gz<br>Mosecurity : Mosecurity2.9.1 git@github.com:SpiderLabs/ModSecurity.git</p>
<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><h3 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h3><figure class="highlight q"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-<span class="built_in">get</span> install  build-essential libpcre3 libpcre3-<span class="built_in">dev</span> libssl-<span class="built_in">dev</span> libtool autoconf apache2-prefork-<span class="built_in">dev</span> libxml2-<span class="built_in">dev</span> libcurl4-openssl-<span class="built_in">dev</span></div></pre></td></tr></table></figure>
<h3 id="下载modsecurity、nginx"><a href="#下载modsecurity、nginx" class="headerlink" title="下载modsecurity、nginx"></a>下载modsecurity、nginx</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">cd <span class="regexp">/usr/</span>src</div><div class="line">sudo git clone git:<span class="regexp">//gi</span>thub.com<span class="regexp">/SpiderLabs/</span>ModSecurity.git</div><div class="line"></div><div class="line">wget nginx.org<span class="regexp">/download/</span>nginx-<span class="number">1.9</span>.<span class="number">9</span>.tar.gz</div></pre></td></tr></table></figure>
<h3 id="编译Modsecurity"><a href="#编译Modsecurity" class="headerlink" title="编译Modsecurity"></a>编译Modsecurity</h3><figure class="highlight gauss"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">cd Modsecurity</div><div class="line">./autogen.sh</div><div class="line">./configure --<span class="keyword">enable</span>-standalone-module --<span class="keyword">disable</span>-mlogc</div><div class="line"><span class="built_in">make</span></div></pre></td></tr></table></figure>
<h3 id="编译-Nginx"><a href="#编译-Nginx" class="headerlink" title="编译 Nginx"></a>编译 Nginx</h3><figure class="highlight haml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">cd /usr/src</div><div class="line">tar xzvf nginx-1.9.9.tar.gz</div><div class="line"> </div><div class="line">编译nginx(加入 Modsecurity ),安装</div><div class="line">./configure \</div><div class="line">  -<span class="ruby">-user=www-data \</span></div><div class="line">  -<span class="ruby">-group=www-data \</span></div><div class="line">  -<span class="ruby">-with-pcre-jit \</span></div><div class="line">  -<span class="ruby">-with-debug \</span></div><div class="line">  -<span class="ruby">-with-ipv6 \</span></div><div class="line">  -<span class="ruby">-with-http_ssl_module \</span></div><div class="line">  -<span class="ruby">-add-<span class="class"><span class="keyword">module</span>=/<span class="title">usr</span>/<span class="title">src</span>/<span class="title">ModSecurity</span>/<span class="title">nginx</span>/<span class="title">modsecurity</span></span></span></div><div class="line"></div><div class="line"> make </div><div class="line"> make install</div></pre></td></tr></table></figure>
<p>编译 nginx 的其他参数可以参考<a href="https://www.nginx.com/resources/wiki/start/topics/tutorials/installoptions/" target="_blank" rel="external">这里</a></p>
<p>安装结果如下<br><img src="http://7xum8m.com1.z0.glb.clouddn.com/nginx_modsecurity_install.png" alt=""></p>
<h3 id="配置-nginx"><a href="#配置-nginx" class="headerlink" title="配置 nginx"></a>配置 nginx</h3><p>修改/usr/local/nginx/conf/nginx.conf 的<br><code>user nobody;</code>为’user www-data;’</p>
<p>创建 /usr/local/nginx/sbin/nginx 软连接，从而可以直接使用nginx命令<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ln -s <span class="regexp">/usr/</span>local<span class="regexp">/nginx/</span>sbin<span class="regexp">/nginx /</span>bin<span class="regexp">/nginx</span></div></pre></td></tr></table></figure></p>
<p>启动 nginx，查看/usr/local/nginx/log/error.log,若出现类似一下信息说明 Modsecurity 安装成功<br><img src="http://7xum8m.com1.z0.glb.clouddn.com/nginx_modsecurity_Modsecurity_successful.png" alt=""></p>
<h3 id="配置-Modsecurity"><a href="#配置-Modsecurity" class="headerlink" title="配置 Modsecurity"></a>配置 Modsecurity</h3><p>复制 /usr/src/ModSecurity/modsecurity.conf-recommended 到 /usr/local/nginx/conf/modsecurity.conf,复制cp /usr/src/ModSecurity/unicode.mapping 到 /usr/local/nginx/conf/,modsecurity.conf需要引用 unicode.mapping</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cp <span class="regexp">/usr/</span>src<span class="regexp">/ModSecurity/</span>modsecurity.conf-recommended <span class="regexp">/usr/</span>local<span class="regexp">/nginx/</span>conf/modsecurity.conf</div><div class="line">cp <span class="regexp">/usr/</span>src<span class="regexp">/ModSecurity/</span>unicode.mapping <span class="regexp">/usr/</span>local<span class="regexp">/nginx/</span>conf/</div></pre></td></tr></table></figure>
<p>修改 Modsecurity.conf，将SecRuleEngine设置为 on</p>
<h3 id="下载-OWASP-Core-Rule-Set-CRS"><a href="#下载-OWASP-Core-Rule-Set-CRS" class="headerlink" title="下载 OWASP Core Rule Set (CRS)"></a>下载 OWASP Core Rule Set (CRS)</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cd <span class="regexp">/usr/</span>local<span class="regexp">/nginx/</span>conf</div><div class="line">git clone https:<span class="regexp">//gi</span>thub.com<span class="regexp">/SpiderLabs/</span>owasp-modsecurity-crs.git</div></pre></td></tr></table></figure>
<h4 id="2-x-版本-CRS"><a href="#2-x-版本-CRS" class="headerlink" title="2.x 版本 CRS"></a>2.x 版本 CRS</h4><p>在 owasp-modsecurity-crs 下有很多存放规则的文件夹，例如base_rules、experimental_rules、optional_rules、slr_rules将需要启用的规则用Include指令添加到 modsecurity.conf尾部,如</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">Include</span> owasp-modsecurity-crs/modsecurity_crs_10_setup.<span class="keyword">conf</span></div><div class="line"><span class="keyword">Include</span> owasp-modsecurity-crs/base_rules/modsecurity_crs_41_sql_injection_attacks.<span class="keyword">conf</span></div><div class="line"><span class="keyword">Include</span> owasp-modsecurity-crs/base_rules/modsecurity_crs_41_xss_attacks.<span class="keyword">conf</span></div><div class="line"><span class="keyword">Include</span> owasp-modsecurity-crs/base_rules/modsecurity_crs_40_generic_attacks.<span class="keyword">conf</span></div><div class="line"><span class="keyword">Include</span> owasp-modsecurity-crs/experimental_rules/modsecurity_crs_11_dos_protection.<span class="keyword">conf</span></div><div class="line"><span class="keyword">Include</span> owasp-modsecurity-crs/experimental_rules/modsecurity_crs_11_brute_force.<span class="keyword">conf</span></div><div class="line"><span class="keyword">Include</span> owasp-modsecurity-crs/optional_rules/modsecurity_crs_16_session_hijacking.<span class="keyword">conf</span></div></pre></td></tr></table></figure>
<h4 id="3-x版本CRS"><a href="#3-x版本CRS" class="headerlink" title="3.x版本CRS"></a>3.x版本CRS</h4><p>修改 crs-setup.conf.example 为 crs-setup.conf.<br>修改 rules/REQUEST-900-EXCLUSION-RULES-BEFORE-CRS.conf.example 为 rules/REQUEST-900-EXCLUSION-RULES-BEFORE-CRS.conf<br>修改 rules/RESPONSE-999-EXCLUSION-RULES-AFTER-CRS.conf.example 为 rules/RESPONSE-999-EXCLUSION-RULES-AFTER-CRS.conf<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">cd owasp-modsecurity-crs</div><div class="line">mv crs-setup<span class="selector-class">.conf</span><span class="selector-class">.example</span> crs-setup<span class="selector-class">.conf</span></div><div class="line"></div><div class="line">mv rules/REQUEST-<span class="number">900</span>-EXCLUSION-RULES-BEFORE-CRS<span class="selector-class">.conf</span><span class="selector-class">.example</span> rules/REQUEST-<span class="number">900</span>-EXCLUSION-RULES-BEFORE-CRS<span class="selector-class">.conf</span></div><div class="line">mv rules/RESPONSE-<span class="number">999</span>-EXCLUSION-RULES-AFTER-CRS<span class="selector-class">.conf</span><span class="selector-class">.example</span> rules/RESPONSE-<span class="number">999</span>-EXCLUSION-RULES-AFTER-CRS.conf</div></pre></td></tr></table></figure></p>
<p>在 /usr/local/nginx/conf 下新建 modsec_includes.conf,内容为需要启用的规则<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">include</span> modsecurity.<span class="keyword">conf</span></div><div class="line"><span class="keyword">include</span> owasp-modsecurity-crs/crs-setup.<span class="keyword">conf</span></div><div class="line"><span class="keyword">include</span> owasp-modsecurity-crs/rules/REQUEST-900-EXCLUSION-RULES-BEFORE-CRS.<span class="keyword">conf</span></div><div class="line"><span class="keyword">include</span> owasp-modsecurity-crs/rules/REQUEST-901-INITIALIZATION.<span class="keyword">conf</span></div><div class="line"><span class="keyword">include</span> owasp-modsecurity-crs/rules/REQUEST-905-COMMON-EXCEPTIONS.<span class="keyword">conf</span></div><div class="line"><span class="keyword">include</span> owasp-modsecurity-crs/rules/REQUEST-910-IP-REPUTATION.<span class="keyword">conf</span></div><div class="line"><span class="keyword">include</span> owasp-modsecurity-crs/rules/REQUEST-911-METHOD-ENFORCEMENT.<span class="keyword">conf</span></div><div class="line"><span class="keyword">include</span> owasp-modsecurity-crs/rules/REQUEST-912-DOS-PROTECTION.<span class="keyword">conf</span></div><div class="line"><span class="keyword">include</span> owasp-modsecurity-crs/rules/REQUEST-913-SCANNER-DETECTION.<span class="keyword">conf</span></div><div class="line"><span class="keyword">include</span> owasp-modsecurity-crs/rules/REQUEST-920-PROTOCOL-ENFORCEMENT.<span class="keyword">conf</span></div><div class="line"><span class="keyword">include</span> owasp-modsecurity-crs/rules/REQUEST-921-PROTOCOL-ATTACK.<span class="keyword">conf</span></div><div class="line"><span class="keyword">include</span> owasp-modsecurity-crs/rules/REQUEST-930-APPLICATION-ATTACK-LFI.<span class="keyword">conf</span></div><div class="line"><span class="keyword">include</span> owasp-modsecurity-crs/rules/REQUEST-931-APPLICATION-ATTACK-RFI.<span class="keyword">conf</span></div><div class="line"><span class="keyword">include</span> owasp-modsecurity-crs/rules/REQUEST-932-APPLICATION-ATTACK-RCE.<span class="keyword">conf</span></div><div class="line"><span class="keyword">include</span> owasp-modsecurity-crs/rules/REQUEST-933-APPLICATION-ATTACK-PHP.<span class="keyword">conf</span></div><div class="line"><span class="keyword">include</span> owasp-modsecurity-crs/rules/REQUEST-941-APPLICATION-ATTACK-XSS.<span class="keyword">conf</span></div><div class="line"><span class="keyword">include</span> owasp-modsecurity-crs/rules/REQUEST-942-APPLICATION-ATTACK-SQLI.<span class="keyword">conf</span></div><div class="line"><span class="keyword">include</span> owasp-modsecurity-crs/rules/REQUEST-943-APPLICATION-ATTACK-SESSION-FIXATION.<span class="keyword">conf</span></div><div class="line"><span class="keyword">include</span> owasp-modsecurity-crs/rules/REQUEST-949-BLOCKING-EVALUATION.<span class="keyword">conf</span></div><div class="line"><span class="keyword">include</span> owasp-modsecurity-crs/rules/RESPONSE-950-DATA-LEAKAGES.<span class="keyword">conf</span></div><div class="line"><span class="keyword">include</span> owasp-modsecurity-crs/rules/RESPONSE-951-DATA-LEAKAGES-SQL.<span class="keyword">conf</span></div><div class="line"><span class="keyword">include</span> owasp-modsecurity-crs/rules/RESPONSE-952-DATA-LEAKAGES-JAVA.<span class="keyword">conf</span></div><div class="line"><span class="keyword">include</span> owasp-modsecurity-crs/rules/RESPONSE-953-DATA-LEAKAGES-PHP.<span class="keyword">conf</span></div><div class="line"><span class="keyword">include</span> owasp-modsecurity-crs/rules/RESPONSE-954-DATA-LEAKAGES-<span class="keyword">IIS</span>.<span class="keyword">conf</span></div><div class="line"><span class="keyword">include</span> owasp-modsecurity-crs/rules/RESPONSE-959-BLOCKING-EVALUATION.<span class="keyword">conf</span></div><div class="line"><span class="keyword">include</span> owasp-modsecurity-crs/rules/RESPONSE-980-CORRELATION.<span class="keyword">conf</span></div><div class="line"><span class="keyword">include</span> owasp-modsecurity-crs/rules/RESPONSE-999-EXCLUSION-RULES-AFTER-CRS.<span class="keyword">conf</span></div></pre></td></tr></table></figure></p>
<h3 id="启用-modsecurity"><a href="#启用-modsecurity" class="headerlink" title="启用 modsecurity"></a>启用 modsecurity</h3><p>修改 /usr/local/nginx/conf/nginx.conf ，在需要启用 Modsecurity 的 location 开启 Modsecurity</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="section">server</span> &#123;</div><div class="line">  <span class="attribute">listen</span>       <span class="number">80</span>;</div><div class="line">  <span class="attribute">server_name</span>  example.com;</div><div class="line"></div><div class="line">  <span class="attribute">location</span> / &#123;</div><div class="line"></div><div class="line">    <span class="attribute">ModSecurityEnabled</span> <span class="literal">on</span>;</div><div class="line">    <span class="comment"># 2.x版本CRS</span></div><div class="line">    <span class="attribute">ModSecurityConfig</span> modsecurity.conf;</div><div class="line">    <span class="comment"># 3.x版本CRS</span></div><div class="line">    <span class="comment"># ModSecurityConfig modsec_includes.conf;</span></div><div class="line"></div><div class="line">    <span class="attribute">root</span>   html;</div><div class="line">    <span class="attribute">index</span>  index.html index.htm;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="测试-Nginx-with-Modsecurity"><a href="#测试-Nginx-with-Modsecurity" class="headerlink" title="测试 Nginx(with Modsecurity)"></a>测试 Nginx(with Modsecurity)</h3><p>构造攻击payload测试<br><a href="http://192.168.204.131/?param=%22%3Cscript%3Ealert(1);%3C/script%3E%22" target="_blank" rel="external">http://192.168.204.131/?param=%22%3Cscript%3Ealert(1);%3C/script%3E%22</a><br>查看拦截日志如下<br><img src="http://7xum8m.com1.z0.glb.clouddn.com/nginx_modsecurity_result.png" alt=""></p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://github.com/SpiderLabs/ModSecurity/wiki">https://github.com/SpiderLabs/ModSecurity/wiki</a><br><a href="https://www.howtoforge.com/tutorial/install-nginx-with-mod_security-on-ubuntu-15-04/" target="_blank" rel="external">https://www.howtoforge.com/tutorial/install-nginx-with-mod_security-on-ubuntu-15-04/</a><br><a href="https://blog.stickleback.dk/nginx-modsec-on-ubuntu-14-04-lts/" target="_blank" rel="external">https://blog.stickleback.dk/nginx-modsec-on-ubuntu-14-04-lts/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Nginxz增加modsecurity，实现WAF。&lt;br&gt;
    
    </summary>
    
      <category term="WAF" scheme="https://github.com/Sword2G/sword2g.github.io/categories/WAF/"/>
    
    
      <category term="Modsecurity, Nginx" scheme="https://github.com/Sword2G/sword2g.github.io/tags/Modsecurity-Nginx/"/>
    
  </entry>
  
  <entry>
    <title>SEnginx 反向代理搭建测试</title>
    <link href="https://github.com/Sword2G/sword2g.github.io/2016/08/26/SEnginx-Reverse-Proxy/"/>
    <id>https://github.com/Sword2G/sword2g.github.io/2016/08/26/SEnginx-Reverse-Proxy/</id>
    <published>2016-08-26T14:43:34.000Z</published>
    <updated>2016-12-28T14:58:11.135Z</updated>
    
    <content type="html"><![CDATA[<p>代理服务器是一个作为客户端与目标服务器之间的中介服务器，主要完成客户端与目标服务器之间请求和响应的转发工作。它分为正向代理和反向代理。<br><a id="more"></a></p>
<h1 id="正向代理"><a href="#正向代理" class="headerlink" title="正向代理"></a>正向代理</h1><p>正向服务器可以理解为客户端的代理人。客户端为了能从目标服务器取得内容，首先向代理服务器发送一个请求，并且指定目标服务器，之后代理服务器向目标服务器转交请求，获得请求的内容并转交返回给客户端。它向内部网络提供访问外部网络资源的途径，作为客户代理。</p>
<p><img src="http://7xum8m.com1.z0.glb.clouddn.com/nginx_%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86.jpg" alt="正向代理"></p>
<h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><h3 id="加快客户端的请求应答"><a href="#加快客户端的请求应答" class="headerlink" title="加快客户端的请求应答"></a>加快客户端的请求应答</h3><p>代理服务器可以缓存某些资源（如页面），当客户端需要再次请求该资源的时候，代理服务器可以将其缓存的该资源直接返回给客户端而不用再次转发请求，重新从目标服务器取得资源。</p>
<h3 id="减少出口的流量，节约带宽"><a href="#减少出口的流量，节约带宽" class="headerlink" title="减少出口的流量，节约带宽"></a>减少出口的流量，节约带宽</h3><p>由于缓存的机制，出口减少的很多请求流量，节约了带宽。</p>
<h3 id="访问受限资源"><a href="#访问受限资源" class="headerlink" title="访问受限资源"></a>访问受限资源</h3><p>客户端可能无法直接访问目标服务器资源，由代理服务器代替客户端取得资源后再将资源转发给客户端。</p>
<h3 id="隐藏客户端身份"><a href="#隐藏客户端身份" class="headerlink" title="隐藏客户端身份"></a>隐藏客户端身份</h3><p>真正的请求资源的是代理服务器，所以目标服务器并不知道真实的客户身份</p>
<h1 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h1><p>反向代理可以理解为服务器端的代理人。反向代理对客户端是透明的，客户端并不知道反向代理的存在。客户端向目标服务器发送请求的时候实际上是由反向代理服务器首先收到请求，反向代理服务器可以根据相应的策略，将客户端的请求转发给真正的目标服务器。它向外部网络提供访问内部网络资源的途径，作为服务器代理。</p>
<p><img src="http://7xum8m.com1.z0.glb.clouddn.com/nginx_%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8.jpg" alt="反向代理"></p>
<h2 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h2><h3 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h3><p>由于客户端的请求首先需要经过代理服务器，代理服务器在对客户端的请求进行合法化的检查之后再将请求转发给真正的目标服务器，保证了目标服务器的安全。</p>
<h3 id="缓解目标服务器压力"><a href="#缓解目标服务器压力" class="headerlink" title="缓解目标服务器压力"></a>缓解目标服务器压力</h3><p>代理服务器可以缓存某些资源，减少对真是目标服务器的请求。</p>
<h3 id="实现负载均衡"><a href="#实现负载均衡" class="headerlink" title="实现负载均衡"></a>实现负载均衡</h3><p>根据某些策略将客户端请求转发到服务器集群中的不同服务器，平衡集群中各个服务器的负载压力。</p>
<h1 id="SEnginx-Security-Enhanced-NGINX"><a href="#SEnginx-Security-Enhanced-NGINX" class="headerlink" title="SEnginx (Security Enhanced NGINX)"></a><a href="http://www.senginx.org/cn/index.php/%E9%A6%96%E9%A1%B5" target="_blank" rel="external">SEnginx (Security Enhanced NGINX)</a></h1><blockquote>
<p>SEnginx（Security Enhanced NGINX）是著名的 HTTP 和 反向代理 服务器nginx的一个变种版本，主要是在原版nginx的基础上增加了多种Web安全功能，并增强了应用交付等方面的原有功能。SEnginx继承了nginx的全部原始特性，全面兼容标准nginx的配置，此外也吸收了一些源自tengine等优秀nginx变种的高级特性以及一些常用的第三方nginx模块。</p>
</blockquote>
<h2 id="SEnginx-主要功能"><a href="#SEnginx-主要功能" class="headerlink" title="SEnginx 主要功能"></a>SEnginx 主要功能</h2><h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><p>SEnginx 中集成了 nginx_tcp_proxy_module，为用户提供 tcp 的反向代理和负载均衡功能。<br>负载均衡功能在 upstream 上下文中进行配置。负载均衡的算法支持 fastest 算法（响应速度快的服务器应该有能力处理更多请求） 和 fair 算法（“闲者优先”，主要判断依据是各个 backend 上的链接数和和失败数）。</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">upstream <span class="keyword">backend </span>&#123;</div><div class="line">    	fastest<span class="comment">;</span></div><div class="line">    	<span class="comment"># fair;</span></div><div class="line">        server <span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">8087</span> <span class="comment">;</span></div><div class="line">    	server <span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">8085</span> <span class="comment">;</span></div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="会话保持"><a href="#会话保持" class="headerlink" title="会话保持"></a>会话保持</h3><p>在使用负载均衡功能的网站会要求属于同一会话的请求必须交付给相同的服务器，由 persistence 模块实现。</p>
<p>persistence有三种标识会话的方式：</p>
<ul>
<li><p>插入HTTP cookie来标识会话<br>persistence 模块在其响应中设置”Set-Cookie”头，浏览器发送下一次请求时带上这个 cookie<br>persistence 模块根据 cookie 判断应该转发给那个服务器</p>
</li>
<li><p>监听现有会话的cookie来标识会话<br>persistence 模块再添加包含 server信息的特定 cookie；在服务器设置的cookie存在时persistence功能才会有效。</p>
</li>
<li><p>基于session功能来标识会话<br>persistence 模块会基于 session 中记录的信息进行会话保持。在这种情况下，persistence 的超时时间和session的超时时间相同</p>
</li>
</ul>
<h3 id="缓存类型设置"><a href="#缓存类型设置" class="headerlink" title="缓存类型设置"></a>缓存类型设置</h3><p>可以针对针应答类型进行缓存，而不仅仅是请求的类型。</p>
<h3 id="服务器健康检查"><a href="#服务器健康检查" class="headerlink" title="服务器健康检查"></a><a href="http://tengine.taobao.org/document_cn/http_upstream_check_cn.html" target="_blank" rel="external">服务器健康检查</a></h3><p>代理服务器定时周期性的向后端服务器发送健康检查数据包，代理可以通过后端服务器给出的响应判断后端服务器 down 还是 up。</p>
<h3 id="访问行为识别"><a href="#访问行为识别" class="headerlink" title="访问行为识别"></a>访问行为识别</h3><p>可以设置某个目录下的资源为敏感资源，在一定的时间内，如果客户端对敏感资源的访问 percent 都达到某个阈值，就可以初步判断该访问为机器人或是恶意攻击，根据相应的策略可以对客户端进行限速或进行机器人挑战（判断是否是机器人）。</p>
<h3 id="基于条件的限速功能"><a href="#基于条件的限速功能" class="headerlink" title="基于条件的限速功能"></a>基于条件的限速功能</h3><p>本功能基于tengine的limit_req模块，该模块针对原始nginx的limit_req功能在IP白名单、多条件限速以及forbid_action等方面进行了增强，SEnginx在此基础上增加了condition参数，只有条件为真时才执行限速动作，这样limit_req模块和机器人缓解模块以及访问行为识别模块配合使用，可以实现更加严格且多样化的限速策略</p>
<h3 id="Robot-Mitigation（机器人缓解）"><a href="#Robot-Mitigation（机器人缓解）" class="headerlink" title="Robot Mitigation（机器人缓解）"></a>Robot Mitigation（机器人缓解）</h3><p>Robot Mitigation 模块采用了一种基于“挑战”的验证方法，即向客户端发送特定的、浏览器能解析的应答（特定的js 脚本或swf flash 文件），如果客户端是真实的浏览器，则会重新触发请求，并带有一个特定的Cookie值，Robot Mitigation 模块会依据此 Cookie 的信息来判断是否是机器人。</p>
<h3 id="黑白名单"><a href="#黑白名单" class="headerlink" title="黑白名单"></a>黑白名单</h3><p>当某个源IP地址在1秒内发生指定的攻击次数时，将此IP地址加入到IP黑名单中，并阻断此IP一段时间。</p>
<h3 id="带DNS反查的User-Agent白名单"><a href="#带DNS反查的User-Agent白名单" class="headerlink" title="带DNS反查的User-Agent白名单"></a>带DNS反查的User-Agent白名单</h3><p>DNS反查，根据请求的源IP地址，查询DNS服务器获取域名，如果域名和用户定义的正则pattern匹配，则此白名单才命中。此机制是为了防止User-Agent伪造为知名机器人。</p>
<h3 id="Cookie-防篡改"><a href="#Cookie-防篡改" class="headerlink" title="Cookie 防篡改"></a>Cookie 防篡改</h3><p>Cookie Poisoning 模块能监控服务器发出的 Set-Cookie 头以及设置的 cookie 值，如果 cookie 的值在客户端被修改，则此模块会检测出修改，并执行动作。</p>
<h3 id="网页防篡改"><a href="#网页防篡改" class="headerlink" title="网页防篡改"></a>网页防篡改</h3><p>在请求到达 SEnginx 的时候核查文件水印（由原始文件生成的 hash 文件）是否有变化，从而达到防篡改的目的。防篡改模块可以和 nginx 配合以达到在篡改发生时，可以将请求重定向到备份的目录，恢复网页内容的功能。</p>
<h3 id="安全会话机制"><a href="#安全会话机制" class="headerlink" title="安全会话机制"></a>安全会话机制</h3><p>Session会在客户端的浏览器设置一个 Cookie 用于记录会话信息</p>
<h1 id="SEnginx-配置示例"><a href="#SEnginx-配置示例" class="headerlink" title="SEnginx 配置示例"></a>SEnginx 配置示例</h1><h2 id="实现环境"><a href="#实现环境" class="headerlink" title="实现环境"></a>实现环境</h2><p>由于实验环境的限制，我们将 SEnginx (作为反向代理)和 apache2 (作为服务器)部署同一台计算机上。SEnginx 监听 http 80 端口，而 web 服务器分别以不同的端口号(8085 和 8087)部署在同一个 apache2 服务器上，代表两个不同的 web 服务器，当用户访问 localhost 时，SEnginx 作为反向代理将请求均衡地转发给 apache 2 不同端口的 Web 应用程序进行处理。架构如下图所示：</p>
<p><img src="http://7xum8m.com1.z0.glb.clouddn.com/nginx_%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E6%9E%B6%E6%9E%84.jpg" alt="SEnginx 反向代理架构"></p>
<h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><figure class="highlight vala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div><div class="line">241</div><div class="line">242</div><div class="line">243</div><div class="line">244</div><div class="line">245</div><div class="line">246</div><div class="line">247</div><div class="line">248</div><div class="line">249</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#运行的用户</span></div><div class="line"><span class="meta">#user  nobody;</span></div><div class="line"><span class="meta"># worker 工作进程的个数，master进程是接收并分配请求给worker处理，通常和cpu数量相同</span></div><div class="line">worker_processes  <span class="number">1</span>;</div><div class="line"><span class="meta"># 错误日志及日志级别[debug, info, notice, warn, error, crit],默认 error</span></div><div class="line">error_log  logs/error.log  notice;</div><div class="line"><span class="meta"># pid 文件</span></div><div class="line">pid        logs/nginx.pid;</div><div class="line"></div><div class="line"></div><div class="line">events &#123;</div><div class="line"><span class="meta"># IO 复用模型 2.6 以上内核支持，Linux 默认 IO 模型</span></div><div class="line"><span class="meta">#    use   epoll;</span></div><div class="line"><span class="meta">#   单个 worker process 上的最大并发数</span></div><div class="line">    worker_connections  <span class="number">1024</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta"># http 服务相关参数</span></div><div class="line">http &#123;</div><div class="line"><span class="meta">#   设定mime类型,类型由mime.type文件定义</span></div><div class="line">    include       mime.types;</div><div class="line">    default_type  application/octet-stream;</div><div class="line"></div><div class="line"><span class="meta">#   服务器日志格式，以下为默认格式</span></div><div class="line">    #log_format  main  <span class="string">'$remote_addr - $remote_user [$time_local] "$request" '</span></div><div class="line">    #                  <span class="string">'$status $body_bytes_sent "$http_referer" '</span></div><div class="line">    #                  <span class="string">'"$http_user_agent" "$http_x_forwarded_for"'</span>;</div><div class="line"></div><div class="line"><span class="meta">#   开启高效文件传输模式，sendfile指令指定nginx是否调用sendfile函数来输出文件，  </span></div><div class="line"><span class="meta">#   减少用户空间到内核空间的上下文切换。</span></div><div class="line"><span class="meta">#	对于普通应用设为on，如果用来进行下载等应用磁盘IO重负载应用，可设置为off，</span></div><div class="line"><span class="meta">#	以平衡磁盘与网络I/O处理速度，降低系统的负载。</span></div><div class="line">    sendfile        on;</div><div class="line"></div><div class="line"><span class="meta">#   与 tcp_nodelay 互斥  </span></div><div class="line"><span class="meta">#   开启 Nagle 算法，等到数据包最大时，一次性的传输出去，这样有助于解决网络堵塞</span></div><div class="line">    tcp_nopush     on;</div><div class="line"></div><div class="line"><span class="meta">#   连接超时时间</span></div><div class="line"><span class="meta">#   keepalive_timeout  0;</span></div><div class="line">    keepalive_timeout  <span class="number">65</span>;</div><div class="line"></div><div class="line"><span class="meta">#   开启gzip压缩</span></div><div class="line">    gzip  on;</div><div class="line"><span class="meta">#   session 最大 size</span></div><div class="line">    session_max_size <span class="number">1024</span>;</div><div class="line"></div><div class="line"><span class="meta">#   SEnginx blacklist 开启</span></div><div class="line">    ip_blacklist on;</div><div class="line"><span class="meta">#   blacklist 大小</span></div><div class="line">    ip_blacklist_size <span class="number">10240</span>;</div><div class="line"><span class="meta">#   blacklis 超时时间</span></div><div class="line">    ip_blacklist_timeout <span class="number">60</span>;</div><div class="line">	</div><div class="line"><span class="meta">#   global User-Agent whitelist </span></div><div class="line">    whitelist_ua $ua_wl_dns &#123;</div><div class="line">    	caseless;</div><div class="line">    	<span class="string">"baiduspider"</span> <span class="string">".*\.baidu\.com"</span>;</div><div class="line">    	<span class="string">"googlebot"</span> <span class="string">".*\.google\.com"</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"><span class="meta">#   statistics 内存 size，注意统计信息放在内存中，一旦 server 关机，数据清零</span></div><div class="line">    statistics_zone <span class="number">10</span>m;</div><div class="line"></div><div class="line"><span class="meta">#   负载均衡的服务器列表	</span></div><div class="line">    upstream backend &#123;</div><div class="line"><span class="meta">#       Http 会话保持，支持 insert_cookie， monitor_cookie， session_based   </span></div><div class="line">    	persistence insert_cookie cookie_name=senginxforward timeout=<span class="number">30</span>;</div><div class="line"></div><div class="line"><span class="meta">#	    负载均衡算法，支持 fastest 和 fair;</span></div><div class="line">    	fastest;</div><div class="line"><span class="meta">#       服务器主机，可以用域名（域名支持动态解析）或 ip</span></div><div class="line">        server <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8087</span> ;</div><div class="line">    	server <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8085</span> ;</div><div class="line"><span class="meta">#       后端服务器健康度检查    	</span></div><div class="line">	    check interval=<span class="number">1000</span> rise=<span class="number">2</span> fall=<span class="number">5</span> timeout=<span class="number">1000</span> type=tcp;</div><div class="line"><span class="meta">#       配置一个连接发送的请求数，其默认值为 1        </span></div><div class="line"><span class="meta">#       check_keepalive_requests 100;</span></div><div class="line"><span class="meta">#       配置http健康检查包发送的请求内容，为了减少传输数据量，采用"HEAD"方法</span></div><div class="line"><span class="meta">#       当采用长连接进行健康检查时，需在该指令中添加keep-alive请求头，</span></div><div class="line"><span class="meta">#       如："HEAD / HTTP/1.1\r\nConnection: keep-alive\r\n\r\n"</span></div><div class="line">        check_http_send <span class="string">"HEAD / HTTP/1.1\r\nConnection: keep-alive\r\n\r\n"</span>;</div><div class="line"><span class="meta">#       指定 HTTP 回复的健康状态，默认认为 2XX 和 3XX 状态是健康的</span></div><div class="line">        check_http_expect_alive http_2xx http_3xx;	</div><div class="line"></div><div class="line">    &#125;</div><div class="line"><span class="meta">#   定义一个限速 zone 速率是 1 request per second</span></div><div class="line">    limit_req_zone $binary_remote_addr zone=cc:<span class="number">10</span>m rate=<span class="number">1</span>r/s;</div><div class="line">    limit_req_zone $binary_remote_addr zone=total:<span class="number">10</span>m rate=<span class="number">30</span>r/s;    </div><div class="line"><span class="meta">#   define a ip analysis zone，名字为abc 内存大小10M，</span></div><div class="line"><span class="meta">#   在1s采样周期内请求达到10次才计算访问行为</span></div><div class="line">    ip_behavior_zone zone=abc:<span class="number">10</span>m sample_base=<span class="number">10</span> sample_cycle=<span class="number">1</span>s;</div><div class="line"></div><div class="line"><span class="meta">#   定义一个虚拟主机 在 80 端口监听</span></div><div class="line">    server &#123;</div><div class="line">        listen       <span class="number">80</span>;</div><div class="line">        server_name  localhost;</div><div class="line">    #   日志路径    </div><div class="line">    #   access_log  logs/host.access.log  main;</div><div class="line"></div><div class="line"><span class="meta">#	define a unique server virtual server name for statistics</span></div><div class="line">	virtual_server_name www.abc.com;</div><div class="line"><span class="meta">#   开启会话，Cookie 防篡改模块依赖 session</span></div><div class="line">	session on;</div><div class="line">	</div><div class="line"><span class="meta">#   开启防篡改</span></div><div class="line"><span class="meta">#	web_defacement on;  </span></div><div class="line"><span class="meta">#   web_defacement_original /usr/local/senginx/html ;</span></div><div class="line"><span class="meta">#	指定网页文件所在的目录</span></div><div class="line"><span class="meta">#   web_defacement_original /var/www/8087 ;</span></div><div class="line"><span class="meta">#   指定hash文件</span></div><div class="line"><span class="meta">#   web_defacement_hash_data /usr/local/senginx/hash_data;</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="meta">#   turn on a ip analysis zone</span></div><div class="line">	ip_behavior zone=abc type=sensitive_url;</div><div class="line">	</div><div class="line"><span class="meta">#	statistics page </span></div><div class="line">	location /stats &#123;</div><div class="line"> 	    statistics;</div><div class="line"><span class="meta">#       设置页面访问权限</span></div><div class="line">	    allow all;</div><div class="line"><span class="meta">#       allow SOME.IP.ADD.RESS;</span></div><div class="line"><span class="meta">#       deny all;</span></div><div class="line">	&#125;</div><div class="line"></div><div class="line"><span class="meta">#	show session page </span></div><div class="line">	location /show_session &#123;</div><div class="line">	    session_show on;</div><div class="line"><span class="meta">#       设置页面访问权限</span></div><div class="line">	    allow all;</div><div class="line"><span class="meta">#       allow SOME.IP.ADD.RESS;</span></div><div class="line"><span class="meta">#       deny all;</span></div><div class="line">	&#125;</div><div class="line"><span class="meta">#   flush session</span></div><div class="line">	location /blacklist_flush &#123;</div><div class="line">        ip_blacklist_flush;</div><div class="line">   	    ip_blacklist_log on;</div><div class="line"><span class="meta">#       设置页面访问权限</span></div><div class="line">	    allow all;</div><div class="line"><span class="meta">#       allow SOME.IP.ADD.RESS;</span></div><div class="line"><span class="meta">#       deny all;</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line"><span class="meta">#   blacklist page </span></div><div class="line">    location /blacklist_show &#123;</div><div class="line">        ip_blacklist_show;</div><div class="line">   	    ip_blacklist_log on;</div><div class="line"><span class="meta">#       设置页面访问权限</span></div><div class="line">	    allow all;</div><div class="line"><span class="meta">#       allow SOME.IP.ADD.RESS;</span></div><div class="line"><span class="meta">#       deny all;  	    </span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">	location /ss/  &#123;</div><div class="line">        </div><div class="line"><span class="meta">#       if condition == 1, goto @process</span></div><div class="line">	    limit_req zone=cc burst=<span class="number">1</span> forbid_action=@process condition=$cond;   </div><div class="line">        # 限速模块backlog = <span class="number">5</span></div><div class="line">	    limit_req zone=total burst=<span class="number">5</span>;</div><div class="line"></div><div class="line"><span class="meta">#	    root /var/www/8085/ss/;</span></div><div class="line">	    root /<span class="keyword">var</span>/www/<span class="number">8087</span>; </div><div class="line"><span class="meta">#       设置为 sensitive resource</span></div><div class="line">	    ip_behavior_sensitive;</div><div class="line"><span class="meta">#       设置 $cond 条件</span></div><div class="line">        ifall ($insensitive_percent &gt;= <span class="number">0</span>) ($insensitive_percent &lt; <span class="number">30</span>) &#123;</div><div class="line">                 <span class="keyword">set</span> $cond <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">	&#125;</div><div class="line">  </div><div class="line">	location @process &#123;</div><div class="line">     	# <span class="keyword">return</span> <span class="number">403</span>;</div><div class="line">        # 机器人模块</div><div class="line">	    robot_mitigation on;</div><div class="line">	    robot_mitigation_cookie_name robotCookie;</div><div class="line">        # js or swf</div><div class="line">	    robot_mitigation_mode js;</div><div class="line">	    # times to change</div><div class="line">	    robot_mitigation_blacklist <span class="number">3</span>;</div><div class="line"></div><div class="line">	    #robot_mitigation_action directive deprecated</div><div class="line">        # robot_mitigation_action block;</div><div class="line">        #  robot_mitigation_whitelist &#123;</div><div class="line">        #       <span class="string">"Google"</span> <span class="string">"Googlebot"</span>;</div><div class="line">        # &#125;</div><div class="line"></div><div class="line"><span class="meta">#       请求转向自定义的服务器列表    </span></div><div class="line">   	    proxy_pass http:<span class="comment">//backend; </span></div><div class="line">	</div><div class="line">    &#125;     </div><div class="line"><span class="meta">#   网页篡改时 recover 目录 </span></div><div class="line">	location /recover &#123;</div><div class="line">               web_defacement off;</div><div class="line">               root /<span class="keyword">var</span>/www;</div><div class="line">    &#125;	</div><div class="line"><span class="meta">#   cookie 防篡改模块 </span></div><div class="line">    location / &#123;</div><div class="line"><span class="meta">#       开启放篡改    </span></div><div class="line">		cookie_poisoning on;</div><div class="line"><span class="meta">#		cookie 篡改时动作，支持 block, pass, remove cookie,add to blacklist</span></div><div class="line">		cookie_poisoning_action block;     </div><div class="line">		#cookie_poisoning_action remove;    <span class="comment">//remove cookie</span></div><div class="line">		#cookie_poisoning_action blacklist,<span class="number">5</span>;    <span class="comment">//block 5 times and put into blacklist	      </span></div><div class="line">		cookie_poisoning_log on;</div><div class="line"></div><div class="line"><span class="meta">#		User-Agent whitelist</span></div><div class="line">		cookie_poisoning_whitelist ua_var_name=ua_wl_dns;                        </div><div class="line"></div><div class="line"><span class="meta">#       限速模块 backlog = 5</span></div><div class="line">	    limit_req zone=total burst=<span class="number">5</span>;</div><div class="line"></div><div class="line"><span class="meta">#       请求转向自定义的服务器列表 	      </span></div><div class="line">	    proxy_pass http:<span class="comment">//backend;</span></div><div class="line"><span class="meta">#       index 页面                </span></div><div class="line">        # index index.html;</div><div class="line">        # root /usr/local/senginx/html;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">        #charset koi8-r;</div><div class="line"></div><div class="line">       # location / &#123;</div><div class="line">        #    root   html;</div><div class="line">         #   index  index.html index.htm;</div><div class="line">       # &#125;</div><div class="line"></div><div class="line">        #error_page  <span class="number">404</span>              /<span class="number">404.</span>html;</div><div class="line"></div><div class="line">        # redirect server error pages to the <span class="keyword">static</span> page /<span class="number">50</span>x.html</div><div class="line"><span class="meta">#       定义错误页面</span></div><div class="line">    error_page   <span class="number">500</span> <span class="number">502</span> <span class="number">503</span> <span class="number">504</span>  /<span class="number">50</span>x.html;</div><div class="line">    location = /<span class="number">50</span>x.html &#123;</div><div class="line">        root   html;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">	location ~ \.html$ &#123;</div><div class="line">		proxy_pass http:<span class="comment">//backend;</span></div><div class="line">		proxy_redirect off; </div><div class="line">	&#125;	</div><div class="line"></div><div class="line"><span class="meta">#   定义健康检查 status page	</span></div><div class="line">	location /status &#123;</div><div class="line">        check_status;</div><div class="line">        access_log   off;</div><div class="line">	    allow all;</div><div class="line"><span class="meta">#       allow SOME.IP.ADD.RESS;</span></div><div class="line"><span class="meta">#       deny all;</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="http://www.cnblogs.com/edisonchou/p/4126742.html" target="_blank" rel="external">http://www.cnblogs.com/edisonchou/p/4126742.html</a><br><a href="http://www.cnblogs.com/xiaogangqq123/archive/2011/03/02/1969006.html" target="_blank" rel="external">http://www.cnblogs.com/xiaogangqq123/archive/2011/03/02/1969006.html</a><br><a href="http://www.senginx.org/cn/index.php/%E9%A6%96%E9%A1%B5" target="_blank" rel="external">http://www.senginx.org/cn/index.php/%E9%A6%96%E9%A1%B5</a><br>（完）</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;代理服务器是一个作为客户端与目标服务器之间的中介服务器，主要完成客户端与目标服务器之间请求和响应的转发工作。它分为正向代理和反向代理。&lt;br&gt;
    
    </summary>
    
      <category term="Server" scheme="https://github.com/Sword2G/sword2g.github.io/categories/Server/"/>
    
    
      <category term="Nginx" scheme="https://github.com/Sword2G/sword2g.github.io/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>GDB-Note</title>
    <link href="https://github.com/Sword2G/sword2g.github.io/2016/08/20/GDB-Note/"/>
    <id>https://github.com/Sword2G/sword2g.github.io/2016/08/20/GDB-Note/</id>
    <published>2016-08-20T14:32:45.000Z</published>
    <updated>2016-12-28T14:43:48.537Z</updated>
    
    <content type="html"><![CDATA[<p>GDB 是 UNIX 及 UNIX-like 下的调试工具。<br><a id="more"></a></p>
<h1 id="编译加入调试信息"><a href="#编译加入调试信息" class="headerlink" title="编译加入调试信息"></a>编译加入调试信息</h1><ul>
<li>gcc -g 参数</li>
<li>gcc -g hello.c -o hello</li>
</ul>
<h1 id="启动gdb"><a href="#启动gdb" class="headerlink" title="启动gdb"></a>启动gdb</h1><ul>
<li><p>调试程序<br>gdb program_name</p>
</li>
<li><p>调试程序和 core 文件<br>gdb program_name core</p>
</li>
<li><p>指定程序的 pid ，gdb 可以自动attach上去<br>gdb program_name pid</p>
</li>
</ul>
<h1 id="显示源代码"><a href="#显示源代码" class="headerlink" title="显示源代码"></a>显示源代码</h1><ul>
<li><p>显示 lineno/function_name 周围源代码<br>list [lineno/function_name]</p>
</li>
<li><p>list<br>显示当前行后面的源程序。</p>
</li>
<li><p>list -<br>显示当前行前面的源程序。</p>
</li>
</ul>
<h1 id="断点"><a href="#断点" class="headerlink" title="断点"></a>断点</h1><h2 id="设置断点"><a href="#设置断点" class="headerlink" title="设置断点"></a>设置断点</h2><ul>
<li><p>设置断点<br>b function_name<br>b lineno if n == 9</p>
</li>
<li><p>修改断点的条件为 expression<br>condition &lt;断点号&gt; </p>
</li>
</ul>
<h2 id="显示断点"><a href="#显示断点" class="headerlink" title="显示断点"></a>显示断点</h2><p>info b</p>
<h2 id="en-dis-able-断点"><a href="#en-dis-able-断点" class="headerlink" title="en(dis)able 断点"></a>en(dis)able 断点</h2><ul>
<li>disable [b] [range]</li>
<li>disable [b] 1-4</li>
<li>enable [b] [range]</li>
</ul>
<h2 id="delete-断点"><a href="#delete-断点" class="headerlink" title="delete 断点"></a>delete 断点</h2><p>delete [breakpoints] [range…]</p>
<h1 id="设置观察点"><a href="#设置观察点" class="headerlink" title="设置观察点"></a>设置观察点</h1><p>观察点一般来观察某个表达式（变量也是一种表达式）的值是否有变化了，如果有变化，马上停住程序。</p>
<ul>
<li>watch 为表达式（变量）expr设置一个观察点。当表达式值有变化时，马上停住程序</li>
<li>rwatch 表达式（变量）expr被读时，停住程序</li>
<li>awatch 表达式（变量）的值被读或被写时，停住程序</li>
<li>info watchpoints 列出当前所设置了的所有观察点</li>
</ul>
<h1 id="run"><a href="#run" class="headerlink" title="run"></a>run</h1><ul>
<li><p>设置参数<br>set args [param1] [param2] [param3]</p>
</li>
<li><p>显示参数<br>show args</p>
</li>
<li><p>r(un) [param1] [param2] [param3] &gt;&gt;</p>
</li>
</ul>
<h1 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h1><ul>
<li>start 开始运行程序</li>
<li>run 运行程序，可简写为r</li>
<li>next 单步跟踪，函数调用当作一条简单语句执行，可简写为n</li>
<li>step 单步跟踪，函数调进入被调用函数体内，可简写为s</li>
<li>finish 退出函数</li>
<li>until 在一个循环体内单步跟踪时，这个命令可以运行程序直到退出循环体,可简写为u。</li>
<li>continue 继续运行程序，可简写为c</li>
</ul>
<h1 id="打印变量、字符串、表达式等的值，可简写为p"><a href="#打印变量、字符串、表达式等的值，可简写为p" class="headerlink" title="打印变量、字符串、表达式等的值，可简写为p"></a>打印变量、字符串、表达式等的值，可简写为p</h1><ul>
<li>p var 打印 var 的值</li>
<li>p cou1+cou2+cou3 打印表达式值</li>
<li>p *array@len 打印数组的前len数据<br>print接受一个表达式，GDB会根据当前的程序运行的数据来计算这个表达式，表达式可以是当前程序运行中的const常量、变量、函数等内容。</li>
</ul>
<p>但是GDB不能使用程序中定义的宏。</p>
<h1 id="设置变量"><a href="#设置变量" class="headerlink" title="设置变量"></a>设置变量</h1><ul>
<li>set var=value</li>
<li>p var=value</li>
</ul>
<h1 id="自动显示变量"><a href="#自动显示变量" class="headerlink" title="自动显示变量"></a>自动显示变量</h1><ul>
<li>dsplay expr</li>
<li>display/fmt expr</li>
<li><p>display/fmt addr<br>expr是一个表达式，fmt表示显示的格式，addr表示内存地址，当你用display设定好了一个或多个表达式后，只要你的程序被停下来，GDB会自动显示你所设置的这些表达式的值。</p>
</li>
<li><p>info display 查看display设置的自动显示的信息。</p>
</li>
<li><p>undisplay dnums…</p>
</li>
<li><p>delete display dnums…<br>删除自动显示，dnums意为所设置好了的自动显式的编号。如果要同时删除几个，编号可以用空格分隔，如果要删除一个范围内的编号，可以用减号表示（如：2-5）</p>
</li>
<li><p>disable display dnums…</p>
</li>
<li><p>enable display dnums…</p>
</li>
</ul>
<p>disable和enalbe不删除自动显示的设置，而只是让其失效和恢复。</p>
<h1 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h1><h2 id="产生信号"><a href="#产生信号" class="headerlink" title="产生信号"></a>产生信号</h2><ul>
<li>signal signalnum<br>如 signal 9<br>signal 命令和 shell 的 kill 命令不同，系统的 kill 命令发信号给被调试程序时，是由 GDB 截获的，而 signal 命令所发出一信号则是直接发给被调试程序的。</li>
</ul>
<h2 id="handle-signal"><a href="#handle-signal" class="headerlink" title="handle signal"></a>handle signal</h2><p><code>handle signal [keywords…]</code><br>keywords 列表如下:</p>
<ul>
<li><p>nostop<br>当被调试的程序收到信号时，GDB不会停住程序的运行，但会打出消息告诉你收到这种信号。</p>
</li>
<li><p>stop<br>当被调试的程序收到信号时，GDB会停住你的程序。</p>
</li>
<li><p>print<br>当被调试的程序收到信号时，GDB会显示出一条信息。</p>
</li>
<li><p>noprint<br>当被调试的程序收到信号时，GDB 不会告诉你收到信号的信息。</p>
</li>
<li><p>pass</p>
</li>
<li><p>noignore<br>当被调试的程序收到信号时，GDB不处理信号。</p>
</li>
<li><p>nopass</p>
</li>
<li><p>ignore<br>当被调试的程序收到信号时，GDB不会让被调试程序来处理这个信号。</p>
</li>
<li><p>info signals</p>
</li>
<li><p>info handle<br>查看有哪些信号在被GDB检测中。</p>
</li>
</ul>
<h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><ul>
<li><p>查看 thread 号<br>info threads</p>
</li>
<li><p>指定线程设置断点<br>break linespec thread threadno<br>break linespec thread threadno if …</p>
</li>
</ul>
<h1 id="查看栈信息"><a href="#查看栈信息" class="headerlink" title="查看栈信息"></a>查看栈信息</h1><ul>
<li><p>打印当前的函数调用栈的所有信息<br>bt</p>
</li>
<li><p>n是一个正整数，表示只打印栈顶上n层的栈信息<br>bt n</p>
</li>
<li><p>-n表一个负整数，表示只打印栈底下n层的栈信息<br>bt -n</p>
</li>
<li><p>切换当前栈<br>frame n</p>
</li>
</ul>
<h1 id="跳转"><a href="#跳转" class="headerlink" title="跳转"></a>跳转</h1><ul>
<li><p>指定下一条语句的运行点<br>jump linespec</p>
</li>
<li><p>这里的是代码行的内存地址<br>jump *address</p>
</li>
</ul>
<p><strong>注意，jump命令不会改变当前的程序栈中的内容，所以，当你从一个函数跳到另一个函数时，当函数运行完返回时进行弹栈操作时必然会发生错误，可能结果还是非常奇怪的，甚至于产生程序Core Dump。所以最好是同一个函数中进行跳转。</strong></p>
<h1 id="强制函数返回"><a href="#强制函数返回" class="headerlink" title="强制函数返回"></a>强制函数返回</h1><p>使用 return 命令取消当前函数的执行，并立即返回，如果指定了 expression，那么该表达式的值会被认作函数的返回值<code>return [expression]</code></p>
<p>如果你的调试断点在某个函数中，并还有语句没有执行完。你可以使用 return 命令强制函数忽略还没有执行的语句并返回。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://blog.csdn.net/haoel/article/details/2879" target="_blank" rel="external">http://blog.csdn.net/haoel/article/details/2879</a><br>（完）</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;GDB 是 UNIX 及 UNIX-like 下的调试工具。&lt;br&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://github.com/Sword2G/sword2g.github.io/categories/Linux/"/>
    
    
      <category term="GDB" scheme="https://github.com/Sword2G/sword2g.github.io/tags/GDB/"/>
    
  </entry>
  
  <entry>
    <title>Linux Kernel — System Calls</title>
    <link href="https://github.com/Sword2G/sword2g.github.io/2016/07/19/Linux-kernel-systemcall/"/>
    <id>https://github.com/Sword2G/sword2g.github.io/2016/07/19/Linux-kernel-systemcall/</id>
    <published>2016-07-19T14:24:26.000Z</published>
    <updated>2016-12-28T14:30:27.504Z</updated>
    
    <content type="html"><![CDATA[<p>Linux 内核中设置了一组用于实现系统功能的子程序，称为系统调用。系统调用和普通库函数调用非常相似，只是系统调用由内核提供，运行于内核态，而普通的函数调用由函数库或用户自己提供，运行于用户态。<br><a id="more"></a></p>
<h1 id="系统调用的作用"><a href="#系统调用的作用" class="headerlink" title="系统调用的作用"></a>系统调用的作用</h1><p>系统调用在用户空间进程和硬件设备之间添加了一个中间层。它的作用有两个：</p>
<ul>
<li><p>为用户空间提供一个抽象的访问硬件资源的接口，即屏蔽了具体的硬件细节。如，在读写文件时，应用程序不用去关心存储介质的类型，所使用的文件系统。</p>
</li>
<li><p>系统调用保证了系统的稳定和安全。系统调用对资源的访问必须遵循一定的规则与限制，防止应用程序非法访问没有权限的软硬件资源。</p>
</li>
</ul>
<h1 id="系统调用-API-C库"><a href="#系统调用-API-C库" class="headerlink" title="系统调用/API/C库"></a>系统调用/API/C库</h1><h2 id="系统调用与-API"><a href="#系统调用与-API" class="headerlink" title="系统调用与 API"></a>系统调用与 API</h2><p>一般情况下，应用程序通过使用在用户空间实现的 API (应用程序编程接口)来获得所需的功能，而不是直接调用系统调用，可以说， API 是系统调用的一种封装。API 可以被看做是系统调用所实现功能的一种使用途径，也就是说应用程序一般通过 API 来使用系统调用。一个 API 可以在多个不同的操作系统中实现，给应用程序提供相同的接口，但是具体的实现可能迥然不同。</p>
<h2 id="API-与-C-库"><a href="#API-与-C-库" class="headerlink" title="API 与 C 库"></a>API 与 C 库</h2><p>操作系统 API 通常都以 C 库的方式提供，C 库实现了 UNIX 系统的主要 API。C 库提供了 POSIX 的绝大部分 API，同时，内核提供的每个系统调用在 C 库中都具有相应的封装函数。系统调用与其 C 库封装函数的名称常常相同，比如，read 系统调用在 C 库中的封装函数即为 read 函数。C 库中的系统调用封装函数在最终调用到相应系统调用之前，往往不做多少额外的工作。</p>
<p>但是系统调用和 C 库函数之间并不是一一对应的关系，一个 C 库函数包含 0 到多个系统调用，从而提供比系统调用更加复杂的功能。</p>
<h2 id="C-库与系统命令"><a href="#C-库与系统命令" class="headerlink" title="C 库与系统命令"></a>C 库与系统命令</h2><p>系统命令位于 C 库的更上层，是利用 C 库实现的可执行程序，比如最为常用的 ls、cd 等命令。</p>
<p>简单的来说，系统调用是内核提供某一服务的接口，而 API(C 库) 是基于系统调用编写的功能更加完善的应用程序。从程序员的角度来看，系统调用无关紧要，只需要和 API 打交道，而从内核的角度来看，并不需要知道应用程序如何使用系统调用，只要实现该系统调用所要完成的功能即可。</p>
<h1 id="系统调用号"><a href="#系统调用号" class="headerlink" title="系统调用号"></a>系统调用号</h1><p>在 Linux 中，每个系统调用都被赋予一个系统调用号，其对应关系存储在 sys_call_table (系统调用表)中。在x86-64中，他定义于 arch/i386/kernel/syscall_64.c 文件中，这样就可以通过这个独一无二的系统调用号关联相应的系统调用。当用户空间执行一个系统调用的时候就可以指明到底是执行哪一个系统调用而不会提及系统调用的名称。</p>
<p>系统调用号一经分配就不可以表更，否则编译好的应用程序就会崩溃。即使该系统调用已删除也不能回收其对应的系统调用号，对于无效的系统调用号，其系统调用处理服务例程会被设置为 sys_ni_syscall(),它除了返回 -ENOSYS 外不做任何其他工作，它的存在就是为了”填补空缺”。</p>
<h1 id="系统调用处理函数"><a href="#系统调用处理函数" class="headerlink" title="系统调用处理函数"></a>系统调用处理函数</h1><p>系统调用运行在内核空间中，应用程序一般运行在用户空间。所以应用程序需要以某种方式通知系统，告诉内核需要切换到内核态（陷入内核），执行一个系统调用，从而让内核代表应用程序在内核空间执行系统调用，。</p>
<h2 id="系统调用与中断"><a href="#系统调用与中断" class="headerlink" title="系统调用与中断"></a>系统调用与中断</h2><p>操作系统通知内核陷入的机制是靠软中断来实现的： 通过引发一个异常促使系统切换到内核态去执行异常处理函数，而这个异常处理程序就是系统调用处理程序。在 X86 中，通过int $0X80 指令触发该异常，导致系统切换到内核态并执行 128 号中断的异常处理程序，该程序即系统调用处理程序(sys_call()，在arch/i386/kernel/entry.S 中，以汇编语言编写)。</p>
<h1 id="系统调用服务例程"><a href="#系统调用服务例程" class="headerlink" title="系统调用服务例程"></a>系统调用服务例程</h1><p>所有系统调用陷入内核的方式都是一样的，系统调用处理函数只是作为所有系统调用的入口函数，所以仅仅陷入内核是不够的，系统需要通过 system_call() 函数派发真正实现系统调用的系统调用服务例程。</p>
<h2 id="系统调用号与参数传递"><a href="#系统调用号与参数传递" class="headerlink" title="系统调用号与参数传递"></a>系统调用号与参数传递</h2><p>system_call() 函数可以读取 寄存器 eax 获得当前系统调用的系统调用号，将其乘以 4 生成偏移地址，然后以 sys_call_table 为基址，基址加上偏移地址所指向的内容即是应该执行的系统调用服务例程的地址，然后就可执行对应的系统调用服务例程了。进入 system_call() 函数前(陷入内核前)，系统调用服务例程所需的其他参数参数会被依次存放到 ebx、ecx、edx、esi 以及 edi 寄存器中，system_call() 函数执行时会首先将这些寄存器压入堆栈,从而将参数从用户空间传给内核，<br>对于系统调用服务例程，可以直接从 system_call() 函数压入的堆栈中获得参数。</p>
<p>给用户空间的返回值也是通过寄存器来传递的。在 X86 系统上，它存放在 eax 中。</p>
<h1 id="系统调用执行过程"><a href="#系统调用执行过程" class="headerlink" title="系统调用执行过程"></a>系统调用执行过程</h1><p>系统调用执行过程分为两个阶段：</p>
<ul>
<li>用户空间到内核空间的转换阶段</li>
<li>系统调用处理程序 system_call() 函数到系统调用服务例程的阶段</li>
</ul>
<p><img src="http://7xum8m.com1.z0.glb.clouddn.com/syscall_user2sys.jpg" alt="用户空间到内核空间"></p>
<p><img src="http://7xum8m.com1.z0.glb.clouddn.com/syscall_systemcall.jpg" alt="system_call函数到系统调用服务例程"></p>
<h2 id="read-系统调用"><a href="#read-系统调用" class="headerlink" title="read() 系统调用"></a>read() 系统调用</h2><p>read() 系统调用在内核中被定义成 sys_read(),系统调用都遵循这一命名规则。</p>
<p><img src="http://7xum8m.com1.z0.glb.clouddn.com/syscall_read.jpg" alt="read系统调用"></p>
<h1 id="系统调用的使用"><a href="#系统调用的使用" class="headerlink" title="系统调用的使用"></a>系统调用的使用</h1><h2 id="系统调用的调用"><a href="#系统调用的调用" class="headerlink" title="系统调用的调用"></a>系统调用的调用</h2><ul>
<li><p>通过库函数使用。通常系统调用靠 C 库支持，用户程序通过包含标准头文件并和C库链接，通过 C 库函数使用系统调用。</p>
</li>
<li><p>通过_syscalln() 宏直接使用系统调用。（include/asm-x86/Unistd_64.h中定义了一组宏）</p>
</li>
</ul>
<p><img src="http://7xum8m.com1.z0.glb.clouddn.com/syscall_the_way2use_systemcall.jpg" alt="使用系统调用的两种方式"></p>
<p>对于 _syscalln() 宏，其中的n范围从 0 到 6 ，代表传递给系统调用的参数的个数。如<br>系统调用 open() 定义为 <code>long open(const char *filename, int flags, int mode)</code>，其系统调用宏的形式为</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 系统调用号</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_open 5</span></div><div class="line"><span class="comment">// _syscalln 宏</span></div><div class="line">_syscall13(<span class="keyword">long</span>, <span class="built_in">open</span>, <span class="keyword">const</span> <span class="keyword">char</span> *, filename, <span class="keyword">int</span>, flags, <span class="keyword">int</span>, mode)</div></pre></td></tr></table></figure>
<p>每个宏都有 2 + 2 * n 个参数，第一个参数是返回值类型，第二个参数是系统调用的名称，剩下的依次为参数的类型和名称。</p>
<h2 id="系统调用的返回值"><a href="#系统调用的返回值" class="headerlink" title="系统调用的返回值"></a>系统调用的返回值</h2><p>系统调用会通过一个 long 类型的返回值表示成功或失败。通常 0 便是成功，负值表示失败。系统调用子啊失败的时候 C 库会将错误码写入全局变量 errno 中，通过调用 perror() 库函数，可以把该变量翻译成用户可以理解的错误字符串。</p>
<h1 id="系统调用上下文"><a href="#系统调用上下文" class="headerlink" title="系统调用上下文"></a>系统调用上下文</h1><p>内核在执行系统调用的时候处于进程上下文。current指针指向当前任务，即引发系统调用的那个进程。在进程上下文中，内核可以休眠并且可以被抢占。这两点都很重要。首先，能够休眠说明系统调用可以使用内核提供的绝大部分功能。休眠的能力会给内核编程带来极大便利。在进程上下文中能够被抢占，其实表明，像用户空间内的进程一样，当前的进程同样可以被其他进程抢占。因为新的进程可以使用相同的系统调用，所以必须小心，保证该系统调用是可重人的。当然，这也是在对称多处理中必须同样关心的问题。当系统调用返回的时候，控制权仍然在system_call()中，它最终会负责切换到用户空间并让用户进程继续执行下去。</p>
<h1 id="系统调用的添加"><a href="#系统调用的添加" class="headerlink" title="系统调用的添加"></a>系统调用的添加</h1><p>添加系统调用需要四个步骤：</p>
<ul>
<li>编写系统调用服务例程()声明中需要 asmlinkage 限定词，注意函数名为 sys_xxx)</li>
<li>添加系统调用号(在 include/asm-x86/Unistd_32.h 中，)</li>
<li>添加到系统调用表(entry.s 中)</li>
<li>重新编译内核并测试新添加的系统调用(系统调用必须编译进内核，不能编译成模块)</li>
</ul>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="http://blog.csdn.net/skyflying2012/article/details/10044343" target="_blank" rel="external">http://blog.csdn.net/skyflying2012/article/details/10044343</a><br><a href="https://book.douban.com/subject/4895627/" target="_blank" rel="external">https://book.douban.com/subject/4895627/</a><br>（完）</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Linux 内核中设置了一组用于实现系统功能的子程序，称为系统调用。系统调用和普通库函数调用非常相似，只是系统调用由内核提供，运行于内核态，而普通的函数调用由函数库或用户自己提供，运行于用户态。&lt;br&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://github.com/Sword2G/sword2g.github.io/categories/Linux/"/>
    
    
      <category term="Linux Kernel" scheme="https://github.com/Sword2G/sword2g.github.io/tags/Linux-Kernel/"/>
    
  </entry>
  
  <entry>
    <title>Linux Kernel — Process Management</title>
    <link href="https://github.com/Sword2G/sword2g.github.io/2016/07/15/Linux-kernel-Process-Management/"/>
    <id>https://github.com/Sword2G/sword2g.github.io/2016/07/15/Linux-kernel-Process-Management/</id>
    <published>2016-07-15T14:52:22.000Z</published>
    <updated>2016-12-27T15:08:47.107Z</updated>
    
    <content type="html"><![CDATA[<p>进程不同于存储在存储介质上的程序，它是处于执行期的程序和与之相关的资源的总称。<br><a id="more"></a></p>
<h1 id="Linux进程和线程"><a href="#Linux进程和线程" class="headerlink" title="Linux进程和线程"></a>Linux进程和线程</h1><p>Linux 并不区分进程和线程。不同于 Microsoft Windows，对 Linux 而言，线程是一种轻量级进程（lightweight processes）。实际上，Linux 进程本身也足够轻量（Linux进程的创建所花时间比其他操作系统要少很多）。</p>
<p>举例来说，假设有一个包含四个线程的进程，Linux 直接创建四个进程，这四个进程共享资源，而对于其他操作系统来说，通常会创建一个进程，并用相应的指针指向此进程中包含的四个线程。</p>
<h1 id="task-struct-与-task-list"><a href="#task-struct-与-task-list" class="headerlink" title="task_struct 与 task list"></a>task_struct 与 task list</h1><p>Linux 内核中进程的信息主要保存在 task_struct 结构中,每个进程都有一个 task_struct 结构与之对应，而一个个 task_struct 结构是通过 task list (任务队列)这个双向循环链表组织起来。也就是说从任意一个 task_struct 开始，可以很轻松的遍历系统中的所有进程。但是在一个拥有大量进程的系统中通过重复来遍历所欲进程代价是很大的，因此尽量避免这样做。</p>
<h1 id="task-struct-定义"><a href="#task-struct-定义" class="headerlink" title="task_struct 定义"></a>task_struct 定义</h1><p>task_struct 结构定义在 /include/linux/sched.h 中<br>部分字段如下</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span></span> &#123;</div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 进程状态，如TASK_RUNNING</div><div class="line">	 */</div><div class="line">	volatile long state;	<span class="comment">/* -1 unrunnable, 0 runnable, &gt;0 stopped */</span></div><div class="line">	void *stack;</div><div class="line">	atomic_t usage;</div><div class="line">	unsigned <span class="keyword">int</span> flags;	<span class="comment">/* per process flags, defined below */</span></div><div class="line">	unsigned <span class="keyword">int</span> ptrace;</div><div class="line"></div><div class="line">	<span class="keyword">int</span> lock_depth;		<span class="comment">/* BKL lock depth */</span></div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * static_prio:进程的静态优先级，由启动时分配，nice和sched_setscheduler修改</div><div class="line">	 * prio和normal_prio是动态优先级。</div><div class="line">	 * normal_prio是由调度策略和静态优先级计算出来的优先级。</div><div class="line">	 * prio是运行时的动态优先级。某些情况下内核可能会暂时提升进程的优先级。如优先级继承。</div><div class="line">	 */</div><div class="line">	<span class="keyword">int</span> prio, static_prio, normal_prio;</div><div class="line">	<span class="comment">/* 对于RR实时进程，通过此字段将它加入到RR链表 */</span></div><div class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span></span> run_list;</div><div class="line">	<span class="comment">/* 进程所属的调度器类 */</span></div><div class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">sched_class</span></span> *sched_class;</div><div class="line">	<span class="comment">/* sched_entity代表一个调度实体，一个调度实体包含一组进程。这个功能用于cgroup */</span></div><div class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sched_entity</span></span> se;</div><div class="line"></div><div class="line">	unsigned short ioprio;</div><div class="line"></div><div class="line">	<span class="comment">/* 进程的调度策略，如SCHED_NORMAL */</span></div><div class="line">	unsigned <span class="keyword">int</span> policy;</div><div class="line">	<span class="comment">/* 进程的CPU亲和性 */</span></div><div class="line">	cpumask_t cpus_allowed;</div><div class="line">	<span class="comment">/* 对于RR进程来说，此字段表示进程可使用CPU的剩余时间段 */</span></div><div class="line">	unsigned <span class="keyword">int</span> time_slice;</div><div class="line"></div><div class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span></span> tasks;</div><div class="line"></div><div class="line">	<span class="comment">/* 分别代表用户态地址空间和实际使用的地址空间 */</span></div><div class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span></span> *mm, *active_mm;</div><div class="line"></div><div class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span></span> *real_parent; <span class="comment">/* real parent process (when being debugged) */</span></div><div class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span></span> *parent;	<span class="comment">/* parent process */</span></div><div class="line">	<span class="comment">/*</span></div><div class="line">	 * children/sibling forms the list of my children plus the</div><div class="line">	 * tasks I'm ptracing.</div><div class="line">	 */</div><div class="line">	<span class="comment">/* 子进程链表头 */</span></div><div class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span></span> children;	<span class="comment">/* list of my children */</span></div><div class="line">	<span class="comment">/* 通过此字段链接到父进程的children链表 */</span></div><div class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span></span> sibling;	<span class="comment">/* linkage in my parent's children list */</span></div><div class="line">	<span class="comment">/* 线程组的领头进程结构 */</span></div><div class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span></span> *group_leader;	<span class="comment">/* threadgroup leader */</span></div><div class="line"></div><div class="line">	<span class="comment">/* PID/PID hash table linkage. */</span></div><div class="line">	<span class="comment">/* 将进程链接到全局pid_hash哈希表的结构 */</span></div><div class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pid_link</span></span> pids[PIDTYPE_MAX];</div><div class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span></span> thread_group;</div><div class="line"></div><div class="line"><span class="comment">/* CPU-specific state of this task */</span></div><div class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">thread_struct</span></span> thread;</div><div class="line"><span class="comment">/* filesystem information */</span></div><div class="line">	<span class="comment">/* 进程文件系统相关信息，如当前目录 */</span></div><div class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fs_struct</span></span> *fs;</div><div class="line"><span class="comment">/* open file information */</span></div><div class="line">	<span class="comment">/* 当前进程的文件描述符 */</span></div><div class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">files_struct</span></span> *files;</div><div class="line"><span class="comment">/* namespaces */</span></div><div class="line">	<span class="comment">/* 进程所属命名空间 */</span></div><div class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nsproxy</span></span> *nsproxy;</div><div class="line"><span class="comment">/* signal handlers */</span></div><div class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">signal_struct</span></span> *signal;</div><div class="line">	<span class="comment">/* 用于管理用户设置的信号处理程序 */</span></div><div class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sighand_struct</span></span> *sighand;</div><div class="line"></div><div class="line">	<span class="comment">/* 所有阻塞的信号，是一个位掩码 */</span></div><div class="line">	sigset_t blocked, real_blocked;</div><div class="line">	sigset_t saved_sigmask;		<span class="comment">/* To be restored with TIF_RESTORE_SIGMASK */</span></div><div class="line">	<span class="comment">/* 已经触发、有待处理的信号链表 */</span></div><div class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sigpending</span></span> pending;</div><div class="line"></div><div class="line">	<span class="comment">/* 用户态信号处理栈地址及长度 */</span></div><div class="line">	unsigned long sas_ss_sp;</div><div class="line">	<span class="comment">//进程id</span></div><div class="line">	pid_t pid;</div><div class="line">	...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="task-struct-的分配"><a href="#task-struct-的分配" class="headerlink" title="task_struct 的分配"></a>task_struct 的分配</h1><p>进程是动态的实体，生命周期不固定，因此内核必须能够处理很多进程，并把 task_struct 存放在动态内存中，而不是放在内核内存区。Linux 是通过 slab 分配器给 task_struct 分配内存的，这样能够达到对象复用和和缓存着色 (cache coloring)的作用。</p>
<p>实际上，对于每个进程来说，Linux 通过把两个不同的数据结构紧凑的存放在一个单独为进程分配的内存区，一个是与 task_struct 相关的 thread_info 结构，另一个是内核态的进程堆栈，通常这块内存区占两个页框（8KB = 8192 Byte 或者4KB = 4096 Byte）。2.6 以前的内核直接将 task_struct 存放在内核栈的尾端，但现在只在内核栈的尾端存放一个较小的 thread_info 结构，该结构中有一个指向通过 slab 分配的 task_struct 结构的指针。</p>
<p>进程内核堆栈和 thread_info 的布局如下<br><img src="http://7xum8m.com1.z0.glb.clouddn.com/process_pthread_info.jpg" alt=""></p>
<p>thread_info 结构定义在 include/asm-x86（Thread_info32.h 后者Thread_in64.h）中<br>部分代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> thread_info &#123;</div><div class="line">	<span class="comment">/* 指向对应的task_struct结构 */</span></div><div class="line">	<span class="keyword">struct</span> task_struct	*task;		<span class="comment">/* main task structure */</span></div><div class="line">	<span class="comment">/* 执行域，一般用于64位机器上运行32位程序 */</span></div><div class="line">	<span class="keyword">struct</span> exec_domain	*exec_domain;	<span class="comment">/* execution domain */</span></div><div class="line">	<span class="comment">/* 进程标志，如TIF_SIGPENDING */</span></div><div class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		flags;		<span class="comment">/* low level flags */</span></div><div class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		status;		<span class="comment">/* thread-synchronous flags */</span></div><div class="line">	<span class="comment">/* 当前运行在哪个CPU上 */</span></div><div class="line">	__u32			cpu;		<span class="comment">/* current CPU */</span></div><div class="line">	<span class="comment">/* 抢占计数 */</span></div><div class="line">	<span class="keyword">int</span>			preempt_count;	<span class="comment">/* 0 =&gt; preemptable, &lt;0 =&gt; BUG */</span></div><div class="line">	...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="task-struct-的存放"><a href="#task-struct-的存放" class="headerlink" title="task_struct 的存放"></a>task_struct 的存放</h1><p>内核通过唯一的进程标识符pid来标识每个进程。pid字段存放在 task_struct 结构中的 pid 字段。通常可以通过current宏（该宏等价于current_thread_info()-&gt;task）来快速获得正在运行进程的 thread_info 结构，然后获得对应的 task_struct 结构指针，内核对进程的所有操作都是通过对 task_struct 结构操作来完成的。</p>
<h2 id="进程的状态"><a href="#进程的状态" class="headerlink" title="进程的状态"></a>进程的状态</h2><h3 id="TASK-RUNNING"><a href="#TASK-RUNNING" class="headerlink" title="TASK_RUNNING"></a>TASK_RUNNING</h3><p>可运行状态。进程是可运行状态，或正在运行。 对应 ps 中的 R 状态。</p>
<h3 id="TASK-INTERRUPTIBLE"><a href="#TASK-INTERRUPTIBLE" class="headerlink" title="TASK_INTERRUPTIBLE"></a>TASK_INTERRUPTIBLE</h3><p>可中断睡眠状态。可以响应异步信号，处于这个状态的进程因为等待某某事件的发生（比如等待 socket 连接、等待信号量），而被挂起，处于睡眠(阻塞)状态。这些进程的 task_struct 结构被放入对应事件的等待队列中。当这些事件发生时（由外部中断触发、或由其他进程触发），对应的等待队列中的一个或多个进程将被唤醒。 对应 ps 中的 S 状态。</p>
<h3 id="TASK-UNINTERRUPTIBLE"><a href="#TASK-UNINTERRUPTIBLE" class="headerlink" title="TASK_UNINTERRUPTIBLE"></a>TASK_UNINTERRUPTIBLE</h3><p>不可中断睡眠状态。与 TASK_INTERRUPTIBLE 状态类似，进程处于睡眠状态，但是此刻进程是不可中断的。不可中断，指的并不是 CPU 不响应外部硬件的中断，而是指进程不响应异步信号。<br>绝大多数情况下，进程处在睡眠状态时，总是应该能够响应异步信号的。处于这种状态下的进程 kill -9 发送 SIGKILL 信号是无法杀死该进程的。<br>ps 命令看到的进程几乎不会出现 TASK_UNINTERRUPTIBLE 状态，TASK_UNINTERRUPTIBLE 状态总是非常短暂的，通过 ps命令基本上不可能捕捉到，对应 ps 中的 D 状态。</p>
<h3 id="TASK-UNINTERRUPTIBLE-1"><a href="#TASK-UNINTERRUPTIBLE-1" class="headerlink" title="TASK_UNINTERRUPTIBLE"></a>TASK_UNINTERRUPTIBLE</h3><p>状态存在的意义就在于，内核的某些处理流程是不能被打断的。如果响应异步信号，程序的执行流程中就会被插入一段用于处理异步信号的流程（信号处理函数，这个插入的流程可能只存在于内核态，也可能延伸到用户态），于是原有的流程就被中断了。<br>在进程对某些硬件进行操作时（比如进程调用 read 系统调用对某个设备文件进行读操作，而 read 系统调用最终执行到对应设备驱动的代码，并与对应的物理设备进行交互），可能需要使用 TASK_UNINTERRUPTIBLE 状态对进程进行保护，以避免进程与设备交互的过程被打断，造成设备陷入不可控的状态。</p>
<h3 id="TASK-TRACED"><a href="#TASK-TRACED" class="headerlink" title="TASK_TRACED"></a>TASK_TRACED</h3><p>被跟踪状态。当进程正在被跟踪时，它处于 TASK_TRACED 这个特殊的状态。“正在被跟踪”指的是进程暂停下来，等待跟踪它的进程对它进行操作。比如在 gdb 中对被跟踪的进程下一个断点，进程在断点处停下来的时候就处于 TASK_TRACED 状态。而在其他时候，被跟踪的进程还是处于前面提到的那些状态。对应 ps 中的 T 状态。</p>
<h3 id="TASK-STOPPED"><a href="#TASK-STOPPED" class="headerlink" title="TASK_STOPPED"></a>TASK_STOPPED</h3><p>停止状态。向进程发送一个 SIGSTOP 信号，它就会因响应该信号而进入 TASK_STOPPED 状态（除非该进程本身处于 TASK_UNINTERRUPTIBLE 状态而不响应信号）对应 ps 中的 T 状态。</p>
<blockquote>
<p>TASK_STOPPED 和 TASK_TRACED 状态很类似，都是表示进程暂停下来。<br>而 TASK_TRACED 状态相当于在 TASK_STOPPED 之上多了一层保护，处于 TASK_TRACED 状态的进程不能响应 SIGCONT 信号而被唤醒。只能等到调试进程通过 ptrace 系统调用执行 PTRACE_CONT、PTRACE_DETACH 等操作（通过 ptrace 系统调用的参数指定操作），或调试进程退出，被调试的进程才能恢复 TASK_RUNNING 状态。</p>
</blockquote>
<h3 id="EXIT-ZOMBIE"><a href="#EXIT-ZOMBIE" class="headerlink" title="EXIT_ZOMBIE"></a>EXIT_ZOMBIE</h3><p>僵死状态。进程已经退出，等待父进程调用 wait 类函数，获取其 task_struct 中保存的退出状态，释放相应的 task_struct 结构（现在已经是空壳尸体，只有很少的字段有意义，用于保存进程的退出码和一些统计信息）。</p>
<h2 id="进程状态转换"><a href="#进程状态转换" class="headerlink" title="进程状态转换"></a>进程状态转换</h2><p><img src="http://7xum8m.com1.z0.glb.clouddn.com/process_status_switch.jpg" alt="进程状态转换"></p>
<h2 id="进程的家族"><a href="#进程的家族" class="headerlink" title="进程的家族"></a>进程的家族</h2><p>task_struct 中的 parent 指针指向其父进程的 task_struct，children 指针指向其子进程链表，sibling 指针指向其兄弟进程的进程链表</p>
<h1 id="进程的创建"><a href="#进程的创建" class="headerlink" title="进程的创建"></a>进程的创建</h1><h2 id="fork-and-exec"><a href="#fork-and-exec" class="headerlink" title="fork and exec"></a>fork and exec</h2><p>Linux 创建进程分为两步：</p>
<ul>
<li>fork() 拷贝当前进程映像</li>
<li>exec() 读取可执行文件并将其载入地址空间运行</li>
</ul>
<h2 id="copy-on-write"><a href="#copy-on-write" class="headerlink" title="copy-on-write"></a>copy-on-write</h2><p>传统的 fork() 直接将父进程的所有资源拷贝到子进程，但是很多时候这个操作是没有意义的，子进程可能马上就通过exec()执行新的程序那么前面进行的拷贝就毫无意义。copy-on-write 机制允许资源的拷贝在需要写的时候再进行，在此之前，以只读的方式与父进程共享同一地址空间，这种延迟拷贝机制节省了很多时间，避免了大量的拷贝。</p>
<h2 id="fork"><a href="#fork" class="headerlink" title="fork()"></a>fork()</h2><p>fork()函数的实现是通过调用 clone()系统调用来实现的。实际上 fork、vfork 还有线程的创建都是通过向 clone 系统调用传送不同的参数进行的，clone() 函数会调用 do_fork() 函数，它定义在 kernel/fork.c 中。do_fork()中的主要工作由 copy_process() 来完成，具体创建流程如下：</p>
<ul>
<li>调用 dup_task_struct() 为新进程分配内核栈、thread_info、task_struct 等，其中的内容与父进程相同</li>
<li>清理新进程 task_struct 结构字段，很多字段清 0 或设为初始值，使之与父进程区别开</li>
<li>新进程状态置为 TASK_UNINTERRUPTIBLE，保证不会投入运行</li>
<li>调用 copy_flags() 更新 task_struct 的 flags 成员。</li>
<li>调用 alloc_pid() 为新进程分配一个有效的 PID</li>
<li>根据 clone() 的参数标志，拷贝共享的打开文件、文件系统信息、信号处理函数、进程地址空间、命名空间等</li>
<li>做一些扫尾工作并返回子进程的指针</li>
</ul>
<p>返回 do_fork() 子进程被唤醒，并投入运行，一般来说内核有意选择子进程先执行。</p>
<h2 id="vfork"><a href="#vfork" class="headerlink" title="vfork()"></a>vfork()</h2><p>类似与 fork() 函数，只是调用 clone() 系统调用时传递的参数不同，通过 vfork()创建子进程，父进程会被阻塞，直到子进程退出或执行 exec() 函数</p>
<h2 id="线程的创建"><a href="#线程的创建" class="headerlink" title="线程的创建"></a>线程的创建</h2><p>Linux 并区分进程和线程，线程的创建与进程的创建类似，都是抵用 clone() 系统调用，传入一些参数指明需要共享的资源。<br><code>clone(CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND, 0);</code>，产生的结构与 fork() 类似，只是父子进程共享地址空间、文件系统资源、文件描述符和信号处理程序。</p>
<p>普通的 fork() 通过 <code>clone(SIGCHLD, 0)</code>实现，vfork() 通过 <code>clone(CLONE_VFORK | CLONE_VM | SIGCHLD, 0)</code>实现。</p>
<h2 id="内核线程的创建"><a href="#内核线程的创建" class="headerlink" title="内核线程的创建"></a>内核线程的创建</h2><p>内核线程和普通线程区别在于内核线程没有独立的地址空间（task_struct 中 mm 字段为NULL）。只在内核空间运行，从不切换到用户空间。</p>
<p>内核线程是由 kthread 内核线程通过调用 clone() 系统调用创建。<br><code>struct task_struct *kthread_create(int (*threadfn)(void *data), void *data, const char namefmt[], ...)</code><br>新的进程将运行 threadfn 函数， 参数为 data，进程名为 namefmt，新创建的线程处于不可运行状态，需要调用 wake_up_process() 明确的唤醒它。</p>
<h3 id="常见的内核线程"><a href="#常见的内核线程" class="headerlink" title="常见的内核线程"></a>常见的内核线程</h3><ul>
<li>keventd 执行 keventd_wq 工作队列当</li>
<li>kapmd 处理高级电源管理事件</li>
<li>kswapd 执行内存回收</li>
<li>pdflush 刷新缓存脏数据到磁盘</li>
</ul>
<h2 id="进程的终止"><a href="#进程的终止" class="headerlink" title="进程的终止"></a>进程的终止</h2><p>当一个进程终止时，内核必须释放它所占有的资源并向其父进程发送 SIGCHLD 信号，告知其父进程。<br>进程的析构发生在进程调用 exit() 系统调用时，既可能显示的调用也可能隐式的调用，比如从某个函数的主函数返回(c编译器会在main函数的返回点后面放置 exit() 的代码)当进程接收到它既不能处理也不能忽略的信号或异常时，也可能被动的终止。进程终止的大部分工作由 do_exit() 函数(定义在kernel/exit.c文件中)来完成，其流程如下：</p>
<ul>
<li>将task_struct flags字段设为 PF_EXITING</li>
<li>调用 edl_timer_sync() 删除任一定时器</li>
<li>调用 acct_update_integrals() 输出记账信息</li>
<li>调用 exit_mm() 释放占用的 mm_struct ，如果没有进程使用它则直接释放</li>
<li>调用 sem_exit() 释放用户空间的“信号量”</li>
<li>调用 exit_files() 递减文件描述符，调用 exit_fs() 递减文件系统数据引用计数，计数为 0 则释放<br>将 task_struct 中的 exit_code 字段设置为 exit() 函数的参数</li>
<li>调用 exit_notify() 函数通知父进程，若父进程已经退出，则会寻找新的父进程，并把task_struct 中exit_state 字段设置为 EXIT_ZOMBIE</li>
<li>调用 schedule() 切换到新进程（处于 EXIT_ZOMBIE 状态的进程将会被忽略）</li>
</ul>
<h2 id="孤儿进程"><a href="#孤儿进程" class="headerlink" title="孤儿进程"></a>孤儿进程</h2><p>如果父进程比子进程先退出，子进程就会成为孤儿进程，在子进程退出的时候没有相应的父进程来获取其退出状态，这些孤儿进程就会永远处于僵死状态，白白消耗内存。所以 Linux 的机制是先尝试在同一线程组中找一个线程作为其父进程，如果不行，则这些孤儿进程由 init 进程收养。</p>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="http://blog.csdn.net/brucexu1978/article/details/7721313" target="_blank" rel="external">http://blog.csdn.net/brucexu1978/article/details/7721313</a><br><a href="https://book.douban.com/subject/6097773/" target="_blank" rel="external">https://book.douban.com/subject/6097773/</a><br>（完）</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;进程不同于存储在存储介质上的程序，它是处于执行期的程序和与之相关的资源的总称。&lt;br&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://github.com/Sword2G/sword2g.github.io/categories/Linux/"/>
    
    
      <category term="Linux Kernel" scheme="https://github.com/Sword2G/sword2g.github.io/tags/Linux-Kernel/"/>
    
  </entry>
  
  <entry>
    <title>Linux 下静/动态链接库的使用</title>
    <link href="https://github.com/Sword2G/sword2g.github.io/2016/07/11/build-lib/"/>
    <id>https://github.com/Sword2G/sword2g.github.io/2016/07/11/build-lib/</id>
    <published>2016-07-11T14:31:02.000Z</published>
    <updated>2017-03-03T05:36:04.713Z</updated>
    
    <content type="html"><![CDATA[<p>静/动态链接库文件都是obj目标文件的集合，静态链接库以”.a”为后缀，动态链接库以”.so”为后缀。<br><a id="more"></a></p>
<h1 id="静态链接库"><a href="#静态链接库" class="headerlink" title="静态链接库"></a>静态链接库</h1><p>静态链接库为后缀为”.a”，有 ar 生成，由于动态链接库的使用，静态链接库的使用已经没有原来那么普遍。</p>
<h2 id="静态链接库的优点"><a href="#静态链接库的优点" class="headerlink" title="静态链接库的优点"></a>静态链接库的优点</h2><ul>
<li>不用重新编译库代码的情况下，重新进行程序链接，节省了编译时间</li>
<li>库开发者可以通过提供库文件给使用者使用，而不开源代码</li>
<li>使程序的开发模块化</li>
</ul>
<h2 id="静态链接库的生成"><a href="#静态链接库的生成" class="headerlink" title="静态链接库的生成"></a>静态链接库的生成</h2><p>静态链接库由 ar 程序来生成，命令格式为 <code>ar libname objfile1 objfile2</code></p>
<h2 id="静态链接库的使用"><a href="#静态链接库的使用" class="headerlink" title="静态链接库的使用"></a>静态链接库的使用</h2><p>gcc 在链接静态链接库时可以像使用obj目标文件一样链接”.a”文件，也可以通过”-llibname”的形式使用库文件。</p>
<h1 id="动态链接库"><a href="#动态链接库" class="headerlink" title="动态链接库"></a>动态链接库</h1><p>动态链接库不同于静态链接库，静态链接库在链接时直接将库文件代码链接进程序，而动态链接库是在程序运行时加载的库，库中函数和变量的地址是相对地址不是绝对地址，其真实地址是在调用动态库的程序加载时形成的。</p>
<h2 id="动态链接库的别名、真名、链接名"><a href="#动态链接库的别名、真名、链接名" class="headerlink" title="动态链接库的别名、真名、链接名"></a>动态链接库的别名、真名、链接名</h2><p>动态链接库的别名形如 <strong>libXXX.so</strong>，真名一般是在别名的基础上加上主版本号、次版本号等；程序链接时使用的库名为链接名。在安装动态链接库的时候，总是要复制库文件到某个目录下，然后用软连接生成别名，在库文件更新的时候只用更新新的软链接即可。</p>
<h2 id="动态链接库的生成"><a href="#动态链接库的生成" class="headerlink" title="动态链接库的生成"></a>动态链接库的生成</h2><p>动态链接库的生成需要用到 gcc 的 <strong>-fPIC(-fpic) -shared</strong> 选项 <strong>-fPIC(-fpic)</strong> 的作用是使得 gcc 生成的代码是位置无关的；<strong>-share </strong>告诉编译器生成动态链接库。</p>
<h2 id="动态链接库的安装"><a href="#动态链接库的安装" class="headerlink" title="动态链接库的安装"></a>动态链接库的安装</h2><p>一般将生成的动态链接库复制到默认的动态链接库搜索路径下，如<strong>/lib、/usr/lib、/usr/local/lib</strong>,放到任意目录即可。</p>
<h2 id="动态链接库的使用"><a href="#动态链接库的使用" class="headerlink" title="动态链接库的使用"></a>动态链接库的使用</h2><p>与静态链接库的使用方法一样，通过”-l库名”的方式使用，在生成可执行文件的时候链接库文件。</p>
<p>但是程序在编译时链接动态链接库和运行时使用动态链接库概念是不同的，运行时程序链接的动态链接库需要在动态链接库的搜索路径中。</p>
<p>可以使用以下三种方式告诉系统到哪里去找动态链接库：</p>
<ul>
<li><p>把库文件拷贝到<strong>/usr/lib</strong>和<strong>/lib</strong>目录下</p>
</li>
<li><p>在<strong>LD_LIBRARY_PATH</strong>环境变量中加上库所在路径。例如动态库 libhello.so 在/home/speedy/test/lib目录下，以 bash 为例，使用命令：<br><code>$export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/home/speedy/test/lib</code><br>在环境变量LD_LIBRARY_PATH后添加/home/speedy/test/lib(<a href="http://prefetch.net/articles/linkers.badldlibrary.html" target="_blank" rel="external">不提倡这种用法</a>)</p>
</li>
<li><p><code>ldconfig path</code>将指定目录中的动态链接库放入<strong>/etc/ld.so.cache</strong>中，从而被共享。（运行该命令后再次运行不带参数的 ldconfig 会更新<strong>/etc/ld.so.cache</strong>，这是上述命令加入的库可能不在共享了）</p>
</li>
<li><p>修改<strong>/etc/ld.so.conf</strong>文件，把库所在的路径加到文件末尾，并执行<code>sudo ldconfig</code>刷新(需要超级用户权限)，或者在<strong>/etc/ld.so.conf.d/</strong>下建立单独的 xx.conf 文件，文件内容为库文件路径</p>
</li>
</ul>
<h2 id="动态链接库的管理"><a href="#动态链接库的管理" class="headerlink" title="动态链接库的管理"></a>动态链接库的管理</h2><p>为了让新增的动态链接库能够被系统共享，需要运行动态链接库的管理命令 ldconfig。ldconfig 的作用是搜索系统默认动态链接库路径(/lib、/usr/lib、/usr/local/lib)和动态链接库配置文件(/etc/ld.so.conf)中列出的搜素路径，创建动态链接库装入程序需要的链接 和缓存文件，并写入 /etc/ld.so.cache(其中保存的是已排好序的动态链接库名字列表)</p>
<p><strong>/etc/ld.so.conf</strong>是动态链接库的搜索配置文件。在这个文件中存放着可被 Linux共享的动态链接库所在目录的名称。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cat /etc/ld<span class="selector-class">.so</span><span class="selector-class">.conf</span></div><div class="line">include /etc/ld<span class="selector-class">.so</span><span class="selector-class">.conf</span><span class="selector-class">.d</span><span class="comment">/*.conf</span></div></pre></td></tr></table></figure>
<h1 id="ldd命令"><a href="#ldd命令" class="headerlink" title="ldd命令"></a>ldd命令</h1><p>通过ldd命令可以查看某程序当前对动态链接库的依赖情况<br><img src="http://7xum8m.com1.z0.glb.clouddn.com/ldd.jpg" alt="ldd"></p>
<h1 id="链接库实例"><a href="#链接库实例" class="headerlink" title="链接库实例"></a>链接库实例</h1><h2 id="代码组织结构"><a href="#代码组织结构" class="headerlink" title="代码组织结构"></a>代码组织结构</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">test/include/hello.h</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _HELLO_H_</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> _HELLO_H_</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div></pre></td></tr></table></figure>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">libtest/<span class="class"><span class="keyword">lib</span>/<span class="title">hello</span>.<span class="title">c</span></span></div><div class="line"></div><div class="line"><span class="comment">#include "hello.h"</span></div><div class="line"><span class="comment">#include &lt;stdio.h&gt;</span></div><div class="line"></div><div class="line">void hello()</div><div class="line">&#123;</div><div class="line">	printf(<span class="string">"hello world!\n"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">libtest/src/testlib.c</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"hello.h"</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span>* argv[])</span></span></div><div class="line">&#123;</div><div class="line">	hello();</div><div class="line"></div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="静态链接库-1"><a href="#静态链接库-1" class="headerlink" title="静态链接库"></a>静态链接库</h2><h3 id="静态链接库生成"><a href="#静态链接库生成" class="headerlink" title="静态链接库生成"></a>静态链接库生成</h3><figure class="highlight crystal"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">cd /test/<span class="class"><span class="keyword">lib</span></span></div><div class="line"></div><div class="line">gcc -c -o hello.o -I../<span class="keyword">include</span> hello.c </div><div class="line">ar -rc libhello.a hello.o</div></pre></td></tr></table></figure>
<h3 id="静态链接库使用"><a href="#静态链接库使用" class="headerlink" title="静态链接库使用"></a>静态链接库使用</h3><figure class="highlight crystal"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cd ~<span class="regexp">/test/src</span></div><div class="line">gcc -o testa  testlib.c -I../<span class="keyword">include</span> -L../<span class="class"><span class="keyword">lib</span> -<span class="title">lhello</span></span></div></pre></td></tr></table></figure>
<h3 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h3><p><img src="http://7xum8m.com1.z0.glb.clouddn.com/staticlib.jpg" alt=""></p>
<h2 id="动态链接库-1"><a href="#动态链接库-1" class="headerlink" title="动态链接库"></a>动态链接库</h2><h3 id="动态链接库生成"><a href="#动态链接库生成" class="headerlink" title="动态链接库生成"></a>动态链接库生成</h3><figure class="highlight crystal"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">cd /test/<span class="class"><span class="keyword">lib</span></span></div><div class="line"></div><div class="line">gcc -o libdyhello.so hello.c -I../<span class="keyword">include</span> -fpic -shared</div></pre></td></tr></table></figure>
<h3 id="动态链接库使用"><a href="#动态链接库使用" class="headerlink" title="动态链接库使用"></a>动态链接库使用</h3><figure class="highlight crystal"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">gcc -o testso testlib.c -I../<span class="keyword">include</span> -L../<span class="class"><span class="keyword">lib</span> -<span class="title">ldyhello</span> </span></div><div class="line"></div><div class="line">sudo cp ~<span class="regexp">/test/lib</span><span class="regexp">/libdyhello.so /usr</span><span class="regexp">/lib</span></div></pre></td></tr></table></figure>
<h3 id="运行结果-1"><a href="#运行结果-1" class="headerlink" title="运行结果"></a>运行结果</h3><p><img src="http://7xum8m.com1.z0.glb.clouddn.com/dynamiclib.jpg" alt=""></p>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="http://blog.csdn.net/dongtingzhizi/article/details/8261062" target="_blank" rel="external">http://blog.csdn.net/dongtingzhizi/article/details/8261062</a><br><a href="http://www.cnblogs.com/dyllove98/archive/2013/06/25/3155599.html" target="_blank" rel="external">http://www.cnblogs.com/dyllove98/archive/2013/06/25/3155599.html</a><br>（完）</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;静/动态链接库文件都是obj目标文件的集合，静态链接库以”.a”为后缀，动态链接库以”.so”为后缀。&lt;br&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://github.com/Sword2G/sword2g.github.io/categories/Linux/"/>
    
    
      <category term="PS3" scheme="https://github.com/Sword2G/sword2g.github.io/tags/PS3/"/>
    
      <category term="Games" scheme="https://github.com/Sword2G/sword2g.github.io/tags/Games/"/>
    
  </entry>
  
  <entry>
    <title>Struct 结构与内存对齐</title>
    <link href="https://github.com/Sword2G/sword2g.github.io/2016/07/06/byte-align/"/>
    <id>https://github.com/Sword2G/sword2g.github.io/2016/07/06/byte-align/</id>
    <published>2016-07-06T14:19:59.000Z</published>
    <updated>2016-12-27T14:30:21.656Z</updated>
    
    <content type="html"><![CDATA[<p>sizeof在计算结构体大小的时候并不是简单的将成员变量相加，计算时还需要考虑内存字节对齐的问题。<br><a id="more"></a></p>
<h1 id="字节对齐原因"><a href="#字节对齐原因" class="headerlink" title="字节对齐原因"></a>字节对齐原因</h1><p>1、平台原因(移植原因)：不是所有的硬件平台都能访问任意地址上的任意数据的；某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。</p>
<p>2、性能原因(空间换取时间)：数据结构(尤其是栈)应该尽可能地在自然边界上对齐。原因在于，为了访问未对齐的内存，处理器需要作两次内存访问；而对齐的内存访问仅需要一次访问<br>关于对齐的原因参考：<a href="http://www.ibm.com/developerworks/library/pa-dalign/" target="_blank" rel="external">Data alignment: Straighten up and fly right</a></p>
<h1 id="内存不对齐后果"><a href="#内存不对齐后果" class="headerlink" title="内存不对齐后果"></a>内存不对齐后果</h1><blockquote>
<p>If you don’t understand and address alignment issues in your software, the following scenarios, in increasing order of severity, are all possible:</p>
<pre><code>* Your software will run slower.
* Your application will lock up.
* Your operating system will crash.
* Your software will silently fail, yielding incorrect results.
</code></pre></blockquote>
<h1 id="字节对齐的规则"><a href="#字节对齐的规则" class="headerlink" title="字节对齐的规则"></a>字节对齐的规则</h1><p>内存字节对齐的具体规则是由编译器决定的，不同的编译环境，内存对齐的方式略有不同。<br>总的来说，内存对齐分两个方面。（都要与#pragma pack(n)中的 n 作比较，都不能大于 n）</p>
<h2 id="成员首地址对齐"><a href="#成员首地址对齐" class="headerlink" title="成员首地址对齐"></a>成员首地址对齐</h2><p>结构体每个成员存放首地址相对结构体首地址的偏移量是(最终)自身对齐参数的整数倍。<br>(最终)自身对齐参数 = min( 自身对齐参数，#pragma pack(n) )<br><img src="http://7xum8m.com1.z0.glb.clouddn.com/align_%E5%AF%B9%E9%BD%90.png" alt="对齐参数表"></p>
<p>在 windows(32)/VC6.0 下各种类型的变量的自身对齐参数就是该类型变量所占字节数的大小，而在 linux(32)/GCC 下 double 类型的变量自身对齐参数是 4 ，是因为 linux(32)/GCC 下如果该类型变量的长度没有超过 CPU 的字长，则以该类型变量的长度作为自身对齐参数，如果该类型变量的长度超过 CPU 字长，则自身对齐参数为 CPU 字长，而 32 位系统其 CPU 字长是 4，所以linux(32)/GCC 下 double 类型的变量自身对齐参数是 4。</p>
<h2 id="结构体所占空间对齐"><a href="#结构体所占空间对齐" class="headerlink" title="结构体所占空间对齐"></a>结构体所占空间对齐</h2><p>整个结构体变量所占空间的大小是（整体）对齐参数大小的整数倍。<br>（整体）对齐参数 = min( max( 所有成员(最终)自身对齐参数）, #pragma pack(n) )</p>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p>计算步骤：</p>
<ul>
<li>是否有#pragma pack(n)<br>没有==&gt; 首地址自身对齐，整个结构按最大成员对齐<br>有====&gt; 首地址自身对齐,整个结构大小对齐都要考虑 n 的大小</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//没有设置#pragma pack进行对齐时</span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">st1</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> a; <span class="comment">// 4</span></div><div class="line">    <span class="keyword">char</span> b; <span class="comment">//1 + 1(填充供下一个short两字节对齐)</span></div><div class="line">    short c; <span class="comment">// 2</span></div><div class="line">&#125;;</div><div class="line"><span class="comment">// 4 + 2 + 2 = 8 (已经两字节对齐)</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">st2</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">char</span> a; <span class="comment">// 1 + 3(填充供下一个int 四字节对齐)</span></div><div class="line">    <span class="keyword">int</span> b; <span class="comment">// 4</span></div><div class="line">    short c; <span class="comment">// 2</span></div><div class="line">&#125;;</div><div class="line"><span class="comment">// 4 + 4 + 2 = 10(不满足4字节对齐)+ 2 = 12</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">st3</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> a; <span class="comment">//4</span></div><div class="line">    short b;<span class="comment">// 2</span></div><div class="line">    <span class="keyword">static</span> <span class="keyword">int</span> c; <span class="comment">//静态不在结构中占空间</span></div><div class="line">&#125;;</div><div class="line"><span class="comment">// 4 + 2 = 6(不满足4字节对齐)+2 = 8</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">st4</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">bool</span> a; <span class="comment">//1 + 3(供struct st1对齐，struct st14字节对齐，成员中最大的自身对齐参数)</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">st1</span></span> s; <span class="comment">// 8</span></div><div class="line">    short b;<span class="comment">//2</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">//4 + 8 + 2 = 14(不满足4字节对齐)+ 2 = 16</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">st5</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">bool</span> a; <span class="comment">//1 + 3(供struct st1对齐，struct st1 4字节对齐，成员中最大的自身对齐参数)</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">st1</span></span> s;<span class="comment">// 8 + 4 (填充供下一个double 8字节对齐)</span></div><div class="line">    double b; <span class="comment">// 8</span></div><div class="line">    <span class="keyword">int</span> c;<span class="comment">//4</span></div><div class="line">&#125;;</div><div class="line"><span class="comment">//4 + 12 + 8 + 4 = 28(不满足8字节对齐) + 4 = 32</span></div></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(2)  </span></div><div class="line"></div><div class="line"><span class="keyword">struct</span> st1</div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> a; <span class="comment">// 4</span></div><div class="line">    <span class="keyword">char</span> b; <span class="comment">//1 + 1(填充供下一个int 2字节对齐)</span></div><div class="line">    <span class="keyword">short</span> c; <span class="comment">// 2</span></div><div class="line">&#125;;</div><div class="line"><span class="comment">// 4 + 1 + 2 = 8 (已经满足1字节对齐)</span></div><div class="line"></div><div class="line"><span class="keyword">struct</span> st2</div><div class="line">&#123;</div><div class="line">    <span class="keyword">char</span> a; <span class="comment">// 1 + 1(填充供下一个int 2字节对齐)</span></div><div class="line">    <span class="keyword">int</span> b; <span class="comment">// 4</span></div><div class="line">    <span class="keyword">short</span> c; <span class="comment">// 2</span></div><div class="line">&#125;;</div><div class="line"><span class="comment">// 2 + 4 + 2 = 8(已经满足2字节对齐)</span></div><div class="line"></div><div class="line"><span class="keyword">struct</span> st3</div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> a; <span class="comment">//4</span></div><div class="line">    <span class="keyword">short</span> b;<span class="comment">// 2</span></div><div class="line">    <span class="keyword">static</span> <span class="keyword">int</span> c; <span class="comment">//静态不在结构中占空间</span></div><div class="line">&#125;;</div><div class="line"><span class="comment">// 4 + 2 = 6(满足2字节对齐)</span></div><div class="line"></div><div class="line"><span class="keyword">struct</span> st4</div><div class="line">&#123;</div><div class="line">    <span class="keyword">bool</span> a; <span class="comment">//1 + 1(供struct st1 2 )</span></div><div class="line">    <span class="keyword">struct</span> st1 s; <span class="comment">// 8</span></div><div class="line">    <span class="keyword">short</span> b;<span class="comment">//2</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">//2 + 8 + 2 = 12(满足2字节对齐)</span></div><div class="line"></div><div class="line"><span class="keyword">struct</span> st5</div><div class="line">&#123;</div><div class="line">    <span class="keyword">bool</span> a; <span class="comment">//1 + 1(供struct st1 2 字节对齐)</span></div><div class="line">    <span class="keyword">struct</span> st1 s;<span class="comment">// 8 </span></div><div class="line">    <span class="keyword">double</span> b; <span class="comment">// 8</span></div><div class="line">    <span class="keyword">int</span> c;<span class="comment">//4</span></div><div class="line">&#125;;</div><div class="line"><span class="comment">//2 + 8 + 8 + 4 = 22(满足2字节对齐)</span></div></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(4)  </span></div><div class="line"></div><div class="line"><span class="keyword">struct</span> st1</div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> a; <span class="comment">// 4</span></div><div class="line">    <span class="keyword">char</span> b; <span class="comment">//1 + 1(填充供下一个int 2字节对齐)</span></div><div class="line">    <span class="keyword">short</span> c; <span class="comment">// 2</span></div><div class="line">&#125;;</div><div class="line"><span class="comment">// 4 + 1 + 2 = 8 (已经满足4字节对齐)</span></div><div class="line"></div><div class="line"><span class="keyword">struct</span> st2</div><div class="line">&#123;</div><div class="line">    <span class="keyword">char</span> a; <span class="comment">// 1 + 3(填充供下一个int 4字节对齐)</span></div><div class="line">    <span class="keyword">int</span> b; <span class="comment">// 4</span></div><div class="line">    <span class="keyword">short</span> c; <span class="comment">// 2</span></div><div class="line">&#125;;</div><div class="line"><span class="comment">// 4 + 4 + 2 = 8(不满足4字节对齐) + 4 = 12</span></div><div class="line"></div><div class="line"><span class="keyword">struct</span> st3</div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> a; <span class="comment">//4</span></div><div class="line">    <span class="keyword">short</span> b;<span class="comment">// 2</span></div><div class="line">    <span class="keyword">static</span> <span class="keyword">int</span> c; <span class="comment">//静态不在结构中占空间</span></div><div class="line">&#125;;</div><div class="line"><span class="comment">// 4 + 2 = 6(不满足4字节对齐) + 2 = 8</span></div><div class="line"></div><div class="line"><span class="keyword">struct</span> st4</div><div class="line">&#123;</div><div class="line">    <span class="keyword">bool</span> a; <span class="comment">//1 + 3(供struct st1对齐，struct st1 4字节对齐，成员中最大的自身对齐参数)</span></div><div class="line">    <span class="keyword">struct</span> st1 s; <span class="comment">// 8</span></div><div class="line">    <span class="keyword">short</span> b;<span class="comment">//2</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">//4 + 8 + 2 = 14(满足4字节对齐) + 2 = 16</span></div><div class="line"></div><div class="line"><span class="keyword">struct</span> st5</div><div class="line">&#123;</div><div class="line">    <span class="keyword">bool</span> a; <span class="comment">//1 + 3(填充,供struct st1对齐，struct st1 4字节对齐，成员中最大的自身对齐参数)</span></div><div class="line">    <span class="keyword">struct</span> st1 s;<span class="comment">// 8 (满足double 4 字节对齐)</span></div><div class="line">    <span class="keyword">double</span> b; <span class="comment">// 8</span></div><div class="line">    <span class="keyword">int</span> c;<span class="comment">//4</span></div><div class="line">&#125;;</div><div class="line"><span class="comment">//4 + 8 + 8 + 4 = 24(满足4字节对齐)</span></div></pre></td></tr></table></figure>
<h1 id="特殊的sizeof"><a href="#特殊的sizeof" class="headerlink" title="特殊的sizeof"></a>特殊的sizeof</h1><ul>
<li>sizeof(void) gcc=1/vc 6.0编译不通过</li>
<li>sizeof(void *) 指针的大小</li>
<li>传字符数组到函数 sizeof,字符数组退化成指针 结果为指针大小</li>
<li>sizeof(空类) = 1</li>
<li>sizeof(类中有虚函数) 加上虚指针</li>
</ul>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="http://www.cnblogs.com/dolphin0520/archive/2011/09/17/2179466.html" target="_blank" rel="external">http://www.cnblogs.com/dolphin0520/archive/2011/09/17/2179466.html</a><br><a href="http://www.ibm.com/developerworks/library/pa-dalign/" target="_blank" rel="external">http://www.ibm.com/developerworks/library/pa-dalign/</a><br>（完）</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;sizeof在计算结构体大小的时候并不是简单的将成员变量相加，计算时还需要考虑内存字节对齐的问题。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>HTTPie</title>
    <link href="https://github.com/Sword2G/sword2g.github.io/2016/06/21/HTTPie/"/>
    <id>https://github.com/Sword2G/sword2g.github.io/2016/06/21/HTTPie/</id>
    <published>2016-06-21T12:57:19.000Z</published>
    <updated>2016-12-27T14:18:27.320Z</updated>
    
    <content type="html"><![CDATA[<p>HTTPie 是一个开源的 HTTP 的命令行客户端。其目标是让 CLI 和 web 服务之间的交互尽可能的人性化。<br><a id="more"></a></p>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p><code>apt-get install httpie</code></p>
<h1 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h1><p>配置文件路径为 ~/.httpie/config.json</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="attr">"__meta__"</span>: &#123;</div><div class="line">        <span class="attr">"about"</span>: <span class="string">"HTTPie configuration file"</span>,</div><div class="line">        <span class="attr">"help"</span>: <span class="string">"https://github.com/jkbr/httpie#config"</span>,</div><div class="line">        <span class="attr">"httpie"</span>: <span class="string">"0.8.0"</span></div><div class="line">    &#125;,</div><div class="line">    <span class="attr">"default_options"</span>: [],</div><div class="line">    <span class="attr">"implicit_content_type"</span>: <span class="string">"json"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><p><strong>meta</strong><br>HTTPie 元数据，一般不要更改</p>
</li>
<li><p>default_options<br>HTTPie 发送数据包时的默认选项<br>如可以设置输出样式”default_options”: [“–style=fruity”, “–body”],设置默认session为default，”–session=default”,可以使用–no-OPTION撤销默认选项，如 –no-style or –no-session</p>
</li>
<li><p>“implicit_content_type”: “json”<br>默认请求的 content_type 类型为 application/json</p>
</li>
</ul>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p><code>http [flags] [METHOD] URL [ITEM [ITEM]]</code></p>
<h3 id="输出选项"><a href="#输出选项" class="headerlink" title="输出选项"></a>输出选项</h3><ul>
<li>–headers, -h 只输出响应headers</li>
<li>–body, -b 只输出响应body</li>
<li>–verbose, -v 输出响应headers和body</li>
<li>–print, -p 可以选择如下输出部分<ul>
<li>H request headers</li>
<li>B request body</li>
<li>h response headers</li>
<li>b response body</li>
</ul>
</li>
</ul>
<h3 id="shorthand"><a href="#shorthand" class="headerlink" title="shorthand"></a>shorthand</h3><p><code>http :80 -pH</code> 将被扩展成 <code>http http://localhost:80 -pH</code></p>
<p>GET /foo HTTP/1.1<br>Host: localhost</p>
<p><code>http :/foo -pH</code> 将被扩展成 <code>http http://localhost/foo -pH</code><br>GET /foo HTTP/1.1<br>Host: localhost:</p>
<p><code>http :80/foo -pH</code> 将被扩展成 <code>http http://localhost:80/foo -pH</code><br>GET /bar HTTP/1.1<br>Host: localhost:80<br><img src="http://7xum8m.com1.z0.glb.clouddn.com/extendHeaders.jpg" alt=""></p>
<p>http :<br>GET /bar HTTP/1.1<br>Host: localhost</p>
<h3 id="Http-Headers"><a href="#Http-Headers" class="headerlink" title="Http Headers"></a>Http Headers</h3><p><code>Name:Value</code><br><code>http http://example.com User-Agent:test_agent -pH</code><br><img src="http://7xum8m.com1.z0.glb.clouddn.com/headers.jpg" alt="Headers"></p>
<p><code>http example.org User-Agent:Bacon/1.0 &#39;Cookie:valued-visitor=yes;foo=bar&#39; X-Foo:Bar Referer:http://httpie.org/ -pH</code><br><img src="http://7xum8m.com1.z0.glb.clouddn.com/headeres2.jpg" alt=""></p>
<h3 id="Querying-String"><a href="#Querying-String" class="headerlink" title="Querying String"></a>Querying String</h3><p><code>name==value</code><br><code>http example.org name==123 age==24 -pH</code><br><img src="http://7xum8m.com1.z0.glb.clouddn.com/QueryingString.jpg" alt=""></p>
<h3 id="Post-Data"><a href="#Post-Data" class="headerlink" title="Post Data"></a>Post Data</h3><h4 id="post"><a href="#post" class="headerlink" title="post"></a>post</h4><p><code>http example.org name=123 age=456 -pH</code><br><img src="http://7xum8m.com1.z0.glb.clouddn.com/postjson.jpg" alt=""></p>
<h2 id="json"><a href="#json" class="headerlink" title="json"></a>json</h2><p><code>http example.org description:=&#39;{&quot;name&quot;:&quot;sword2g&quot;,&quot;age&quot;:24}&#39; -pHB</code><br><img src="http://7xum8m.com1.z0.glb.clouddn.com/JSOn.jpg" alt="json"></p>
<h2 id="data-from-file"><a href="#data-from-file" class="headerlink" title="data from file"></a>data from file</h2><h3 id="text-string-json"><a href="#text-string-json" class="headerlink" title="text string/json"></a>text string/json</h3><p><code>http example.org name==sword2g age=@age.txt</code><br><img src="http://7xum8m.com1.z0.glb.clouddn.com/txt.jpg" alt="txtfile"></p>
<p><code>http example.org description:=@description.json</code><br><img src="http://7xum8m.com1.z0.glb.clouddn.com/json2.jpg" alt="jsonfile"></p>
<h2 id="upload-file"><a href="#upload-file" class="headerlink" title="upload file"></a>upload file</h2><p><code>http -f POST example.com/ name=sword2g cv@~/test.txt</code><br><img src="http://7xum8m.com1.z0.glb.clouddn.com/uploadfile.jpg" alt="uploadfle"></p>
<h2 id="认证"><a href="#认证" class="headerlink" title="认证"></a>认证</h2><p><code>http -a username:password example.org</code></p>
<h2 id="自动重定向"><a href="#自动重定向" class="headerlink" title="自动重定向"></a>自动重定向</h2><p><code>--follow</code><br><code>http httpbin.org/redirect/3</code><br><img src="http://7xum8m.com1.z0.glb.clouddn.com/noredirect.jpg" alt=""></p>
<p><code>http --follow --all --max-redirects=5 httpbin.org/redirect/3</code><br><img src="http://7xum8m.com1.z0.glb.clouddn.com/redirect.jpg" alt=""></p>
<h2 id="下载文件"><a href="#下载文件" class="headerlink" title="下载文件"></a>下载文件</h2><p><code>--download -d</code><br><code>http --download example.com</code><br><img src="http://7xum8m.com1.z0.glb.clouddn.com/download.jpg" alt=""></p>
<h2 id="Sessions"><a href="#Sessions" class="headerlink" title="Sessions"></a>Sessions</h2><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">http</span> <span class="comment">--session=user1 -a user1:password example.org X-Foo:Bar</span></div><div class="line"><span class="keyword">http</span> <span class="comment">--session=user1 example.org</span></div></pre></td></tr></table></figure>
<h1 id="More-details-on-Github"><a href="#More-details-on-Github" class="headerlink" title="More details on Github"></a><a href="https://github.com/jkbrzt/httpie">More details on Github</a></h1><p>（完）</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;HTTPie 是一个开源的 HTTP 的命令行客户端。其目标是让 CLI 和 web 服务之间的交互尽可能的人性化。&lt;br&gt;
    
    </summary>
    
      <category term="WAF" scheme="https://github.com/Sword2G/sword2g.github.io/categories/WAF/"/>
    
    
      <category term="HTTPie" scheme="https://github.com/Sword2G/sword2g.github.io/tags/HTTPie/"/>
    
  </entry>
  
  <entry>
    <title>WAF 之 Modsecurity</title>
    <link href="https://github.com/Sword2G/sword2g.github.io/2016/06/20/WAF-Modsecurity/"/>
    <id>https://github.com/Sword2G/sword2g.github.io/2016/06/20/WAF-Modsecurity/</id>
    <published>2016-06-20T13:42:26.000Z</published>
    <updated>2017-03-06T11:41:07.868Z</updated>
    
    <content type="html"><![CDATA[<p>WAF（Web Application Firewall）,Web 应用防火墙是通过执行一系列针对 HTTP/HTTPS 的安全策略来专门为 Web 应用提供保护的一款产品。<br><a id="more"></a></p>
<h1 id="WAF-与传统防火墙"><a href="#WAF-与传统防火墙" class="headerlink" title="WAF 与传统防火墙"></a>WAF 与传统防火墙</h1><p>传统的防火墙可以根据 IP 地址或服务端口过滤数据包。但是，它对于利用合法IP地址和端口而从事的破坏活动则无能为力。而 WAF 是一种工作在应用层的、通过特定的安全策略来专门为 Web 应用提供安全防护的产品。主要是对 Web 特有入侵方式（如 DDOS 防护、SQL 注入、XML 注入、XSS 等）进行加强防护。</p>
<h1 id="WAF-特点"><a href="#WAF-特点" class="headerlink" title="WAF 特点"></a>WAF 特点</h1><h3 id="异常协议检测"><a href="#异常协议检测" class="headerlink" title="异常协议检测"></a>异常协议检测</h3><p>Web 应用防火墙会对 HTTP 的请求进行异常检测，拒绝不符合 HTTP 标准的请求。并且，它也可以只允许 HTTP 协议的部分选项通过，从而减少攻击的影响范围。甚至，一些 Web 应用防火墙还可以严格限定 HTTP 协议中那些过于松散或未被完全制定的选项。</p>
<h3 id="增强的输入验证"><a href="#增强的输入验证" class="headerlink" title="增强的输入验证"></a>增强的输入验证</h3><p>增强输入验证，可以有效防止网页篡改、信息泄露、木马植入等恶意网络入侵行为。从而减小 Web 服务器被攻击的可能性</p>
<h3 id="及时补丁"><a href="#及时补丁" class="headerlink" title="及时补丁"></a>及时补丁</h3><p>可以针对漏洞及时充当虚拟补丁，及时屏蔽漏洞</p>
<h3 id="基于规则的保护和基于异常的保护"><a href="#基于规则的保护和基于异常的保护" class="headerlink" title="基于规则的保护和基于异常的保护"></a>基于规则的保护和基于异常的保护</h3><p>基于规则的保护可以提供各种Web应用的安全规则，WAF生产商会维护这个规则库，并时时为其更新。用户可以按照这些规则对应用进行全方面检测。还有的产品可以基于合法应用数据建立模型，并以此为依据判断应用数据的异常</p>
<h3 id="状态管理"><a href="#状态管理" class="headerlink" title="状态管理"></a>状态管理</h3><p>WAF 能够判断用户是否是第一次访问并且将请求重定向到默认登录页面并且记录事件。通过检测用户的整个操作行为我们可以更容易识别攻击。状态管理模式还能检测出异常事件（比如登陆失败），并且在达到极限值时进行处理。这对暴力攻击的识别和响应是十分有利的。</p>
<h1 id="WAF-分类"><a href="#WAF-分类" class="headerlink" title="WAF 分类"></a>WAF 分类</h1><h3 id="硬件-WAF"><a href="#硬件-WAF" class="headerlink" title="硬件 WAF"></a>硬件 WAF</h3><p>目前安全市场上，大多数的 WAF 都属于此类。它们以一个独立的硬件设备的形态存在，支持以多种方式（如透明桥接模式、旁路模式、反向代理等）部署到网络中为后端的Web应用提供安全防护。相对于软件产品类的 WAF，这类产品的优点是性能好、功能全面、支持多种模式部署等，但它的价格通常比较贵。国内的绿盟、安恒、启明星辰等厂商生产的WAF 都属于此类。</p>
<h3 id="软件-WAF"><a href="#软件-WAF" class="headerlink" title="软件 WAF"></a>软件 WAF</h3><p>采用纯软件的方式实现,安装在 Web 应用服务器上。这类WAF的代表有ModSecurity、Naxsi、网站安全狗等。</p>
<h3 id="云-WAF"><a href="#云-WAF" class="headerlink" title="云 WAF"></a>云 WAF</h3><p>随着云计算技术的快速发展，使得其于云的WAF实现成为可能。国内创新工场旗下的安全宝、360的网站宝是这类WAF的典型代表。</p>
<h1 id="ModSecurity"><a href="#ModSecurity" class="headerlink" title="ModSecurity"></a>ModSecurity</h1><p><a href="https://github.com/SpiderLabs/ModSecurity">ModSecurity</a> 是一个开源的入侵侦测与防护引擎，它主要是用于 Web 应用程序，属于 WAF，它可以作为 Apache Web 服务器的模块或是单独的应用程序来运作。</p>
<h1 id="ModSecurity-安装"><a href="#ModSecurity-安装" class="headerlink" title="ModSecurity 安装"></a>ModSecurity 安装</h1><h3 id="安装环境"><a href="#安装环境" class="headerlink" title="安装环境"></a>安装环境</h3><pre><code>OS : Ubuntu 14.04.1 LTS
Apache : Apache/2.4.7 (Ubuntu)
</code></pre><h3 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h3><p>1 安装 apache2<br><code>sudo apt-get install apache2</code></p>
<p>2 安装 libapache2-modsecurity 模块及其依赖包<code>sudo apt-get install libxml2 libxml2-dev libxml2-utils libaprutil1 libaprutil1-dev libapache2-modsecurity</code>，安装完成后可查看安装的 ModSecurity 版本 <code>dpkg -s libapache2-modsecurity | grep Version</code>。</p>
<p>3 配置文件，命令<code>sudo cp /etc/modsecurity/modsecurity.conf-recommended /etc/modsecurity/modsecurity.conf</code>,重命名 <code>/etc/modsecurity/modsecurity.conf-recommended</code> 为 <code>/etc/modsecurity/modsecurity.conf</code>。</p>
<p>4 查看日志文件<br>查看 apache2 的日志目录<code>list /var/log/apache2</code>，可以看到目录下有 access.log, error.log, other_vhosts_access.log,执行 <code>sudo service apache2 reload</code> 重启 apache2 后，查看 apache2 日志目录，可以看到新生成的日志文件 modsec_audit.log。</p>
<p>5 添加到激活规则集<br>在 /usr/share/modsecurity-crs/ 下可以看到有如下目录 activated_rules, base_rules, experimental_rules 和 optional_rules,激活的规则集都放在 /usr/share/modsecurity-crs/activated_rules/ 中，只需在该目录下建立待启用的规则集目录的符号链接即可。</p>
<p>如：要激活 base_rules 和 ptional_rules 中的规则集可以执行如下脚本</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">cd</span> /usr/share/modsecurity-crs/base_rules  </div><div class="line"><span class="keyword">for</span> f <span class="keyword">in</span> * ;    </div><div class="line"><span class="keyword">do</span> sudo ln <span class="_">-s</span> /usr/share/modsecurity-crs/base_rules/<span class="variable">$f</span> </div><div class="line">/usr/share/modsecurity-crs/activated_rules/<span class="variable">$f</span>;   </div><div class="line"><span class="keyword">done</span></div><div class="line"></div><div class="line"><span class="built_in">cd</span> /usr/share/modsecurity-crs/optional_rules</div><div class="line"><span class="keyword">for</span> f <span class="keyword">in</span> * ;</div><div class="line"><span class="keyword">do</span> sudo ln <span class="_">-s</span> /usr/share/modsecurity-crs/optional_rules/<span class="variable">$f</span> </div><div class="line">/usr/share/modsecurity-crs/activated_rules/<span class="variable">$f</span>;</div><div class="line"><span class="keyword">done</span></div></pre></td></tr></table></figure>
<p>6 开启拦截<br>更改配置文件 /etc/modsecurity/modsecurity.conf 中 SecRuleEngine DetectionOnly 为 On</p>
<p>7 更改 apache2 配置文件<br>更改文件 /etc/apache2/mods-available/security2.conf，在  前添加如下两行（顺序不能弄错）<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">IncludeOptional <span class="regexp">/usr/</span>share<span class="regexp">/modsecurity-crs/</span>*.conf        </div><div class="line">IncludeOptional <span class="regexp">/usr/</span>share<span class="regexp">/modsecurity-crs/</span>activated_rules<span class="regexp">/*.conf</span></div></pre></td></tr></table></figure></p>
<p>告知 apache2 到哪里去查找激活的规则</p>
<p>8 启用 ModSecurity 模块</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">sudo</span> a2enmod headers</div><div class="line">sudo a2enmod security2</div></pre></td></tr></table></figure>
<p>9 重启 apache2<br><code>sudo service apache2 restart</code></p>
<h3 id="ModSecurity-配置"><a href="#ModSecurity-配置" class="headerlink" title="ModSecurity 配置"></a>ModSecurity 配置</h3><p>ModSecurity 中的重要配置选项</p>
<ul>
<li><p>SecRuleEngine On<br>打开过滤引擎开关。如果是 Off，那么下面这些都不起作用了。</p>
</li>
<li><p>SecRequestBodyAccess On<br>允许过滤引擎检查请求体，如果关闭该选项则 modsecurity 无法看到 post 的任何数据</p>
</li>
<li><p>SecRule REQUEST_HEADERS:Content-Type<br>允许解析 xml 格式的请求</p>
</li>
<li><p>SecRequestBodyLimit 13107200</p>
</li>
<li><p>SecRequestBodyNoFilesLimit 131072<br>ModSecurity允许的最大请求体的缓存区大小 SecRequestBodyLimit 为文件大小，SecRequestBodyNoFilesLimit 没有文件请求提大小</p>
</li>
<li><p>SecRequestBodyInMemoryLimit 131072<br>用来保存请求体的最大内存，超过后会使用硬盘空间</p>
</li>
<li><p>SecResponseBodyAccess On<br>允许对请求体进行检查，从而辨识错误、防止数据泄露（可能会消耗内存并且对响应产生延迟）</p>
</li>
<li><p>SecResponseBodyMimeType text/plain text/html text/xml<br>希望被检查的 MIME 类型</p>
</li>
<li><p>SecResponseBodyLimit 524288<br>ModSecurity 允许的最大响应体的缓存区大小</p>
</li>
<li><p>SecTmpDir /tmp/<br>存储临时文件目录</p>
</li>
<li><p>SecDataDir /tmp/<br>存储临时数据目录</p>
</li>
<li><p>SecUploadDir /opt/modsecurity/var/upload/<br>ModSecurity 用来存放拦截的上传文件</p>
</li>
<li><p>SecUploadKeepFiles RelevantOnly<br>配置是否保存事务处理后的拦截文件</p>
</li>
<li><p>SecUploadFileMode 0600<br>设置拦截的文件的 mode</p>
</li>
</ul>
<h3 id="Modsecurity-处理阶段"><a href="#Modsecurity-处理阶段" class="headerlink" title="Modsecurity 处理阶段"></a>Modsecurity 处理阶段</h3><ul>
<li><p>请求头(REQUEST_HEADERS) 阶段（Phase 1 阶段）<br>这个阶段的 modsecurity 规则会在 apache 完成请求头的读取后立即被执行（post-read-request阶段），这时，还没有读取请求体，意味着不是所有的参数都可用。<br>如果你必须让规则尽早运行，应把规则放在这个阶段（在 apache 使用这个请求做某些事前），在请求体被读取前做些事情，从而决定是否缓存这个请求体，或者决定你将希望这个请求体如何被处理（如是否以 XML 格式解析或不解析）。</p>
</li>
<li><p>请求体(REQUEST_BODY) 阶段（Phase 2 阶段）<br>这是通用输入分析阶段，大部分传统的应用规则不会部署在这个阶段，这个阶段你肯定能收到参数（只有读取过请求体后），在请求体阶段，ModSecurity支持三种编码类型。</p>
<ul>
<li><p>application/x-www-form-urlencoded - used to transfer form data</p>
</li>
<li><p>multipart/form-data - used for file transfers</p>
</li>
<li><p>text/xml - used for passing XML data<br>大部分WEB应用还没有使用其它的编码方法。</p>
</li>
</ul>
</li>
<li><p>响应头(RESPONSE_HEADERS) 阶段（Phase 3 阶段）<br>发生在响应头被发送到客户端之前。如果你想观察响应发生前就在这儿运行，如果你想使用响应头来决定你是否想缓存响应体也行。注意一些响应状态码（如 404）在请求环的早期就被 apache 管理着，我也无法触发预期。加上apache在后面的勾子上双增加了一些响应头（如日期、服务器和连接信息等），这些我们无法触发和审查。在代理配置模式下或使用phase:5(logging)工作的较好。</p>
</li>
<li><p>响应体(RESPONSE_BODY) 阶段（Phase 4 阶段）<br>这是通用输出分析阶段，这里你能运行规则截断响应体（当然提供缓存）。这个阶段你想检查输出的HTML信息公布、错误消息和失败的验证文字。</p>
</li>
<li><p>记录(LOGGING) 阶段（Phase 5 阶段）<br>在日志发生前运行的一个阶段，放在这个阶段的规则只能影响日志记录器如何执行，这个阶段可以检测 apache 记录的错误消息，在这个阶段你不能拒绝或阻断连接，因为太迟了。</p>
</li>
</ul>
<h3 id="ModSecurity-测试"><a href="#ModSecurity-测试" class="headerlink" title="ModSecurity 测试"></a>ModSecurity 测试</h3><p>使用 HTTPie 发包工具测试</p>
<p>1 <code>http http://localhost/ a==&#39;select 0x123 from user&#39;</code><br>打开 ModSecurity 日志文件/var/log/apache2/modsec_audit.log查看具体拦截情况。<br><img src="http://7xum8m.com1.z0.glb.clouddn.com/ModSecuritysql.jpg" alt=""></p>
<p>2 测试自定义规则<br><code>sudo vim /usr/share/modsecurity-crs/activated_rules/TestRules.conf</code><br>添加如下规则,值允许上传图片</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">SecRule FILES <span class="string">"!\\.(?i:jpe?g|gif|png|bmp)$"</span> <span class="comment">"deny,tag:'WEB_ATTACK/    </span></div><div class="line">FILEUPLOAD<span class="string">',msg:'</span>upload <span class="keyword">no</span>-picture <span class="keyword">file</span><span class="string">',id:0000001,phase:2"</span></div></pre></td></tr></table></figure>
<p>上传文件名中不允许含有0</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">SecRule</span> FILES <span class="string">"<span class="variable">@contains</span> 0"</span> <span class="string">"deny,tag:'WEB_ATTACK/      </span></div><div class="line">FILEUPLOAD',msg:'filename has null character',id:0000002,phase:2"</div></pre></td></tr></table></figure>
<p>在 /var/www/html 下新建 upload.html</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;<span class="keyword">form</span> enctype=<span class="string">"multipart/form-data"</span> method=<span class="string">"post"</span> action=<span class="string">"http://example.com/jobs"</span>&gt;</div><div class="line">    &lt;<span class="keyword">input</span> <span class="keyword">type</span>=<span class="string">"text"</span> name=<span class="string">"name"</span> /&gt;</div><div class="line">    &lt;<span class="keyword">input</span> <span class="keyword">type</span>=<span class="string">"file"</span> name=<span class="string">"cv"</span> /&gt;</div><div class="line">    &lt;<span class="keyword">input</span> <span class="keyword">type</span>=<span class="string">"submit"</span>/&gt;</div><div class="line">&lt;/<span class="keyword">form</span>&gt;</div></pre></td></tr></table></figure>
<p><code>http -f POST http://localhost/upload.html name=&#39;testfile&#39; cv@~/testMod/a.php</code><br>上传php文件，相关拦截日志如下<br><img src="http://7xum8m.com1.z0.glb.clouddn.com/ModSecurityphp.jpg" alt=""></p>
<p><code>http -f POST http://localhost/upload.html name=&#39;testfile&#39; cv@~/testModSeciurity/0.png</code><br>上传0.png，相关拦截日志如下<br><img src="http://7xum8m.com1.z0.glb.clouddn.com/ModSecuritynull.jpg" alt=""></p>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="http://netsecurity.51cto.com/art/201004/195250_all.htm" target="_blank" rel="external">http://netsecurity.51cto.com/art/201004/195250_all.htm</a><br><a href="http://ubuntuforums.org/showthread.php?t=2219109" target="_blank" rel="external">http://ubuntuforums.org/showthread.php?t=2219109</a><br><a href="http://www.freebuf.com/articles/web/43559.html" target="_blank" rel="external">http://www.freebuf.com/articles/web/43559.html</a><br>（完）</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;WAF（Web Application Firewall）,Web 应用防火墙是通过执行一系列针对 HTTP/HTTPS 的安全策略来专门为 Web 应用提供保护的一款产品。&lt;br&gt;
    
    </summary>
    
      <category term="WAF" scheme="https://github.com/Sword2G/sword2g.github.io/categories/WAF/"/>
    
    
      <category term="Modsecurity" scheme="https://github.com/Sword2G/sword2g.github.io/tags/Modsecurity/"/>
    
  </entry>
  
  <entry>
    <title>C Standard I/O</title>
    <link href="https://github.com/Sword2G/sword2g.github.io/2016/06/01/C-standard-io/"/>
    <id>https://github.com/Sword2G/sword2g.github.io/2016/06/01/C-standard-io/</id>
    <published>2016-06-01T13:23:45.000Z</published>
    <updated>2016-12-26T13:41:49.545Z</updated>
    
    <content type="html"><![CDATA[<p>C/C++ 的输入输出并不是以其语言本身为基础实现的，换句话说，C 和 C++ 本身都没有为输入和输出提供专门的语句结构。输入输出留给了编译器来实现。C 语言的输入输出是由标准 I/O 函数库（stdio.h）来实现的，C++ 是由标准类库（iostream 和 fstream）来实现的。<br><a id="more"></a></p>
<h1 id="流"><a href="#流" class="headerlink" title="流"></a>流</h1><p>C 程序把输入输出看做流，所有的 I/O 操作可以看作是简单的把字节移入或者移出程序。输入流中的字节可能来自键盘、其他存储设备或其他程序，输出流可以流向屏幕、 打印机、存储设备或其他程序。流充当了程序和流源或流目标之间的桥梁，因此，特定I/O设备的细节对程序来说是透明的。</p>
<h1 id="缓冲"><a href="#缓冲" class="headerlink" title="缓冲"></a>缓冲</h1><p>使用缓冲的目的是为了提高输入输出的效率，减少read、write调用的次数。缓冲区其实就是一块作为中介的内存块，而“读取” 就是从缓冲区复制数据到程序，“写入”就是将数据从程序复制到缓冲区。通常像磁盘驱动器这样的设备以 512 字节的块为单位来传输信息，而程序通常每次只能处理一个字节信息。逐个字节读取然后处理是十分低效的，因为从磁盘读取一个字节需要大量的硬件活动。缓冲区的目的就是为了帮助匹配这两种不同信息传输效率。有了缓冲区就可以先从磁盘读取大块数据，然后再逐字节传送给程序处理。</p>
<h2 id="键盘缓冲"><a href="#键盘缓冲" class="headerlink" title="键盘缓冲"></a>键盘缓冲</h2><p>键盘每次提供一个字符，事实上无需缓冲，然而对键盘的缓冲可以允许用户在将键入的数据传送给程序之前做更改。这就是为什么很多程序在键入回车以后（刷新输入缓冲区），程序才开始处理输入的数据。</p>
<h2 id="缓冲类型"><a href="#缓冲类型" class="headerlink" title="缓冲类型"></a>缓冲类型</h2><h3 id="全缓冲"><a href="#全缓冲" class="headerlink" title="全缓冲"></a>全缓冲</h3><p>在填满 I/O 缓冲区之后才进行实际的 I/O 操作。对于驻留在磁盘上的文件，通常是由标准 I/O 库实施全缓冲，在一个流上第一次执行 I/O 操作的时候，相关标准 I/O 将调用 malloc 获得所需的缓冲区。缓冲区在填满的时候自动刷新，或者调用 fflush 进行刷新，fflush 迫使缓冲区数据立即写入而不管缓冲区是否已满。</p>
<h3 id="行缓冲"><a href="#行缓冲" class="headerlink" title="行缓冲"></a>行缓冲</h3><p>当输入输出中遇到换行符的时候执行 I/O 操作。当流涉及到终端设备时使用行缓冲。</p>
<h3 id="不缓冲"><a href="#不缓冲" class="headerlink" title="不缓冲"></a>不缓冲</h3><p>不使用缓冲区，直接执行 I/O 操作。标准错误流一般使用不带缓冲的，从而使错误信息尽快的输出。</p>
<h2 id="ISO-C-缓冲特性"><a href="#ISO-C-缓冲特性" class="headerlink" title="ISO C 缓冲特性"></a>ISO C 缓冲特性</h2><ul>
<li><p>标准输入和标准输出不指向交互式设备时，他们才是全缓冲。（通常标注输入设备是键盘，标准输出设备是终端或屏幕，可以通过重定向来改变输入输出指向的设备）</p>
</li>
<li><p>标准错误绝对不是全缓冲</p>
</li>
<li><p>指向终端设备的流是行缓冲，否则是全缓冲</p>
</li>
</ul>
<h2 id="相关函数"><a href="#相关函数" class="headerlink" title="相关函数"></a>相关函数</h2><p><code>void setbuf(FILE *stream, char *buf);</code></p>
<p>setbuf 函数具有打开和关闭缓冲机制。为了带缓冲进行 I/O，参数 buf 必须指向一个长度为 BUFSIZ (定义在 stdio.h 头文件中)的缓冲区。通常在此之后该流就是全缓冲的，但是如果该流与一个终端设备相关，那么某些系统也可以将其设置为行缓冲。为了关闭缓冲，可以将 buf 参数设置为 NULL。</p>
<p><code>int setvbuf(FILE *stream, char *buf, int mode, size_t size);</code></p>
<ul>
<li><p>mode ：期望缓冲区的类型：</p>
<ul>
<li>_IOFBF(满缓冲）：当缓冲区为空时，从流读入数据。或者当缓冲区满时，向流写入数 据。</li>
<li>_IOLBF(行缓冲）：每次从流中读入一行数据或向流中写入一行数据。<br><em>_IONBF(无缓冲）：直接从流中读入数据或直接向流中写入数据，而没有缓冲区。
</em>size ：缓冲区内字节的数量</li>
</ul>
</li>
</ul>
<p>一般而言，应该由系统选择缓冲区的长度并自动分配缓冲区，在关闭流时，标准 I/O 库自动释放缓冲区。</p>
<h1 id="输入输出相关函数"><a href="#输入输出相关函数" class="headerlink" title="输入输出相关函数"></a>输入输出相关函数</h1><h2 id="打开流"><a href="#打开流" class="headerlink" title="打开流"></a>打开流</h2><p><code>FILE * fopen(const char * restrict path, const char * restrict mode);</code><br>打开一个特定的文件，并把一个流和这个文件相关联</p>
<p><strong>Note ：以读写方式（mode+）打开一个流的时候具有以下限制：</strong></p>
<ul>
<li>输出之后跟输入必须调用 flush 、fseek、fsetpos、rewind</li>
<li>输入之后跟输出必须调用 fseek、fsetpos、rewind<br><code>FILE freopen(const char restrict filename, const char restrict mode, FILE * restrict stream);</code><br>打开或重新打开一个特定的流（如stdin、stdout、stderr）。函数首先试图关闭这个流，然后用指定的文件和模式重新打开这个流，失败返回NULL，打开成功返回它的第三个参数值。</li>
</ul>
<h2 id="关闭流"><a href="#关闭流" class="headerlink" title="关闭流"></a>关闭流</h2><p>int fclose( FILE *fp );</p>
<p>关闭一个打开的流，成功返回 0 ,失败返回 EOF(-1)。<br>在文件被关闭之前，刷新输出缓冲区中的数据，丢弃输入缓冲区中的数据。如果标准 I/O 库已经为该流自动分配了一个缓冲区，则释放该缓冲区。</p>
<h2 id="读写流"><a href="#读写流" class="headerlink" title="读写流"></a>读写流</h2><h3 id="非格式化IO"><a href="#非格式化IO" class="headerlink" title="非格式化IO"></a>非格式化IO</h3><h4 id="字符IO"><a href="#字符IO" class="headerlink" title="字符IO"></a>字符IO</h4><h5 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">getc</span><span class="params">(FILE *fp)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">fgetc</span><span class="params">(FILE *fp)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">getchar</span><span class="params">(<span class="keyword">void</span>)</span></span>;</div></pre></td></tr></table></figure>
<p>前两个函数区别在于 getc 可以被实现为宏，fgetc 不可以。因此 getc 调用要快一些。getchar() 等价于 getc(stdin)</p>
<p><strong>Note ：返回值的类型为 int 这样就可以返回所有字符的值加上一个出错或者到达文件尾的指示值EOF 区分 error/eof，也就是说不能将这三个函数的返回值存储在 char 类型的变量中，因为这些函数的返回值以后还要跟 EOF 作比较。</strong></p>
<h5 id="区分-error-eof"><a href="#区分-error-eof" class="headerlink" title="区分 error/eof"></a>区分 error/eof</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">ferror</span><span class="params">(FILE *fp)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">feof</span><span class="params">(FILE *fp)</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">fclearerr</span><span class="params">(FILE *fp)</span></span>;</div></pre></td></tr></table></figure>
<p>fclearerr 函数清除出错标志和文件尾标志。</p>
<h5 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">putc</span><span class="params">(<span class="keyword">int</span> c, FILE *fp)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">fputc</span><span class="params">(<span class="keyword">int</span> c, FILE *fp)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">putchar</span><span class="params">(<span class="keyword">int</span> c)</span></span>;</div></pre></td></tr></table></figure>
<p>和输入类似，putc 可以被实现为宏，fputc 不可以。putchar(c) 等价于 putc(c,stdout)</p>
<h5 id="撤销字符"><a href="#撤销字符" class="headerlink" title="撤销字符"></a>撤销字符</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">ungetc</span><span class="params">(<span class="keyword">int</span> c, FILE *fp)</span></span>;</div></pre></td></tr></table></figure>
<p>将之前读出的字符压送回流中（并没有写到底层文件或者设备中，只是将它写回到流缓冲区中），以后可以重新读取。</p>
<h4 id="行-I-O"><a href="#行-I-O" class="headerlink" title="行 I/O"></a>行 I/O</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">char</span> *<span class="title">fgets</span><span class="params">(<span class="keyword">char</span> *<span class="keyword">restrict</span> buf, <span class="keyword">int</span> n, FILE *fp)</span></span>;</div><div class="line"><span class="function"><span class="keyword">char</span> *<span class="title">gets</span><span class="params">(<span class="keyword">char</span> *buf)</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">fputs</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> buf, FILE *fp)</span></span></div><div class="line"><span class="keyword">int</span> <span class="title">puts</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *buf)</span></div></pre></td></tr></table></figure>
<p><strong>Note ：gtes 在读取一行的时候并不存储换行符，puts在输出的时候会在输出后在添加一个换行符，fgets、fputs 与其不同,推荐使用 fgets、fputs，因为 gets 不安全，可能造成缓冲区溢出。</strong></p>
<h4 id="二进制-I-O"><a href="#二进制-I-O" class="headerlink" title="二进制 I/O"></a>二进制 I/O</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">size_t</span> fread(<span class="keyword">void</span> *buffer, <span class="keyword">size_t</span> size, <span class="keyword">size_t</span> count, FILE *fp);</div><div class="line"><span class="keyword">size_t</span> fwrite(<span class="keyword">void</span> *buffer, <span class="keyword">size_t</span> size , <span class="keyword">size_t</span> count, FILE *fp);</div></pre></td></tr></table></figure>
<p>从（向）fp中读或者写 count 个每个大小为 size 的对象<br>对于读，如果返回值小于 count 则需要使用 feof 或 ferror 判断是哪种情况<br>对于写，如果返回值小于 count 则出错</p>
<h3 id="格式化IO"><a href="#格式化IO" class="headerlink" title="格式化IO"></a>格式化IO</h3><h4 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">scanf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> format, ...)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">fscanf</span><span class="params">(FILE *fp, <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> format, ...)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">sscanf</span><span class="params">(<span class="keyword">char</span> *<span class="keyword">restrict</span> buf, <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> format, ...)</span></span>;</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">printf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> format, ...)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">fprintf</span><span class="params">(FILE *fp, <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> format, ...)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">sprintf</span><span class="params">(<span class="keyword">char</span> *<span class="keyword">restrict</span> buf, <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> format, ...)</span></span>;</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdarg.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">vprintf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> format, va_list arg)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">vfprintf</span><span class="params">(FILE *fp,<span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> format, va_list arg)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">vsprintf</span><span class="params">(<span class="keyword">char</span> *<span class="keyword">restrict</span> buf, <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> format, va_list arg)</span></span>;</div></pre></td></tr></table></figure>
<h4 id="定位流"><a href="#定位流" class="headerlink" title="定位流"></a>定位流</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">long</span> <span class="title">ftell</span><span class="params">(FILE *fp)</span></span>;</div><div class="line"><span class="function"><span class="keyword">long</span> <span class="title">fseek</span><span class="params">(FILE *fp, <span class="keyword">long</span> offset, <span class="keyword">int</span> whence)</span></span>;</div></pre></td></tr></table></figure>
<ul>
<li><p>对于二进制文件 以字节为度量单位<br>fseek 的 whence 字段可以为</p>
<ul>
<li>SEEK_SET 文件起始位置</li>
<li>SEEK_CUR 文件当前位置</li>
<li>SEEK_END 文件结束位置</li>
</ul>
</li>
<li><p>对于文本文件 可能不以字节为单位<br>whence 的值只能为SEEK_SET，而且 offset 的值只能为</p>
<ul>
<li>0 后退到文件的起始位置</li>
<li>对该文件的ftell返回的值</li>
</ul>
</li>
</ul>
<p><code>void rewind(FILE *fp);</code><br>将一个流设置到文件的起始位置。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">getpos</span><span class="params">(FILE *<span class="keyword">restrict</span> fp, <span class="keyword">fpos_t</span> *<span class="keyword">restrict</span> pos)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">setpos</span><span class="params">(FILE *<span class="keyword">restrict</span> fp, <span class="keyword">const</span> <span class="keyword">fpos_t</span> *pos)</span></span>;</div></pre></td></tr></table></figure>
<p>将当前位置指示器的值存入由pos指向的对象中，在以后的fsetpos调用时，可以使用此值将流重新定位至该位置。</p>
<h1 id="参考书籍"><a href="#参考书籍" class="headerlink" title="参考书籍"></a>参考书籍</h1><p><a href="https://book.douban.com/subject/25900403/" target="_blank" rel="external">UNIX环境高级编程（第3版）</a><br><a href="https://book.douban.com/subject/3012360/" target="_blank" rel="external">C和指针</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;C/C++ 的输入输出并不是以其语言本身为基础实现的，换句话说，C 和 C++ 本身都没有为输入和输出提供专门的语句结构。输入输出留给了编译器来实现。C 语言的输入输出是由标准 I/O 函数库（stdio.h）来实现的，C++ 是由标准类库（iostream 和 fstream）来实现的。&lt;br&gt;
    
    </summary>
    
      <category term="C/C++" scheme="https://github.com/Sword2G/sword2g.github.io/categories/C-C/"/>
    
    
      <category term="standard I/O" scheme="https://github.com/Sword2G/sword2g.github.io/tags/standard-I-O/"/>
    
  </entry>
  
  <entry>
    <title>Syslog</title>
    <link href="https://github.com/Sword2G/sword2g.github.io/2016/05/26/syslog/"/>
    <id>https://github.com/Sword2G/sword2g.github.io/2016/05/26/syslog/</id>
    <published>2016-05-26T13:00:55.000Z</published>
    <updated>2016-12-28T14:59:10.565Z</updated>
    
    <content type="html"><![CDATA[<p>在类 Unix 操作系统上，syslog 广泛应用于系统日志。该机制负责发送、记录系统内核、守护进程及应用程序所产生的信息，它由 syslogd 守护进程、syslog 调用和配置文件 /etc/syslog.conf 三部分组成。<br><a id="more"></a></p>
<h1 id="syslogd-守护进程"><a href="#syslogd-守护进程" class="headerlink" title="syslogd 守护进程"></a>syslogd 守护进程</h1><p>syslog协议分为客户端和服务器端，客户端是产生日志消息的一方，而服务器端负责接收客户端发送来的日志消息，并做出保存到特定的日志文件中或者其他方式的处理。<br>在Unix中，常见的 syslog 服务器端程序是 syslogd 守护程序。</p>
<h2 id="syslogd-启动方式"><a href="#syslogd-启动方式" class="headerlink" title="syslogd 启动方式"></a>syslogd 启动方式</h2><p>Unix 系统中的 syslogd 守护进程通常由某个系统初始化脚本启动，在工作期间一直运行。</p>
<h2 id="syslogd-启动步骤"><a href="#syslogd-启动步骤" class="headerlink" title="syslogd 启动步骤"></a>syslogd 启动步骤</h2><p>1 读取配置文件。默认的配置文件为 /etc/syslog.conf，该配置文件指定了本守护进程可能收取的各种日志消息应该如何处理（如添加到一个文件、输出到控制台、写到指定用户的登录窗口，转发到另一个主机的 syslogd 进程）。<br>2 创建一个 Unix 域套接字，给他捆绑路径名 /dev/log<br>3 创建一个 UDP 套接字，给他捆绑端口 514<br>4 打开路径名 /dev/klog，记录来自内核的日志消息</p>
<h1 id="syslog-接口调用"><a href="#syslog-接口调用" class="headerlink" title="syslog 接口调用"></a>syslog 接口调用</h1><h2 id="函数原型"><a href="#函数原型" class="headerlink" title="函数原型"></a>函数原型</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;syslog.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;syslog.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">openlog</span> <span class="params">(<span class="keyword">char</span>*ident, <span class="keyword">int</span> option, <span class="keyword">int</span> facility)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">syslog</span><span class="params">(<span class="keyword">int</span> priority, <span class="keyword">char</span>* format, ……)</span></span></div><div class="line"><span class="keyword">void</span> <span class="title">closelog</span><span class="params">(<span class="keyword">void</span>)</span>;</div></pre></td></tr></table></figure>
<h2 id="openlog"><a href="#openlog" class="headerlink" title="openlog"></a>openlog</h2><p>openlog 是可选择的。如果不调用 openlog ，则在第一次调用 syslog 的时候自动调用 openlog</p>
<h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p>ident 参数是一个由 syslog 冠于每个日志消息之前的字符串，一般是程序名称；<br>options 参数由LOG_CONS、LOG_NDELAY、LOG_PERROR、LOG_PID中的一个或者多个标志位逻辑或构成；</p>
<pre><code>LOG_CONS 若无法发送到 syslogd 守护进程则登记到控制台
LOG_NDELAY openlog 被调用时，通常不立即打开 UNIX 域套接字，直到 syslog 函数调用时才打开，该参数指定立即打开
LOG_PERROR 既发送到 syslogd，又登记到标准错误输出
LOG_PID 每条消息都登记进程pid
</code></pre><p>facility 为没有指定设施的后续 syslog() 调用指定一个默认值。</p>
<h2 id="syslog"><a href="#syslog" class="headerlink" title="syslog"></a>syslog</h2><p>syslog 产生一个日志消息，priority 参数是 facility（标识消息发送进程） 和 level（标识消息级别）的组合。<br><strong>P.S.默认的 level 是 LOG_NOTICE，默认的 facility 是 LOG_USER<br>syslog 中的 format 类似于 printf，增设了 %m ，它被替换成当前 errno 对应的出错消息</strong><br><img src="http://7xum8m.com1.z0.glb.clouddn.com/hexo_syslog_syslog_level.jpg" alt="facility"><br><img src="http://7xum8m.com1.z0.glb.clouddn.com/hexo_syslog_syslog_level.jpg" alt="level"></p>
<h2 id="closelog"><a href="#closelog" class="headerlink" title="closelog"></a>closelog</h2><p>应用进程不再需要发送日志消息是关闭</p>
<h1 id="配置文件-etc-syslog-conf"><a href="#配置文件-etc-syslog-conf" class="headerlink" title="配置文件 /etc/syslog.conf"></a>配置文件 /etc/syslog.conf</h1><p>对每类消息提供一个选择域和一个动作域，选择域指明消息的类型和优先级（syslogd 将记录一个拥有相同或更高优先级的消息），动作域指明syslogd 接收到一个与选择标准相匹配的消息时所执行的动作，这些域由 tab 隔开。<br>syslog.conf 行的基本语法是：消息类型.优先级 动作域</p>
<h2 id="消息类型"><a href="#消息类型" class="headerlink" title="消息类型"></a>消息类型</h2><p><img src="http://7xum8m.com1.z0.glb.clouddn.com/hexo_syslog_log_type.jpg" alt="log_type"></p>
<h2 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h2><p><img src="http://7xum8m.com1.z0.glb.clouddn.com/hexo_syslog_log_priority.jpg" alt="log_priority"></p>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><pre><code>kern.* /dev/console
local17.debug /var/log/cisco.log
所有的内核消息登记到控制台，来自 local17 的所有 debug 消息添加到 /var/log/cisco.log
</code></pre><h1 id="syslog-应用场景"><a href="#syslog-应用场景" class="headerlink" title="syslog 应用场景"></a>syslog 应用场景</h1><p>网络管理工具<br>安全管理系统<br>日志审计系统<br>可以让任何事件都以网络行为日志的方式登记到一台或多台服务器上，以备后台数据库用off-line(离线) 方式分析远端设备事件，追踪掌握与设备和网络有关的状况并作响应<br>大多数守护进程的日志信息都使用 syslog 设施</p>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="http://blog.chinaunix.net/uid-25120309-id-3359929.html" target="_blank" rel="external">http://blog.chinaunix.net/uid-25120309-id-3359929.html</a><br><a href="http://blog.csdn.net/tonyxf121/article/details/7934824" target="_blank" rel="external">http://blog.csdn.net/tonyxf121/article/details/7934824</a><br>（完）</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在类 Unix 操作系统上，syslog 广泛应用于系统日志。该机制负责发送、记录系统内核、守护进程及应用程序所产生的信息，它由 syslogd 守护进程、syslog 调用和配置文件 /etc/syslog.conf 三部分组成。&lt;br&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://github.com/Sword2G/sword2g.github.io/categories/Linux/"/>
    
    
      <category term="Syslog 协议" scheme="https://github.com/Sword2G/sword2g.github.io/tags/Syslog-%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>套接字选项</title>
    <link href="https://github.com/Sword2G/sword2g.github.io/2016/05/17/socket-options/"/>
    <id>https://github.com/Sword2G/sword2g.github.io/2016/05/17/socket-options/</id>
    <published>2016-05-17T02:30:49.000Z</published>
    <updated>2017-03-03T12:32:54.510Z</updated>
    
    <content type="html"><![CDATA[<p>通过套接字选项可以获得、设置套接字的行为属性。<br><a id="more"></a></p>
<h1 id="getsockopt-和-setsockopt-函数"><a href="#getsockopt-和-setsockopt-函数" class="headerlink" title="getsockopt 和 setsockopt 函数"></a>getsockopt 和 setsockopt 函数</h1><h2 id="函数原型"><a href="#函数原型" class="headerlink" title="函数原型"></a>函数原型</h2><p>int getsockopt(int sockfd, int level,<br>int optname, void <em>optval, socklen_t </em>optlen);</p>
<p>int setsockopt(int sockfd, int level,<br>int optname, const void <em>optval, socklen_t </em>optlen);</p>
<h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><blockquote>
<p>sockfd： 已打开的套接字描述符<br>level：  指定系统中解释选项的代码。（通用套接字代码，特定于协议的代码）<br>optname：套接字选项名称<br>optval： 指向某个变量的指针，setsockopt从<em>optval（值参数）中取得选项待设置的新值，getsockopt把已获得的选项的当前值存入</em>optval（值-结果参数）中。<br>optlen： 选项类型的长度</p>
</blockquote>
<h1 id="套接字选项"><a href="#套接字选项" class="headerlink" title="套接字选项"></a>套接字选项</h1><p>套接字选项粗分为两大类：</p>
<ul>
<li>启用和禁止某个特性的二元选项</li>
<li>取得并返回我们可以设置或检查的特定值选项</li>
</ul>
<h2 id="常见的套接字选项"><a href="#常见的套接字选项" class="headerlink" title="常见的套接字选项"></a>常见的套接字选项</h2><p><img src="http://7xum8m.com1.z0.glb.clouddn.com/socket_optssockets_options.jpg" alt="套接字选项"></p>
<h2 id="SOL-SOCKET（通用套接字选项）"><a href="#SOL-SOCKET（通用套接字选项）" class="headerlink" title="SOL_SOCKET（通用套接字选项）"></a>SOL_SOCKET（通用套接字选项）</h2><h3 id="SO-BROADCAST"><a href="#SO-BROADCAST" class="headerlink" title="SO_BROADCAST"></a>SO_BROADCAST</h3><p>开启或禁止进程发送广播消息的能力，默认情况下，本选项关闭。只有数据报套接字（SOCK_DGRAM）支持广播，并且还必须在支持广播消息的网络上（以太网、令牌环网），不可能在p2p网络上广播，也不可能在基于链连接的网络上广播。</p>
<h3 id="SO-DEBUG"><a href="#SO-DEBUG" class="headerlink" title="SO_DEBUG"></a>SO_DEBUG</h3><p>开启或禁止套接字调试功能，仅支持TCP协议。该选项打开时，内核跟踪此套接字上发送和接收的数据，并将调试信息保存到一个环形缓冲区中。可使用trpt程序进行检查。</p>
<h3 id="SO-ERROR"><a href="#SO-ERROR" class="headerlink" title="SO_ERROR"></a>SO_ERROR</h3><p>通过该套接字获得套接字错误。<br>当套接字发生错误时，源自 Berkeley 的内核将内核中该套接字的 so_error 变量设置为标准的 Unix_Exxx 的值。<br>内核以两种方式通知用户进程：</p>
<ul>
<li>使用 select，进程阻塞在 select，函数返回 -1,。无论是检查可读还是可写条件，select 均会返回并设置其中一个或两个条件</li>
<li>使用信号驱动 I/O，给进程或进程组发送一个 SIGIO 信号</li>
</ul>
<h3 id="SO-DONTROUTE"><a href="#SO-DONTROUTE" class="headerlink" title="SO_DONTROUTE"></a>SO_DONTROUTE</h3><p>规定底层的分组将绕过底层协议的正常路由机制。。分组将按照发送数据的目的地址和子网掩码选择一个合适的网络接口进行发送。</p>
<h3 id="SO-KEEPALIVE"><a href="#SO-KEEPALIVE" class="headerlink" title="SO_KEEPALIVE"></a>SO_KEEPALIVE</h3><p>如果在 2 小时内该套接字的任一方向没有数据交换，TCP就发送探测报文。<br>对端可能有一下三种情况发生：</p>
<ul>
<li>对端以期望的ACK响应</li>
<li>对端以RST响应</li>
<li>对端没有响应 ==&gt; 两两相隔 75s 另外发送 8 个探测报文</li>
</ul>
<h3 id="SO-LINGER"><a href="#SO-LINGER" class="headerlink" title="SO_LINGER"></a>SO_LINGER</h3><p>指定close函数对面向连接的协议如何操作。</p>
<h4 id="linger数据结构"><a href="#linger数据结构" class="headerlink" title="linger数据结构"></a>linger数据结构</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">struct</span> linger&#123;</div><div class="line">	<span class="keyword">int</span> l_onoff;</div><div class="line">	<span class="keyword">int</span> l_linger;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>l_onoff 为 0，套接字该选项关闭，默认情况。close函数立即返回，如果套接字发送缓冲区中还有数据，系统试着把数据发送给对端。存在无法确认是否发送成功的问题。</li>
<li>l_onoff 非 0 且 l_linger 为 0 。丢弃发送缓冲区中的数据，并发送 RST 给对端。 </li>
<li>l_onoff 非 0 且 l_linger 非 0 。内核将拖延一段时间，如果发送缓冲区中仍然残留数据，进程投入睡眠（ close 阻塞），直到数据发送完成<strong>并且被对方确认</strong>或者超时。如果在数据发送完并确认之前超时，close 返回 EWOULDBLOCK ，close成功仅仅代表先前发送的数据已经被对端TCP确认，但是依然存在无法确认应用程序是否成功读取数据的问题。需要使用应用级的 ACK。</li>
</ul>
<h3 id="SO-RCVBUF-和-SO-SNDBUF"><a href="#SO-RCVBUF-和-SO-SNDBUF" class="headerlink" title="SO_RCVBUF 和 SO_SNDBUF"></a>SO_RCVBUF 和 SO_SNDBUF</h3><p>设置套接字接收发送缓冲区大小（在内核中）。</p>
<ul>
<li>UDP 发送缓冲区中的数据，发送后就可以丢弃，接收缓冲区中的数据需要等待应用程序读取，UDP 没有流量控制，如果发送的数据量大于缓冲区大小，则丢弃数据。</li>
<li>TCP 有流量控制，接收缓冲区大小就是滑动窗口大小。接受缓冲区不可能溢出，因为不允许对端发送超过本端所通告窗口的大小，对于对端无视通知大小发送的数据，直接丢弃。</li>
</ul>
<p>该选项，客户端在 connect 之前设置，服务器端在 listen 之前给监听套接字设置。</p>
<h3 id="SO-RCVLOWAT-和-SO-SNDLOWAT"><a href="#SO-RCVLOWAT-和-SO-SNDLOWAT" class="headerlink" title="SO_RCVLOWAT 和 SO_SNDLOWAT"></a>SO_RCVLOWAT 和 SO_SNDLOWAT</h3><p>设置每个套接字的接收低水位线和发送低水位线。它们由 select 函数使用</p>
<h3 id="SO-REUSEADDR"><a href="#SO-REUSEADDR" class="headerlink" title="SO_REUSEADDR"></a>SO_REUSEADDR</h3><p>允许重复使用本地地址和端口。</p>
<h2 id="IPPROTO-IP（IPv4套接字选项）"><a href="#IPPROTO-IP（IPv4套接字选项）" class="headerlink" title="IPPROTO_IP（IPv4套接字选项）"></a>IPPROTO_IP（IPv4套接字选项）</h2><h3 id="IP-HDRINCL"><a href="#IP-HDRINCL" class="headerlink" title="IP_HDRINCL"></a>IP_HDRINCL</h3><p>一般情况下，Linux内黑会自动计算和填充IP头部数据。如果套接字是一个原始套接字，则IP头部需要用户手动填充。通常在用户自定义数据包格式的时候使用。注意，一旦该选项生效，用户发送的IP数据包将不在进行分片。因此用户的数据包不能太大，否则网卡不能发送。</p>
<h2 id="IPPROTO-TCP（TCP套接字选项）"><a href="#IPPROTO-TCP（TCP套接字选项）" class="headerlink" title="IPPROTO_TCP（TCP套接字选项）"></a>IPPROTO_TCP（TCP套接字选项）</h2><h3 id="TCP-MAXSEG"><a href="#TCP-MAXSEG" class="headerlink" title="TCP_MAXSEG"></a>TCP_MAXSEG</h3><p>获得/设置 TCP 连接的最大分节大小（MSS）</p>
<h3 id="TCP-NODELY"><a href="#TCP-NODELY" class="headerlink" title="TCP_NODELY"></a>TCP_NODELY</h3><p>开启本选项将禁止Nagle算法</p>
<p>####　Nagle算法<br>Nagle算法的目的在于减少广域网上的小分组（小于MSS的分组）数目。<br>Nagle算法的基本原理如下：</p>
<ul>
<li><p>尽可能的发送最大大小分组，防止一个连接在任何时刻有多个小分组待确认。<br><img src="http://7xum8m.com1.z0.glb.clouddn.com/ocket_optsnagle1.jpg" alt="Nagle算法"><br><img src="http://7xum8m.com1.z0.glb.clouddn.com/socket_optsnagle0.jpg" alt="禁止Nagle算法"></p>
</li>
<li><p>ACK 延迟算法（捎带确认）。TCP 在接收到数据后并不马上发送 ACK 确认，而是等待一小段时间，然后才发送 ACK<br>以期待这一小段时间内自己有数据发送到对端，被延迟的 ACK 就可以由这段数据捎带，从而省略一个 TCP 报文</p>
</li>
</ul>
<h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><p>对于服务器不在相反方向产生数据以携带 ACK 的客户来说，ACK 延迟算法存在明显的延迟，因为客户需要等到 ACK 延迟定时器超时才会收到 ACK 确认，从而继续发送数据，此时需要禁止Nagle算法。</p>
<h1 id="参考书籍"><a href="#参考书籍" class="headerlink" title="参考书籍"></a>参考书籍</h1><p><a href="https://book.douban.com/subject/1500149/" target="_blank" rel="external">UNIX 网络编程</a><br><a href="https://book.douban.com/subject/4189500/" target="_blank" rel="external">Linux 网络编程</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;通过套接字选项可以获得、设置套接字的行为属性。&lt;br&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://github.com/Sword2G/sword2g.github.io/categories/Linux/"/>
    
    
      <category term="Socket" scheme="https://github.com/Sword2G/sword2g.github.io/tags/Socket/"/>
    
  </entry>
  
  <entry>
    <title>I/O多路复用select、poll、epoll</title>
    <link href="https://github.com/Sword2G/sword2g.github.io/2016/05/13/select-poll-epoll/"/>
    <id>https://github.com/Sword2G/sword2g.github.io/2016/05/13/select-poll-epoll/</id>
    <published>2016-05-13T01:18:20.000Z</published>
    <updated>2017-03-03T12:54:39.660Z</updated>
    
    <content type="html"><![CDATA[<p>select, poll, epoll都是IO多路复用的机制，它允许进程指示内核等待多个事件中的任何一个发生，并且在只有一个或者多个事件发生或经历一段指定的时间后才唤醒它。<br><a id="more"></a></p>
<h1 id="select-函数"><a href="#select-函数" class="headerlink" title="select 函数"></a>select 函数</h1><h2 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h2><figure class="highlight autoit"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">\<span class="meta">#<span class="meta-keyword">include</span>&amp;lt;sys/types.h&amp;gt;</span></div><div class="line">\<span class="meta">#<span class="meta-keyword">include</span>&amp;lt;sys/times.h&amp;gt;</span></div><div class="line">\<span class="meta">#<span class="meta-keyword">include</span>&amp;lt;sys/select.h&amp;gt;</span></div><div class="line"></div><div class="line"><span class="built_in">int</span> <span class="keyword">select</span>(</div><div class="line"><span class="built_in">int</span> maxfdp1,</div><div class="line">fd_set* readfds,</div><div class="line">fd_set* writefds,</div><div class="line">fd_set* exceptfds,</div><div class="line"><span class="keyword">const</span> struct timeval* timeout</div><div class="line">)<span class="comment">;</span></div></pre></td></tr></table></figure>
<h2 id="参数解释"><a href="#参数解释" class="headerlink" title="参数解释"></a>参数解释</h2><ul>
<li>maxfdp1 是一个整数值，是指集合中所有文件描述符的范围，即所有文件描述符的最大值加1</li>
<li>readfds 要求内核测试的读描述符集</li>
<li>writefds 要求内核测试的写描述符集</li>
<li>exceptfds 要求内核测试的异常描述符集</li>
<li>timeout 要求内核等待的时间</li>
</ul>
<h3 id="struct-timeval结构"><a href="#struct-timeval结构" class="headerlink" title="struct timeval结构"></a>struct timeval结构</h3><p>struct timebal{<br>    long tv_sec; //second<br>    long tv_usec; //microsecond<br>}<br>这个参数有三种可能：<br>1 永远等待下去：仅在有一个描述符准备好I/O时才返回。为此，我们将参数设置为空指针。<br>2 等待一段固定的时间 ：在有一个描述符准备好时返回，但是不超过由该参数所指向的timeval结构中指定的秒数和微妙数<br>以上两种情况的等待通常会被进程在等待期间捕获的信号所中断，并从信号处理函数<br>3 根本不等待 ：检查描述符后立即返回，这称为轮询。为此，参数timeval定时器的值必须为0（秒数和微妙数）</p>
<h3 id="描述符集"><a href="#描述符集" class="headerlink" title="描述符集"></a>描述符集</h3><p>是一个整数数组，其中每个整数中的某一位对应一个描述符。可以通过如下四个宏来操作描述符集。</p>
<ul>
<li>void FD_ZERO(fd_set *fdset)            //clear all bits in fdset</li>
<li>void FD_SET(int fd, fd_set <em>fdset)    //turn on the bit for </em>fd<em> in </em>fdset*</li>
<li>void FD_CLR(int fd, fd_set <em>fdset)    //turn off the bit for </em>fd<em> in </em>fdset*</li>
<li>int FD_ISSET(int fd, fd_set <em>fdset)    //is the bit for fd on in </em>fdset*</li>
</ul>
<h2 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h2><p>调用select时，我们指定所关心的描述符的值，该函数返回时，结果将指示那些描述符已经就绪。函数返回时，使用FD_ISSET测试fd_set数据类型中的描述符，描述符集内任何与未就绪描述符对应的位返回时均被清 0 。因此每次重新调用 select 时，都必须再次把所有的描述符集内所关心位置 1 。函数的返回值为跨所有描述符集的已就绪的总位数。如果在任何描述符就绪之前定时器超时，返回 0 。返回 -1 表示出错（如本函数被某个信号中断）</p>
<h1 id="pselect-函数"><a href="#pselect-函数" class="headerlink" title="pselect 函数"></a>pselect 函数</h1><h2 id="原型-1"><a href="#原型-1" class="headerlink" title="原型"></a>原型</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pselect</span><span class="params">(</span></span></div><div class="line"><span class="keyword">int</span> maxfdp1,</div><div class="line">fd_set* readfds,</div><div class="line">fd_set* writefds,</div><div class="line">fd_set* exceptfds,</div><div class="line"><span class="keyword">const</span> <span class="keyword">struct</span> timespec* timeout,</div><div class="line"><span class="keyword">const</span> <span class="keyword">sigset_t</span> *sigmask</div><div class="line">);</div></pre></td></tr></table></figure>
<h2 id="参数解释-1"><a href="#参数解释-1" class="headerlink" title="参数解释"></a>参数解释</h2><ul>
<li>maxfdp1 是一个整数值，是指集合中所有文件描述符的范围，即所有文件描述符的最大值加1</li>
<li>readfds 要求内核测试的读描述符集</li>
<li>writefds 要求内核测试的写描述符集</li>
<li>exceptfds 要求内核测试的异常描述符集</li>
<li>timeout 要求内核等待的时间</li>
<li>sigmask，比 select 多一个参数：一个指向信号掩码的指针。该参数允许程序先禁止递交某些信号，在测试由这些当前被禁止信号的信号处理函数设置的全局变量，然后调用pselect，告诉它重新设置信号掩码</li>
</ul>
<h3 id="struct-timespec结构"><a href="#struct-timespec结构" class="headerlink" title="struct timespec结构"></a>struct timespec结构</h3><p>struct timebal{<br>    time_t tv_sec; //second<br>    long tv_nsec; //nanosecond<br>}</p>
<h2 id="返回值-1"><a href="#返回值-1" class="headerlink" title="返回值"></a>返回值</h2><p>返回就绪描述符数目，若超时返回 0 ，出错返回 -1，然后恢复进程信号掩码重置为调用pselect之前的值。</p>
<h1 id="poll-函数"><a href="#poll-函数" class="headerlink" title="poll 函数"></a>poll 函数</h1><h2 id="原型-2"><a href="#原型-2" class="headerlink" title="原型"></a>原型</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;poll.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span><span class="params">(<span class="keyword">struct</span> pollfd *fdarray, <span class="keyword">unsigned</span> <span class="keyword">long</span> nfds, <span class="keyword">int</span> timeout)</span></span>;</div></pre></td></tr></table></figure>
<h2 id="参数解释-2"><a href="#参数解释-2" class="headerlink" title="参数解释"></a>参数解释</h2><ul>
<li>fdarray struct pollfd 数组的指针</li>
<li>nfds 是一个整数值，是指集合中所有文件描述符的范围，即所有文件描述符的最大值加1</li>
<li>timeout 超时时间 <ul>
<li>timeout = INFTIM 永远等待</li>
<li>timeout &lt; 0 立即返回，不阻塞进程</li>
<li>timeout &gt; 0 等待指定数目的毫秒数</li>
</ul>
</li>
</ul>
<h3 id="struct-pollfd结构"><a href="#struct-pollfd结构" class="headerlink" title="struct pollfd结构"></a>struct pollfd结构</h3><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">struct pollfd&#123;</div><div class="line">	int fd<span class="comment">;</span></div><div class="line">	<span class="keyword">short </span>events<span class="comment">;</span></div><div class="line">	<span class="keyword">short </span>revents<span class="comment">;</span></div><div class="line">&#125;<span class="comment">;</span></div></pre></td></tr></table></figure>
<p>要测试的条件由events成员指定，函数在revents成员中返回该描述符的状态，函数返回时设置这个域。</p>
<p><img src="http://7xum8m.com1.z0.glb.clouddn.com/hexo_selectselects_events_revents.jpg" alt="events 与 revents"></p>
<h2 id="返回值-2"><a href="#返回值-2" class="headerlink" title="返回值"></a>返回值</h2><p>定时器超时之前没有任何描述符就绪，返回 0 ，否则返回就绪描述符（结构体中revents域不为0的文件描述符）的个数。<br>发生错误时返回 -1，并设置errno为下列值之一：</p>
<ul>
<li>EBADF　　     一个或多个结构体中指定的文件描述符无效。</li>
<li>EFAULTfds　　 指针指向的地址超出进程的地址空间。</li>
<li>EINTR　　　　 请求的事件之前产生一个信号，调用可以重新发起。</li>
<li>EINVALnfds　　参数超出PLIMIT_NOFILE值。</li>
<li>ENOMEM　　    可用内存不足，无法完成请求。<br>如果不关心某个描述符可以把它对应的 struct poolfd 结构的 fd 字段设置为一个负值。poll 函数将忽略这样的 pollfd 结构的 events 成员，返回时将它的 revents 成员置为 0。</li>
</ul>
<h1 id="epoll-函数"><a href="#epoll-函数" class="headerlink" title="epoll 函数"></a>epoll 函数</h1><p>poll和select同样存在一个缺点就是，包含大量文件描述符的数组被整体复制于用户态和内核态的地址空间之间，而不论这些文件描述符是否就绪，它的开销随着文件描述符数量的增加而线性增大。<br>epoll是在2.6内核中提出的，是之前的select和poll的增强版本。相对于select和poll来说，epoll更加灵活，没有描述符限制</p>
<h2 id="epoll-的接口"><a href="#epoll-的接口" class="headerlink" title="epoll 的接口"></a>epoll 的接口</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> size)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> op, <span class="keyword">int</span> fd, <span class="keyword">struct</span> epoll_event *event)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">struct</span> epoll_event * events, <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span>;</div></pre></td></tr></table></figure>
<h3 id="epoll-create"><a href="#epoll-create" class="headerlink" title="epoll_create"></a>epoll_create</h3><p>创建一个epoll的句柄，size用来告诉内核这个监听的数目一共有多大。这个参数不同于select()中的第一个参数，给出最大监听的fd+1的值。需要注意的是，当创建好epoll句柄后，它就是会占用一个fd值，在linux下如果查看/proc/进程id/fd/，是能够看到这个fd的，所以在使用完epoll后，必须调用close()关闭，否则可能导致fd被耗尽</p>
<h3 id="epoll-ctl"><a href="#epoll-ctl" class="headerlink" title="epoll_ctl"></a>epoll_ctl</h3><p>epoll的事件注册函数,不同于select()是在监听事件时告诉内核要监听什么类型的事件，而是在这里先注册要监听的事件类型。</p>
<h4 id="参数解释-3"><a href="#参数解释-3" class="headerlink" title="参数解释"></a>参数解释</h4><p>*epfd epoll_create()的返回值，</p>
<ul>
<li>op 表示动作，用三个宏来表示：<ul>
<li>EPOLL_CTL_ADD：注册新的fd到epfd中；</li>
<li>EPOLL_CTL_MOD：修改已经注册的fd的监听事件；</li>
<li>EPOLL_CTL_DEL：从epfd中删除一个fd；</li>
</ul>
</li>
<li>fd 需要监听的fd</li>
<li>event 告诉内核需要监听什么事<h4 id="struct-epoll-event-结构"><a href="#struct-epoll-event-结构" class="headerlink" title="struct epoll_event 结构"></a>struct epoll_event 结构</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> epoll_event &#123;</div><div class="line">  <span class="keyword">__uint32_t</span> events;  <span class="comment">/* Epoll events */</span></div><div class="line">  <span class="keyword">epoll_data_t</span> data;  <span class="comment">/* User data variable */</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>events可以是以下几个宏的集合：<br>EPOLLIN ：表示对应的文件描述符可以读（包括对端SOCKET正常关闭）；<br>EPOLLOUT：表示对应的文件描述符可以写；<br>EPOLLPRI：表示对应的文件描述符有紧急的数据可读（这里应该表示有带外数据到来）；<br>EPOLLERR：表示对应的文件描述符发生错误；<br>EPOLLHUP：表示对应的文件描述符被挂断；<br>EPOLLET： 将EPOLL设为边缘触发(Edge Triggered)模式，这是相对于水平触发(Level Triggered)来说的。<br>EPOLLONESHOT：只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个socket的话，需要再次把这个socket加入到EPOLL队列里</p>
<h5 id="epoll-data-t结构"><a href="#epoll-data-t结构" class="headerlink" title="epoll_data_t结构"></a>epoll_data_t结构</h5><figure class="highlight crystal"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">typedef <span class="class"><span class="keyword">union</span> <span class="title">epoll_data</span> &#123;</span></div><div class="line">void *ptr;</div><div class="line">int fd;</div><div class="line">__uint32_t u32;</div><div class="line">__uint64_t u64;</div><div class="line">&#125; epoll_data_t;</div></pre></td></tr></table></figure>
<h3 id="epoll-wait"><a href="#epoll-wait" class="headerlink" title="epoll_wait"></a>epoll_wait</h3><p>等待事件的产生，类似于select()调用。参数events用来从内核得到事件的集合，maxevents告之内核这个events有多大，这个maxevents的值不能大于创建epoll_create()时的size，参数timeout是超时时间（毫秒，0会立即返回，-1将不确定，也有说法说是永久阻塞）。该函数返回需要处理的事件数目，如返回0表示已超时。</p>
<h2 id="epoll-工作模式"><a href="#epoll-工作模式" class="headerlink" title="epoll 工作模式"></a>epoll 工作模式</h2><p>epoll对文件描述符的操作有两种模式：LT（level trigger）和ET（edge trigger）。LT模式是默认模式。</p>
<ul>
<li><p>LT模式：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序可以不立即处理该事件。下次调用epoll_wait时，会再次响应应用程序并通知此事件。</p>
</li>
<li><p>ET模式：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序必须立即处理该事件。如果不处理，下次调用epoll_wait时，不会再次响应应用程序并通知此事件。</p>
</li>
</ul>
<p>ET模式在很大程度上减少了epoll事件被重复触发的次数，因此效率要比LT模式高。epoll工作在ET模式的时候，必须使用非阻塞套接口，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。</p>
<h1 id="select-poll-epoll区别"><a href="#select-poll-epoll区别" class="headerlink" title="select poll epoll区别"></a>select poll epoll区别</h1><p>1 select，poll实现需要自己不断轮询所有fd集合，直到设备就绪，期间可能要睡眠和唤醒多次交替。而epoll其实也需要调用epoll_wait不断轮询就绪链表，期间也可能多次睡眠和唤醒交替，但是它是设备就绪时，调用回调函数，把就绪fd放入就绪链表中，并唤醒在epoll_wait中进入睡眠的进程。虽然都要睡眠和交替，但是select和poll在“醒着”的时候要遍历整个fd集合，而epoll在“醒着”的时候只要判断一下就绪链表是否为空就行了，这节省了大量的CPU时间。这就是回调机制带来的性能提升。</p>
<p>2 select，poll每次调用都要把fd集合从用户态往内核态拷贝一次，并且要把current往设备等待队列中挂一次，而epoll只要一次拷贝，而且把current往等待队列上挂也只挂一次（在epoll_wait的开始，注意这里的等待队列并不是设备等待队列，只是一个epoll内部定义的等待队列）。这也能节省不少的开销。</p>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="http://www.cnblogs.com/Anker/archive/2013/08/17/3263780.html" target="_blank" rel="external">http://www.cnblogs.com/Anker/archive/2013/08/17/3263780.html</a><br><a href="http://www.cnblogs.com/Anker/p/3265058.html" target="_blank" rel="external">http://www.cnblogs.com/Anker/p/3265058.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;select, poll, epoll都是IO多路复用的机制，它允许进程指示内核等待多个事件中的任何一个发生，并且在只有一个或者多个事件发生或经历一段指定的时间后才唤醒它。&lt;br&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://github.com/Sword2G/sword2g.github.io/categories/Linux/"/>
    
    
      <category term="I/O multiplexing, select, poll, epoll" scheme="https://github.com/Sword2G/sword2g.github.io/tags/I-O-multiplexing-select-poll-epoll/"/>
    
  </entry>
  
  <entry>
    <title>I/O 模型</title>
    <link href="https://github.com/Sword2G/sword2g.github.io/2016/05/13/I-O-Models/"/>
    <id>https://github.com/Sword2G/sword2g.github.io/2016/05/13/I-O-Models/</id>
    <published>2016-05-12T23:13:24.000Z</published>
    <updated>2017-03-03T13:32:50.478Z</updated>
    
    <content type="html"><![CDATA[<p>Unix下可用的 I/O 模型有五种：<a href="#阻塞式-I-O-模型">阻塞式 I/O 模型</a>、<a href="#非阻塞式-I-O-模型">非阻塞式 I/O 模型</a>、<a href="#I-O-复用模型">I/O 复用模型</a>、<a href="#信号驱动式-I-O（SIGIO）模型">信号驱动式 I/O模型（SIGIO）</a>、<a href="#异步-I-O-模型">异步 I/O 模型（POSIX 的 aio_ 系列函数）</a>。<br><a id="more"></a></p>
<h1 id="输入系统"><a href="#输入系统" class="headerlink" title="输入系统"></a>输入系统</h1><h2 id="普通输入操作"><a href="#普通输入操作" class="headerlink" title="普通输入操作"></a>普通输入操作</h2><p>一个输入操作一般分为两个阶段：<br>1 等待数据可读；<br>2 将数据从内核复制到进程。</p>
<h2 id="套接字输入操作"><a href="#套接字输入操作" class="headerlink" title="套接字输入操作"></a>套接字输入操作</h2><p>对于对于一个套接字的输入操作，<br>1 一般来说是等待数据从网络中到达。当数据包到达的时候，数据将会从网络层拷贝到内核的缓冲区中；<br>2 从内核缓冲区中把数据复制到应用进程的缓冲区中。</p>
<h1 id="I-O模型"><a href="#I-O模型" class="headerlink" title="I/O模型"></a>I/O模型</h1><h2 id="POSIX同步-I-O-与异步-I-O"><a href="#POSIX同步-I-O-与异步-I-O" class="headerlink" title="POSIX同步 I/O 与异步 I/O"></a>POSIX同步 I/O 与异步 I/O</h2><ul>
<li>同步 I/O ： 请求进程阻塞，直到 I/O 操作完成</li>
<li>异步 I/O ： 不导致请求进程阻塞，I/O 操作完成后通知</li>
</ul>
<p>简单的说：</p>
<ul>
<li>同步 ：就是在发出一个功能调用时，在没有得到结果之前，该调用就不返回。也就是必须一件一件事做,等前一件做完了才能做下一件事。</li>
<li>异步 ：异步的概念和同步相对。当一个异步过程调用发出后，调用者不能立刻得到结果。实际处理这个调用的部件在完成后，通过状态、通知和回调来通知调用者。</li>
</ul>
<h3 id="POSIX同步-I-O"><a href="#POSIX同步-I-O" class="headerlink" title="POSIX同步 I/O"></a>POSIX同步 I/O</h3><h4 id="阻塞式-I-O-模型"><a href="#阻塞式-I-O-模型" class="headerlink" title="阻塞式 I/O 模型"></a>阻塞式 I/O 模型</h4><p>最常用的一个模型是同步阻塞 I/O 模型。在这个模型中，用户空间的应用程序执行一个系统调用，这会导致应用程序阻塞。这意味着应用程序会一直阻塞，直到系统调用完成为止（数据传输完成或发生错误）。调用应用程序处于一种不再消费 CPU 而只是简单等待响应的状态，因此从处理的角度来看，这是非常有效的。<br>一个传统的阻塞 I/O 模型如下：<br><img src="http://7xum8m.com1.z0.glb.clouddn.com/hexo_iomodels_traditional_block_io.jpg.gif" alt="传统阻塞I/O模型典型流程"></p>
<p>在调用 read 系统调用时，应用程序会阻塞并对内核进行上下文切换。然后会触发读操作，当响应返回时（从我们正在从中读取的设备中返回），数据就被移动到用户空间的缓冲区中。然后应用程序就会解除阻塞（read 调用返回）。</p>
<p><img src="http://7xum8m.com1.z0.glb.clouddn.com/hexo_iomodels_socket_block.jpg" alt="数据报套接字阻塞式 I/O 模型典型流程"></p>
<p>进程调用recvfrom，其系统调用直到数据包到达并被复制到应用程序缓冲区或者发生错误时才返回。最常见的是系统调用被信号中断。进程在从recvfrom别调用到它返回这个时间内是被阻塞的。</p>
<h4 id="非阻塞式-I-O-模型"><a href="#非阻塞式-I-O-模型" class="headerlink" title="非阻塞式 I/O 模型"></a>非阻塞式 I/O 模型</h4><p>I/O 操作不会阻塞应用程序，而是返回一个错误代码，说明这个命令不能立即满足（EAGAIN 或 EWOULDBLOCK），需要应用程序调用许多次来等待操作完成（称之为轮询，应用程序持续轮询内核，以查看某个操作是否就绪）。这可能效率不高，因为在很多情况下，当内核执行这个命令时，应用程序必须要进行忙碌等待，直到数据可用为止，或者试图执行其他工作。</p>
<p><img src="http://7xum8m.com1.z0.glb.clouddn.com/hexo_iomodels_unblock.jpg" alt="非阻塞 I/O 模型的典型流程"><br><img src="http://7xum8m.com1.z0.glb.clouddn.com/hexo_iomodels_dgram_unblock.jpg" alt="数据报套接字非阻塞 I/O 模型的典型流程"></p>
<p>前三次调用 recfrom 时没有数据返回，因此内核立即返回 EWOULDBLOCK 错误，第四次调用 recfrom 时已有数据准备好，它被复制到应用进程缓冲区，recvfrom 成功返回。</p>
<h4 id="I-O-复用模型"><a href="#I-O-复用模型" class="headerlink" title="I/O 复用模型"></a>I/O 复用模型</h4><p>I/O 复用模型会用到select、poll、epoll函数，这几个函数也会使进程阻塞，但是和阻塞I/O 所不同的的，它可以阻塞于多个I/O操作的某一个上，而不是阻塞在真正的 I/O操作之上。比如它可以同时对多个读操作，多个写操作的I/O函数进行检测，直到有数据可读或可写时，才真正调用I/O操作函数。</p>
<p><img src="http://7xum8m.com1.z0.glb.clouddn.com/hexo_iomodels_dgram_muti.jpg" alt="数据报套接字 I/O 复用模型的典型流程"></p>
<h4 id="信号驱动式-I-O（SIGIO）模型"><a href="#信号驱动式-I-O（SIGIO）模型" class="headerlink" title="信号驱动式 I/O（SIGIO）模型"></a>信号驱动式 I/O（SIGIO）模型</h4><p>首先开启套接字的信号驱动式 I/O 功能，并通过sigaction系统调用一个安装信号处理函数。该系统调用立即返回。当数据包准备好时，内核为该进程产生一个 SIGIO 信号，我们就可以在信号处理函数中调用I/O操作函数处理数据。</p>
<p><img src="http://7xum8m.com1.z0.glb.clouddn.com/hexo_iomodels_signal_io.jpg" alt="数据报套接字信号驱动式 I/O 模型的典型流程"></p>
<h3 id="POSIX-异步-I-O"><a href="#POSIX-异步-I-O" class="headerlink" title="POSIX 异步 I/O"></a>POSIX 异步 I/O</h3><h4 id="异步-I-O-模型"><a href="#异步-I-O-模型" class="headerlink" title="异步 I/O 模型"></a>异步 I/O 模型</h4><p>告知内核启动某个动作，并在动作完成后告知我们。</p>
<p><img src="http://7xum8m.com1.z0.glb.clouddn.com/hexo_iomodels_asy.jpg" alt="数据报套接字异步 I/O 模型的典型流程"></p>
<h2 id="五种-I-O-模型的比较"><a href="#五种-I-O-模型的比较" class="headerlink" title="五种 I/O 模型的比较"></a>五种 I/O 模型的比较</h2><p><img src="http://7xum8m.com1.z0.glb.clouddn.com/hexo_iomodels_compare.jpg" alt="五种 I/O 模型的比较"></p>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="http://www.ibm.com/developerworks/cn/linux/l-async/#authorN10019" target="_blank" rel="external">http://www.ibm.com/developerworks/cn/linux/l-async/#authorN10019</a><br><a href="http://www.cnblogs.com/renxs/p/3683189.html" target="_blank" rel="external">http://www.cnblogs.com/renxs/p/3683189.html</a><br><a href="http://blog.jobbole.com/53152/" target="_blank" rel="external">http://blog.jobbole.com/53152/</a><br><a href="https://book.douban.com/subject/4859464/" target="_blank" rel="external">https://book.douban.com/subject/4859464/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Unix下可用的 I/O 模型有五种：&lt;a href=&quot;#阻塞式-I-O-模型&quot;&gt;阻塞式 I/O 模型&lt;/a&gt;、&lt;a href=&quot;#非阻塞式-I-O-模型&quot;&gt;非阻塞式 I/O 模型&lt;/a&gt;、&lt;a href=&quot;#I-O-复用模型&quot;&gt;I/O 复用模型&lt;/a&gt;、&lt;a href=&quot;#信号驱动式-I-O（SIGIO）模型&quot;&gt;信号驱动式 I/O模型（SIGIO）&lt;/a&gt;、&lt;a href=&quot;#异步-I-O-模型&quot;&gt;异步 I/O 模型（POSIX 的 aio_ 系列函数）&lt;/a&gt;。&lt;br&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://github.com/Sword2G/sword2g.github.io/categories/Linux/"/>
    
    
      <category term="I/O" scheme="https://github.com/Sword2G/sword2g.github.io/tags/I-O/"/>
    
  </entry>
  
  <entry>
    <title>About GCC</title>
    <link href="https://github.com/Sword2G/sword2g.github.io/2016/05/12/GCC/"/>
    <id>https://github.com/Sword2G/sword2g.github.io/2016/05/12/GCC/</id>
    <published>2016-05-12T10:33:41.000Z</published>
    <updated>2017-03-03T13:40:25.489Z</updated>
    
    <content type="html"><![CDATA[<p>GCC（GNU Compiler Collection，GNU编译器套件），是由 GNU 开发的编程语言编译器。GCC原本作为GNU操作系统的官方编译器，现已被大多数类Unix操作系统（如Linux、BSD、Mac OS X等）采纳为标准的编译器，GCC同样适用于微软的Windows。<br><a id="more"></a></p>
<h1 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a>编译过程</h1><p>一个完整的编译过程包括四个步骤:<a href="#预处理">预处理</a>，<a href="#编译">编译</a>，<a href="#汇编">汇编</a>，<a href="#链接">链接</a>。</p>
<h2 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h2><p>预处理的过程主要处理包括以下过程：</p>
<ul>
<li>将所有的#define删除，并且展开所有的宏定义；</li>
<li>处理所有的条件预编译指令，比如#if #ifdef #elif #else #endif等， 这些伪指令的引入使得程序员可以通过定义不同的宏来决定编译程序对哪些代码进行处理；</li>
<li>处理#include 预编译指令，将被包含的文件插入到该预编译指令的位置；</li>
<li>删除所有注释 “//”和”/<em> </em>/”；</li>
<li>添加行号和文件标识，以便编译时产生调试用的行号及编译错误警告行号；</li>
<li>保留所有的#pragma编译器指令，因为编译器需要使用它们；</li>
</ul>
<h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>编译过程就是把预处理完的文件进行一系列的词法分析（扫描），语法分析,语义分析，中间代码生成，<br>编译优化，目标代码生成，生成相应的汇编代码。</p>
<h3 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h3><p>扫描器（Scanner）将源代的字符序列分割成一系列的记号（Token）。lex工具可实现词法扫描。</p>
<h3 id="语法分析"><a href="#语法分析" class="headerlink" title="语法分析"></a>语法分析</h3><p>语法分析器将记号（Token）产生语法树（Syntax Tree）。yacc工具可实现语法分析(yacc: Yet Another Compiler Compiler)。</p>
<h3 id="语义分析"><a href="#语义分析" class="headerlink" title="语义分析"></a>语义分析</h3><p>静态语义（在编译器可以确定的语义）、动态语义（只能在运行期才能确定的语义）。</p>
<h3 id="中间代码生成"><a href="#中间代码生成" class="headerlink" title="中间代码生成"></a>中间代码生成</h3><p>源代码优化器(Source Code Optimizer)，将整个语法书转化为中间代码（Intermediate Code），中间代码是与目标机器和运行环境无关的。中间代码使得编译器被分为前端和后端。编译器前端负责产生机器无关的中间代码；编译器后端将中间代码转化为目标机器代码。</p>
<h3 id="编译优化"><a href="#编译优化" class="headerlink" title="编译优化"></a>编译优化</h3><p>这一部分是现代编译器最核心所在，主要有两类，一类是通用的优化手段，比如死代码删除、循环不变量外提、强度削弱等，另一类就是体系结构相关的，说白了就是某种体系结构针对某类应用提供了特殊指令，例如intel的MMX，SSE2等等。</p>
<h3 id="目标代码生成"><a href="#目标代码生成" class="headerlink" title="目标代码生成"></a>目标代码生成</h3><p>这里直接和具体平台相关，这里的平台同时包括软件和硬件，例如哪种目标文件格式(ELF, PE)，哪种平台(指令集)。不过现在编译器一般生成的是字符形式的汇编文件，所以前面一个问题基本不大，主要影响在后者。</p>
<h2 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h2><p>汇编过程实际上指把汇编语言代码翻译成目标机器指令的过程。对于被翻译系统处理的每一个C语言源程序，都将最终经过这一处理而得到相应的目标文件。目标文件中所存放的也就是与源程序等效的目标的机器语言代码。</p>
<p>目标文件由段组成，通常一个目标文件中至少有两个段：</p>
<ul>
<li>代码段：该段中所包含的主要是程序的指令。该段一般是可读和可执行的，但一般却不可写;</li>
<li>数据段：主要存放程序中要用到的各种全局变量或静态的数据。一般数据段都是可读，可写，可执行的</li>
</ul>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p>目标文件还不能运行，必须进一步转成可执行文件。链接的主要内容是把各个模块之间相互引用的部分处理好，使得各个模块之间能够正确地衔接。</p>
<p>链接的主要过程包括：地址和空间分配（Address and Storage Allocation），符号决议（Symbol Resolution），重定位（Relocation）等。</p>
<h1 id="GCC简介"><a href="#GCC简介" class="headerlink" title="GCC简介"></a>GCC简介</h1><p>GCC 原名为 GNU C 语言编译器（GNU C Compiler），因为它原本只能处理 C语言。GCC 很快地扩展，变得可处理 C++。后来又扩展能够支持更多编程语言，如Fortran、Pascal、Objective-C、Java、Ada、Go以及各类处理器架构上的汇编语言等，所以改名GNU编译器套件（GNU Compiler Collection）</p>
<h1 id="GCC命令"><a href="#GCC命令" class="headerlink" title="GCC命令"></a>GCC命令</h1><h2 id="gcc与g"><a href="#gcc与g" class="headerlink" title="gcc与g++"></a>gcc与g++</h2><h3 id="gcc与g-区别"><a href="#gcc与g-区别" class="headerlink" title="gcc与g++区别"></a>gcc与g++区别</h3><blockquote>
<p>gcc and g++ are compiler-drivers of the ‘Gnu Compiler Collection’ (which was once upon a time just the ‘Gnu C Compiler’).The probably most important difference in their defaults is which libraries they link against automatically.</p>
</blockquote>
<p>这里的意思是说gcc和g++都是GNU编译器套件（GCC原来只代表一个单纯的C编译器）的编译器驱动（也就是说他可以根据代码的后缀名来判断调用c编译器还是c++编译器g++）。他们之间最大的区别是他们默认链接的库的不同，如果你的代码后缀是cpp, 他会调用g++编译器，当然library call也是c++版本的。</p>
<h3 id="gcc与g-误解"><a href="#gcc与g-误解" class="headerlink" title="gcc与g++误解"></a>gcc与g++误解</h3><h4 id="误解一"><a href="#误解一" class="headerlink" title="误解一"></a>误解一</h4><p>gcc只能编译c代码,g++只能编译c++代码两者都可以，但是请注意：</p>
<ul>
<li><p>后缀为.c的，gcc把它当作是C程序，而g++当作是c++程序；后缀为.cpp的，两者都会认为是c++程序，注意，虽然c++是c的超集，但是两者对语法的要求是有区别的。</p>
</li>
<li><p>编译阶段，g++会调用gcc，对于c++代码，两者是等价的，但是因为gcc命令不能自动和C＋＋程序使用的库联接，所以通常用g++来完成链接，为了统一起见，干脆编译/链接统统用g++了，这就给人一种错觉，好像cpp程序只能用g++似的。</p>
</li>
</ul>
<h4 id="误解二"><a href="#误解二" class="headerlink" title="误解二"></a>误解二</h4><p>gcc不会定义__cplusplus宏，而g++会</p>
<p>实际上，这个宏只是标志着编译器将会把代码按C还是C++语法来解释，如上所述，如果后缀为.c，并且采用gcc编译器，则该宏就是未定义的，否则，就是已定义。</p>
<h4 id="误解三"><a href="#误解三" class="headerlink" title="误解三"></a>误解三</h4><p>编译只能用gcc，链接只能用g++</p>
<p>严格来说，这句话不算错误，但是它混淆了概念，应该这样说：编译可以用gcc/g++，而链接可以用g++或者gcc -lstdc++。因为gcc命令不能自动和C＋＋程序使用的库联接，所以通常使用g++来完成联接。但在编译阶段，g++会自动调用gcc，二者等价。</p>
<h4 id="误解四"><a href="#误解四" class="headerlink" title="误解四"></a>误解四</h4><p>extern “C”与gcc/g++有关系<br>实际上并无关系，无论是gcc还是g++，用extern “c”时，都是以C的命名方式来为symbol命名，否则，都以c++方式命名。</p>
<h3 id="包含库-头文件方法"><a href="#包含库-头文件方法" class="headerlink" title="包含库/头文件方法"></a>包含库/头文件方法</h3><ul>
<li><p>-l（小写的L）参数就是用来指定程序要链接的库，-l参数紧接着就是库名（库文件名是libm.so，则库名是m），-L参数紧接着是库路径（如果库文件放在/lib和/usr/lib和/usr/local/lib里的库直接用-l参数就能链接了，但如果库文件没放 在这三个目录里，而是放在其他目录里，这时我们只用-l参数的话，链接还是会出错，出错信息大概是：“/usr/bin/ld: cannot find -lxxx”），这是我们需要加路径</p>
</li>
<li><p>-I（大写的i）参数是用来指定头文件目录，/usr/include目录一般是不用指定的，gcc知道去那里找，但 是如果头文件不在/usr/include里我们就要用-I参数指定了</p>
</li>
</ul>
<h2 id="gcc与cc"><a href="#gcc与cc" class="headerlink" title="gcc与cc"></a>gcc与cc</h2><p>cc是UNIX下的一款古老的c编译器,他是一款商业软件。<br>在Linux下，cc是gcc的符号链接，这样方便了用gcc来编译老的用cc编译的Unix软件，甚至连makefile都不用改在，而且也便于编译来自于Unix的软件。</p>
<h2 id="gcc常用选项"><a href="#gcc常用选项" class="headerlink" title="gcc常用选项"></a>gcc常用选项</h2><ul>
<li>无选项   ==&gt;可执行文件          执行预处理，编译，汇编，链接生成可执行文件</li>
<li>-E       ==&gt;*.i                仅作预处理，不进行编译、汇编和链接</li>
<li>-S       ==&gt;*.s                编译到汇编语言，不进行汇编和链接</li>
<li>-c       ==&gt;*.o                  编译、汇编到目标代码，不进行链接</li>
<li><p>-o &lt;文件&gt;                         输出到 &lt;文件&gt;</p>
</li>
<li><p>-g          包括调试信息，产生供gdb调试用的可执行文件</p>
</li>
<li>-Wwarn      设置警告,可以设置的警告开关很多,通常用-Wall开启所有的警告</li>
<li><p>-O<em>level</em>   设置优化级别,level可以是0,1,2,3或者s,默认-O0,即不进行优化，常用-O2</p>
</li>
<li><p>-I<em>dir</em>        把dir加到头文件的搜索路径中而且gcc会在搜索标准头文件之前先搜索dir</p>
</li>
<li>-L<em>dir</em>       把dir加到库文件的搜索路径中,而且gcc会在搜索标准库文件之前先搜索dir</li>
<li><p>-l<em>library</em>   在连接的时候搜索library库</p>
</li>
<li><p>-pthread       通过pthreads库加入对多线程的支持,这为预处理和连接设置了标志.pthread是POSIX指定的标准线程库</p>
</li>
</ul>
<h2 id="gcc示例"><a href="#gcc示例" class="headerlink" title="gcc示例"></a>gcc示例</h2><figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">&gt; gcc <span class="keyword">test</span>.c</div><div class="line">将<span class="keyword">test</span>.c预处理、汇编、编译并链接形成可执行文件。这里未指定输出文件，默认输出为a.<span class="keyword">out</span></div><div class="line"></div><div class="line">&gt; gcc <span class="keyword">test</span>.c -o <span class="keyword">test</span></div><div class="line">将<span class="keyword">test</span>.c预处理、汇编、编译并链接形成可执行文件<span class="keyword">test</span>。-o选项用来指定输出文件的文件名</div><div class="line"></div><div class="line">&gt; gcc -<span class="keyword">E</span> <span class="keyword">test</span>.c -o <span class="keyword">test</span>.<span class="built_in">i</span></div><div class="line">将<span class="keyword">test</span>.c预处理输出<span class="keyword">test</span>.i文件。</div><div class="line"></div><div class="line">&gt; gcc -S <span class="keyword">test</span>.i [-o <span class="keyword">test</span>.s]</div><div class="line">将<span class="keyword">test</span>.i编译输出<span class="keyword">test</span>.s汇编文件</div><div class="line"></div><div class="line">&gt; gcc -c <span class="keyword">test</span>.s [-o <span class="keyword">test</span>.o]</div><div class="line">将<span class="keyword">test</span>.s汇编输出<span class="keyword">test</span>.o目标文件</div><div class="line"></div><div class="line">&gt; gcc <span class="keyword">test</span>.o [-o <span class="keyword">test</span>]</div><div class="line">将编译输出文件<span class="keyword">test</span>.o链接成最终<span class="keyword">test</span>可执行文件</div></pre></td></tr></table></figure>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="http://www.oschina.net/p/gcc" target="_blank" rel="external">http://www.oschina.net/p/gcc</a><br><a href="http://stackoverflow.com/questions/172587/what-is-the-difference-between-g-and-gcc/172592#172592" target="_blank" rel="external">http://stackoverflow.com/questions/172587/what-is-the-difference-between-g-and-gcc/172592#172592</a><br><a href="http://blog.jobbole.com/53152/" target="_blank" rel="external">http://blog.jobbole.com/53152/</a><br><a href="https://www.zhihu.com/question/20940822/answer/69547180" target="_blank" rel="external">https://www.zhihu.com/question/20940822/answer/69547180</a><br><a href="https://www.zhihu.com/question/20940822/answer/16667772" target="_blank" rel="external">https://www.zhihu.com/question/20940822/answer/16667772</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;GCC（GNU Compiler Collection，GNU编译器套件），是由 GNU 开发的编程语言编译器。GCC原本作为GNU操作系统的官方编译器，现已被大多数类Unix操作系统（如Linux、BSD、Mac OS X等）采纳为标准的编译器，GCC同样适用于微软的Windows。&lt;br&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://github.com/Sword2G/sword2g.github.io/categories/Linux/"/>
    
    
      <category term="GCC, gcc, g++" scheme="https://github.com/Sword2G/sword2g.github.io/tags/GCC-gcc-g/"/>
    
  </entry>
  
  <entry>
    <title>ProGit Note</title>
    <link href="https://github.com/Sword2G/sword2g.github.io/2016/04/07/git-note/"/>
    <id>https://github.com/Sword2G/sword2g.github.io/2016/04/07/git-note/</id>
    <published>2016-04-07T12:38:28.000Z</published>
    <updated>2017-03-03T14:09:07.526Z</updated>
    
    <content type="html"><![CDATA[<p>最近工作使用Git，发现很多Git命令忘了，重新阅读了ProGit，在这里做做笔记，方便自己查阅<br><a id="more"></a><br>(注：以下内容均出自<a href="https://git-scm.com/book/zh/v1/" target="_blank" rel="external">ProGit</a>)</p>
<hr>
<h1 id="git配置"><a href="#git配置" class="headerlink" title="git配置"></a>git配置</h1><p>1 不让git追踪某些文件（写一个.gitignore文件，将不需要追踪的文件名放入其中） </p>
<p>2 配置别名<br><code>git config [--global] alias.co checkout</code><br><code>git config [--global] alias.ci commit</code><br><code>git config [--global] alias.br branch</code></p>
<p>(别名就在<code>alias</code>后面)</p>
<p>3 命令显示加色</p>
<p><code>git config [--global] color.ui true</code></p>
<p>4 文本编辑器</p>
<p><code>git config [--global] core.editor emacs</code><br>(默认会使用操作系统指定的默认编辑器)</p>
<p>5 差异分析工具</p>
<p><code>git config [--global] merge.tool vimdiff</code></p>
<p>(Git 可以理解 kdiff3，tkdiff，meld，xxdiff，emerge，vimdiff，gvimdiff，ecmerge，和 opendiff 等<br>合并工具的输出信息。当然，你也可以指定使用自己开发的工具)</p>
<p>6 查看配置<br><code>git config --list</code></p>
<p>7 单独查看某个配置<br><code>git config user.name</code></p>
<p>8 查看帮助<br><code>git &lt;verb&gt; --help</code>或者<code>git help &lt;verb&gt;</code></p>
<h2 id="git配置变量存放位置"><a href="#git配置变量存放位置" class="headerlink" title="git配置变量存放位置"></a>git配置变量存放位置</h2><ul>
<li><p>/etc/gitconfig文件：系统中对所有用户都普遍适用的配置。若使用 git config 时用 –system 选项，读写的就是这个文件。</p>
</li>
<li><p>~/.gitconfig文件：用户目录下的配置文件只适用于该用户。若使用 git config 时用 –global 选项，读写的就是这个文件。</p>
</li>
<li><p>每个项目的.git/config文件：这里的配置仅仅针对当前项目有效。若使用 git config 时不使用–global 选项，读写的就是这个文件。</p>
</li>
</ul>
<p>config文件类似这样<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">[user]</div><div class="line">	<span class="attr">name</span> = licong</div><div class="line">	<span class="attr">email</span> = <span class="number">1146726935</span>@qq.com</div><div class="line">[core]</div><div class="line">	<span class="attr">repositoryformatversion</span> = <span class="number">0</span></div><div class="line">	<span class="attr">filemode</span> = <span class="literal">false</span></div><div class="line">	<span class="attr">bare</span> = <span class="literal">false</span></div><div class="line">	<span class="attr">logallrefupdates</span> = <span class="literal">true</span></div><div class="line">	<span class="attr">symlinks</span> = <span class="literal">false</span></div><div class="line">	<span class="attr">ignorecase</span> = <span class="literal">true</span></div><div class="line">	<span class="attr">hideDotFiles</span> = dotGitOnly</div><div class="line">[remote <span class="string">"origin"</span>]</div><div class="line">	<span class="attr">url</span> = https://github.com/Sword2G/learngit.git</div><div class="line">	<span class="attr">fetch</span> = +refs/heads<span class="comment">/*:refs/remotes/origin/*</span></div><div class="line">[branch "master"]</div><div class="line">	remote = origin</div><div class="line">	merge = refs/heads/master</div></pre></td></tr></table></figure></p>
<blockquote>
<p>每一个级别的配置都会覆盖上层的相同配置，所以 .git/config 里的配置会覆盖 /etc/gitconfig<br>中的同名变量</p>
</blockquote>
<h2 id="配置用户名、邮箱"><a href="#配置用户名、邮箱" class="headerlink" title="配置用户名、邮箱"></a>配置用户名、邮箱</h2><p>使用git的时候，第一步需要配置用户名和电子邮箱<br><code>git config --global user.name &quot;userName&quot;</code><br><code>git config --global user.email &quot;email&quot;</code></p>
<p>由于使用–global，所以这里配置的变量会写到用户目录下的.gitconfig文件中,以后你所有的项目都会默<br>认使用这里配置的用户信息，如果要在某个特定的项目中使用其他名字或者电邮，只要去掉 –global 选项重<br>新配置即可，新的设定保存在当前项目的 .git/config 文件里。</p>
<h1 id="git基本操作"><a href="#git基本操作" class="headerlink" title="git基本操作"></a>git基本操作</h1><h2 id="获得git仓库"><a href="#获得git仓库" class="headerlink" title="获得git仓库"></a>获得git仓库</h2><p>1 自己创建仓库，切换到项目所在目录执行<code>git init</code>进行初始化，初始化后，在当前目录下会出现一个名为 .git 的目录，所有 Git 需要的数据和资源都存放在这个目录中</p>
<p>2 克隆仓库，执行<code>git clone [url] [name](如git clone https://github.com/Sword2G/learngit.git)</code>会在当前目录创建一个learngit目录，项目中的所有文件已经在里边了。如果有name参数，则目录的名称为name</p>
<h2 id="检查当前文件状态"><a href="#检查当前文件状态" class="headerlink" title="检查当前文件状态"></a>检查当前文件状态</h2><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ git status</div><div class="line"><span class="keyword">On</span> branch testbranch</div><div class="line"><span class="literal">nothing</span> <span class="keyword">to</span> commit, working directory clean</div></pre></td></tr></table></figure>
<p>以上信息显示，目前所在分支为testbranch，当前没有任何跟踪着的文件</p>
<p>当增加一个文件后执行<code>git status</code>，会显示未跟踪的文件<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">On branch testbranch</div><div class="line">Untracked files:</div><div class="line">  (<span class="keyword">use</span> <span class="string">"git add &lt;file&gt;..."</span> <span class="keyword">to</span> <span class="keyword">include</span> <span class="keyword">in</span> what will be committed)</div><div class="line"></div><div class="line">        test.txt</div><div class="line"></div><div class="line"><span class="keyword">nothing</span> added <span class="keyword">to</span> <span class="keyword">commit</span> but untracked files <span class="keyword">present</span> (<span class="keyword">use</span> <span class="string">"git add"</span> <span class="keyword">to</span> track)</div></pre></td></tr></table></figure></p>
<p>以上信息显示，test.txt文件为跟踪</p>
<h2 id="跟踪新文件"><a href="#跟踪新文件" class="headerlink" title="跟踪新文件"></a>跟踪新文件</h2><figure class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">git <span class="built_in">add</span> <span class="symbol">&lt;fileName&gt;</span></div><div class="line"></div><div class="line">$ git <span class="built_in">add</span> test.txt</div><div class="line"></div><div class="line">$ git status</div><div class="line">On branch testbranch</div><div class="line">Changes <span class="keyword">to</span> <span class="keyword">be</span> committed:</div><div class="line">  (use <span class="string">"git reset HEAD &lt;file&gt;..."</span> <span class="keyword">to</span> unstage)</div><div class="line"></div><div class="line">        <span class="keyword">new</span> <span class="keyword">file</span>:   test.txt</div></pre></td></tr></table></figure>
<p>只要在 “Changes to be committed” 这行下面的，就说明是已暂存状态。如果此时提交，那么该文件此<br>时此刻的版本将被留存在历史记录中。每修改一次，都要使用<code>git add fileName</code>跟踪变化的文件</p>
<h2 id="撤销跟踪（从暂存区清除）"><a href="#撤销跟踪（从暂存区清除）" class="headerlink" title="撤销跟踪（从暂存区清除）"></a>撤销跟踪（从暂存区清除）</h2><p><code>git reset HEAD &lt;file&gt;</code></p>
<h2 id="提交更新"><a href="#提交更新" class="headerlink" title="提交更新"></a>提交更新</h2><p><code>git commit -m &quot;message&quot;</code></p>
<h2 id="比较差异"><a href="#比较差异" class="headerlink" title="比较差异"></a>比较差异</h2><p>1 <code>git diff</code>,查看工作区与暂存区的差别的<br>2 <code>git diff --cached</code>,查看暂存区和上次提交时的快照（版本库）之间的差异<br>3 <code>git diff HEAD</code>，查看工作区和上次提交时的快照（版本库）之间的差异   </p>
<h2 id="移除文件"><a href="#移除文件" class="headerlink" title="移除文件"></a>移除文件</h2><p>如果直接删除，执行<code>git status</code>后<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">$ git status</div><div class="line">On branch testbranch</div><div class="line">Changes not staged for <span class="keyword">commit</span>:</div><div class="line">  (<span class="keyword">use</span> <span class="string">"git add/rm &lt;file&gt;..."</span> <span class="keyword">to</span> <span class="keyword">update</span> what will be committed)</div><div class="line">  (<span class="keyword">use</span> <span class="string">"git checkout -- &lt;file&gt;..."</span> <span class="keyword">to</span> discard changes <span class="keyword">in</span> working <span class="keyword">directory</span>)</div><div class="line"></div><div class="line">        deleted:    test.txt</div><div class="line"></div><div class="line"><span class="keyword">no</span> changes added <span class="keyword">to</span> <span class="keyword">commit</span> (<span class="keyword">use</span> <span class="string">"git add"</span> <span class="keyword">and</span>/<span class="keyword">or</span> <span class="string">"git commit -a"</span>)</div></pre></td></tr></table></figure></p>
<p>1 如果确实要删除，执行<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">git <span class="keyword">rm</span> &lt;fileName&gt;</div><div class="line">git commit -<span class="keyword">m</span><span class="string">"message"</span></div><div class="line"></div><div class="line">git <span class="keyword">rm</span> <span class="keyword">test</span>.txt</div><div class="line">git commit -<span class="keyword">m</span><span class="string">"delete test.txt"</span></div></pre></td></tr></table></figure></p>
<p>2 如果不想删除，想要找回删除的文件，执行<br><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">git</span> <span class="comment">checkout</span> <span class="literal">-</span><span class="literal">-</span> &lt;<span class="comment">fileName</span>&gt;<span class="comment">(</span><span class="literal">-</span><span class="literal">-</span><span class="comment">和fileName之间有空格)</span></div><div class="line"><span class="comment">git</span> <span class="comment">checkout</span> <span class="literal">-</span><span class="literal">-</span> <span class="comment">test</span><span class="string">.</span><span class="comment">txt</span></div></pre></td></tr></table></figure></p>
<p>可以再工作区中看到test.txt文件又回来了</p>
<p>3 如果删除之前修改过并且已经放到暂存区域的话，则必须要用强制删除选项 -f，以防误删除文件后丢失修改的内容</p>
<p>4 <em>想把文件从 Git 仓库中删除（亦即从暂存区域移除），但仍然希望保留在当前工作<br>目录中。换句话说，仅是从跟踪清单中删除。比如一些大型日志文件或者一堆 .a 编译文件，不小心纳入仓库<br>后，要移除跟踪但不删除文件，以便稍后在 .gitignore 文件中补上，用 –cached 选项即可：<br><code>$ git rm --cached test.txt</code></em></p>
<h2 id="查看历史提交"><a href="#查看历史提交" class="headerlink" title="查看历史提交"></a>查看历史提交</h2><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">git <span class="built_in">log</span></div><div class="line">git <span class="built_in">log</span> -p <span class="number">-2</span> (常用 -p 选项展开显示每次提交的内容差异，用 <span class="number">-2</span> 则仅显示最近的两次更新)</div><div class="line">git <span class="built_in">log</span> <span class="comment">--stat (仅显示简要的增改行数统计)</span></div><div class="line">git <span class="built_in">log</span> <span class="comment">--pretty=[oneline | short | full | fuller]</span></div><div class="line">git <span class="built_in">log</span> <span class="comment">--pretty=format:...</span></div><div class="line">git <span class="built_in">log</span> <span class="comment">--pretty=format:"%h - %an, %ar : %s"</span></div><div class="line"></div><div class="line">git <span class="built_in">log</span> <span class="comment">--pretty=oneline --graph</span></div><div class="line"></div><div class="line">$ git <span class="built_in">log</span> <span class="comment">--pretty=oneline --graph</span></div><div class="line">* <span class="number">2</span>b44a1b29da60985db49669f33ea5d9be4256770 <span class="built_in">delete</span> test.txt</div><div class="line">* <span class="number">58</span>b4edd691cb4c8a4458831d4750bcca01630919 <span class="built_in">add</span> test.txt</div><div class="line">* d3eed9e927117c6d158d5e29158632a6cf65caf7 <span class="built_in">add</span> <span class="number">3</span></div><div class="line">* <span class="number">72</span>f98cf95d8477a880d0078a6f6959a0edadffcf amend2</div><div class="line">* ff51daf49347ae242243816e5341ef207905645a test2</div><div class="line">*   bc9e6947b8139649a86e2873668299c2131deea0 Merge branch <span class="string">'bob'</span></div><div class="line">|\</div><div class="line">| * ed2b23e1080a79b9011344d58d69f105e453625b <span class="built_in">add</span> <span class="built_in">merge</span> <span class="keyword">with</span> <span class="comment">--no-ff</span></div><div class="line">|/</div><div class="line">* <span class="number">972369043</span>db41a60eaa5e4c5a9a8c3b9772777d4 <span class="built_in">add</span> <span class="built_in">merge</span> <span class="comment">--no-ff</span></div><div class="line"></div><div class="line">git <span class="built_in">log</span> <span class="comment">--[since | until | author | committer]=</span></div><div class="line">-(n) 仅显示最近的 n 条提交</div><div class="line"><span class="comment">--since, --after 仅显示指定时间之后的提交。</span></div><div class="line"><span class="comment">--until, --before 仅显示指定时间之前的提交。</span></div><div class="line"><span class="comment">--author 仅显示指定作者相关的提交。</span></div><div class="line"><span class="comment">--committer 仅显示指定提交者相关的提交。</span></div><div class="line"></div><div class="line">gitk (git <span class="built_in">log</span> 命令的可视化版)</div></pre></td></tr></table></figure>
<p>(用 oneline 或 format 时结合 –graph 选项，可以看到开头多出一些 ASCII 字符串表示的简单图形，形象<br>地展示了每个提交所在的分支及其分化衍合情况)</p>
<h2 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h2><h2 id="撤销提交"><a href="#撤销提交" class="headerlink" title="撤销提交"></a>撤销提交</h2><p>想要撤消刚才的提交操作,重新提,可以使用 –amend 选项，上次的提交作废（git log中不存在上次提交记录）<br><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ git commit -m <span class="string">'initial commit'</span></div><div class="line">$ git <span class="keyword">add</span><span class="bash"> forgotten_file</span></div><div class="line">$ git commit --amend -m<span class="string">"message"</span></div></pre></td></tr></table></figure></p>
<h2 id="撤销暂存区"><a href="#撤销暂存区" class="headerlink" title="撤销暂存区"></a>撤销暂存区</h2><p><code>git reset HEAD &lt;file&gt;</code></p>
<h2 id="撤销对文件的修改"><a href="#撤销对文件的修改" class="headerlink" title="撤销对文件的修改"></a>撤销对文件的修改</h2><p><code>git checkout -- &lt;fileName&gt;</code>(–和fileName之间有空格)</p>
<h2 id="远程库"><a href="#远程库" class="headerlink" title="远程库"></a>远程库</h2><h2 id="查看当前远程库"><a href="#查看当前远程库" class="headerlink" title="查看当前远程库"></a>查看当前远程库</h2><p>可以用<code>git remote [-v](显示url)</code>命令，它会列出每个远程库的简短名字。在克隆完某个项目后，至少可以看到一个名为 origin 的远程库，Git 默认使用这个名字来标识你所克隆的原始仓库.</p>
<h2 id="添加远程库"><a href="#添加远程库" class="headerlink" title="添加远程库"></a>添加远程库</h2><p><code>git remote add [shortname] [url]</code> 可以添加多个远程库</p>
<h2 id="从远程仓库抓取数据"><a href="#从远程仓库抓取数据" class="headerlink" title="从远程仓库抓取数据"></a>从远程仓库抓取数据</h2><figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">git</span> <span class="selector-tag">fetch</span> <span class="selector-attr">[remote-name]</span></div><div class="line"></div><div class="line"><span class="selector-tag">git</span> <span class="selector-tag">pull</span> (从原始克隆的远端仓库中抓取数据后，合并到工作目录中*当前*分支)</div></pre></td></tr></table></figure>
<p>1 此命令会到远程仓库中拉取所有你本地仓库中还没有的数据。运行完成后，你就可以在本地访问该远程仓库中的所有分支，将其中某个分支合并到本地，或者只是取出某个分支，一探究竟</p>
<p>2 如果是克隆了一个仓库，此命令会自动将远程仓库归于 origin 名下。所以<code>git fetch origin</code>会抓取从你上<br>次克隆以来别人上传到此远程仓库中的所有更新（或是上次 fetch 以来别人提交的更新）。有一点很重要，<br>需要记住，fetch 命令只是将远端的数据拉到本地仓库，并不自动合并到<em>当前</em>工作分支，只有当你确实准备好<br>了，才能手工合并</p>
<h2 id="推送数据到远程仓库"><a href="#推送数据到远程仓库" class="headerlink" title="推送数据到远程仓库"></a>推送数据到远程仓库</h2><p><code>git push &lt;remote-name&gt; &lt;branch-name&gt;</code></p>
<h2 id="查看远程仓库信息"><a href="#查看远程仓库信息" class="headerlink" title="查看远程仓库信息"></a>查看远程仓库信息</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">git remote <span class="keyword">show</span> &lt;remote-<span class="keyword">name</span>&gt; </div><div class="line"></div><div class="line">$ git remote <span class="keyword">show</span> origin</div><div class="line">* remote origin</div><div class="line">  <span class="keyword">Fetch</span> <span class="keyword">URL</span>: https://github.com/Sword2G/learngit.git</div><div class="line">  Push  <span class="keyword">URL</span>: https://github.com/Sword2G/learngit.git</div><div class="line">  <span class="keyword">HEAD</span> branch: <span class="keyword">master</span></div><div class="line">  Remote branches:</div><div class="line">    <span class="keyword">master</span>     tracked</div><div class="line">    testbranch tracked</div><div class="line">  <span class="keyword">Local</span> branch configured <span class="keyword">for</span> <span class="string">'git pull'</span>:</div><div class="line">    <span class="keyword">master</span> merges <span class="keyword">with</span> remote <span class="keyword">master</span></div><div class="line">  <span class="keyword">Local</span> refs configured <span class="keyword">for</span> <span class="string">'git push'</span>:</div><div class="line">    <span class="keyword">master</span>     pushes <span class="keyword">to</span> <span class="keyword">master</span>     (up <span class="keyword">to</span> <span class="built_in">date</span>)</div><div class="line">    testbranch pushes <span class="keyword">to</span> testbranch (up <span class="keyword">to</span> <span class="built_in">date</span>)</div></pre></td></tr></table></figure>
<h2 id="远程仓库的重命名"><a href="#远程仓库的重命名" class="headerlink" title="远程仓库的重命名"></a>远程仓库的重命名</h2><p>对远程仓库的重命名，也会使对应的分支名称发生变化，原来的 pb/master 分支现在成了 paul/master<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">git remote <span class="built_in">rename</span> <span class="symbol">&lt;oldName&gt;</span> <span class="symbol">&lt;newName&gt;</span></div><div class="line"></div><div class="line">$ git remote <span class="built_in">rename</span> pb paul</div><div class="line">$ git remote</div><div class="line">origin</div><div class="line">paul</div></pre></td></tr></table></figure></p>
<h2 id="远程仓库的删除"><a href="#远程仓库的删除" class="headerlink" title="远程仓库的删除"></a>远程仓库的删除</h2><p>碰到远端仓库服务器迁移，或者原来的克隆镜像不再使用，又或者某个参与者不再贡献代码，那么需要移除对应的远端仓库，可以运行 git remote rm 命令<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">git remote rm &lt;remoteName&gt;</div><div class="line"><span class="variable">$ </span>git remote rm paul</div><div class="line"><span class="variable">$ </span>git remote</div><div class="line">origin</div></pre></td></tr></table></figure></p>
<h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><h2 id="列显已有的标签"><a href="#列显已有的标签" class="headerlink" title="列显已有的标签"></a>列显已有的标签</h2><p><code>git tag</code></p>
<h2 id="创建的新标签"><a href="#创建的新标签" class="headerlink" title="创建的新标签"></a>创建的新标签</h2><p><code>git tag -a v1.0 -m&quot;message&quot;</code></p>
<h2 id="后期加注标签"><a href="#后期加注标签" class="headerlink" title="后期加注标签"></a>后期加注标签</h2><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ git <span class="built_in">log</span> <span class="comment">--pretty=oneline -2</span></div><div class="line"><span class="number">72</span>f98cf95d8477a880d0078a6f6959a0edadffcf amend2</div><div class="line">ff51daf49347ae242243816e5341ef207905645a test2</div><div class="line"></div><div class="line">查看提交的校验和</div><div class="line">git tag -<span class="keyword">a</span> v1<span class="number">.1</span> <span class="number">72</span>f98c [-m<span class="string">"message"</span>]</div></pre></td></tr></table></figure>
<h2 id="推送标签"><a href="#推送标签" class="headerlink" title="推送标签"></a>推送标签</h2><p>默认情况下，<code>git push</code>并不会把标签传送到远端服务器上，只有通过显式命令才能分享标签到远端仓库。其<br>命令格式如同推送分支，运行<code>git push origin [tagname]</code> </p>
<p>如果要一次推送所有（本地新增的）标签上去，可以使用 –tags<br><code>$ git push origin --tags</code></p>
<h1 id="git分支"><a href="#git分支" class="headerlink" title="git分支"></a>git分支</h1><h2 id="分支内涵"><a href="#分支内涵" class="headerlink" title="分支内涵"></a>分支内涵</h2><ul>
<li><p>在<code>Git</code>中提交时，会保存一个提交（commit）对象，它包含一个指向暂存内容快照的指针，作者和相关附<br>属信息，以及一定数量（也可能没有）指向该提交对象直接祖先的指针：第一次提交是没有直接祖先的，普通<br>提交有一个祖先，由两个或多个分支合并产生的提交则有多个祖先</p>
</li>
<li><p>当使用<code>git commit</code>新建一个提交对象前，Git会先计算每一个子目录（本例中就是项目根目录）的校验和,然后在Git仓库中将这些目录保存为树(tree)对象。之后Git创建的提交对象，除了包含相关提交信息以外，还包含着指向这个树对象（项目根目录）的指针，如此它就可以在将来需要的时候，重现此次快照的内容了</p>
</li>
<li><p>现在，Git仓库中有五个对象：三个表示文件快照内容的blob对象;一个记录着目录树内容及其中各个文件对应 blob 对象索引的tree对象；以及一个包含指向tree对象（根目录）的索引和其他提交信息元数据的commit对象<br><img src="http://7xum8m.com1.z0.glb.clouddn.com/hexo-git-obj.png" alt="git_object"></p>
</li>
<li>Git中的分支，其实本质上仅仅是个指向commit对象的可变指针。Git会使用master作<br>为分支的默认名字。在若干次提交后，你其实已经有了一个指向最后一次提交对象的master分支，它在每次<br>提交的时候都会自动向前移动<br><img src="http://7xum8m.com1.z0.glb.clouddn.com/hexo-after-server-gits.png" alt="after_several_gits"></li>
</ul>
<h2 id="创建新分支"><a href="#创建新分支" class="headerlink" title="创建新分支"></a>创建新分支</h2><figure class="highlight armasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">git</span> <span class="keyword">branch </span>&lt;<span class="keyword">branch-name&gt;`</span></div><div class="line"><span class="symbol">git</span> -<span class="keyword">b </span><span class="keyword">branch </span>&lt;<span class="keyword">branch-name&gt;`(创建分支并进入分支)</span></div></pre></td></tr></table></figure>
<p>在当前 commit 对象上新建一个分支指针</p>
<h2 id="切换分支"><a href="#切换分支" class="headerlink" title="切换分支"></a>切换分支</h2><p><code>git checkout &lt;branch-name&gt;</code><br>切换分支的时候最好保持一个清洁的工作区域，Git会把工作目录的内容恢复为检出某分支时它所指向的那个commit的快照。它会自动添加、删除和修改文件以确保目录的内容和你上次提交时完全一样。</p>
<h2 id="HEAD指针"><a href="#HEAD指针" class="headerlink" title="HEAD指针"></a>HEAD指针</h2><p>Git中，HEAD指针是一个指向你<strong>正在工作中的本地分支</strong>的指针</p>
<h2 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h2><p>首先切换到要合并的分支然后执行<code>git merge &lt;branch-name&gt;</code>,比如要把testbranch分支合并到master分支，先执行<code>git checkout master</code>然后执行<code>git merge testbranch</code><br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ git merge testbranch</div><div class="line">Updating <span class="number">72</span>f98cf..e0e37f4</div><div class="line">Fast-forward</div><div class="line"> LICENSE.txt | <span class="number">3</span> ++-</div><div class="line"> test1.txt   | <span class="number">1</span> +</div><div class="line"> <span class="number">2</span> files <span class="section">changed</span>, <span class="number">3</span> insertions(+), <span class="number">1</span> deletion(-)</div></pre></td></tr></table></figure></p>
<p>合并时出现了”Fast-forward”（快进）提示。由于当前master分支所在的commit是要并入<br>的testbranch分支的直接上游,Git只需把指针直接右移,如果顺着一个分支走下去可以到达另一个<br>分支，那么Git在合并两者时，只会简单地把指针前移，因为没有什么分歧需要解决，所以这个过程叫做快进（Fast forward）。合并之后master分支和testbranch分支指向相同的提交，如果testbranch分支不在使用就可以删除了</p>
<h2 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h2><p><code>git branch -d &lt;branch-name&gt;</code></p>
<h2 id="查看分支"><a href="#查看分支" class="headerlink" title="查看分支"></a>查看分支</h2><figure class="highlight armasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">git</span> <span class="keyword">branch`</span></div><div class="line"><span class="symbol">git</span> <span class="keyword">branch </span>-v 各个分支的最后一次提交</div><div class="line"><span class="symbol">git</span> <span class="keyword">branch </span>--merge 查看合并的分支</div><div class="line"><span class="symbol">git</span> <span class="keyword">branch </span>--no-merge 查看未合并分支</div><div class="line">正常情况下无法删除未合并的分支，如果确认要删除可以执行</div><div class="line"><span class="symbol">git</span> <span class="keyword">branch </span>-D &lt;<span class="keyword">branch-name&gt;</span></div></pre></td></tr></table></figure>
<h2 id="远程分支"><a href="#远程分支" class="headerlink" title="远程分支"></a>远程分支</h2><blockquote>
<p>假设你们团队有个地址为git.ourcompany.com的Git服务器。如果你从这里克隆，Git会自动为你将此远程仓库命名为origin，并下载其中所有的数据，建立一个指向它的 master分支的指针，在本地命名为origin/master，但你无法在本地更改其数据。接着，Git建立一个属于你自己的本地master分支，始于origin上master分支相同的位置，你可以就此开始工作；要是你在本地 master 分支做了会儿事情，与此同时，其他人向 git.ourcompany.com推送了内容，更新了上面的master分支，那么你的提交历史会开始朝不同的方向发展。不过只要你不和服务器通讯，你的 origin/master指针不会移动。</p>
</blockquote>
<p><strong>一次 Git 克隆会建立你自己的本地分支master和远程分支origin/master，它们都指向origin/master分支的最后一次提交</strong></p>
<h2 id="推送远程分支"><a href="#推送远程分支" class="headerlink" title="推送远程分支"></a>推送远程分支</h2><figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">git push &lt;remote-name&gt; &lt;branch-name&gt;</div><div class="line"></div><div class="line">git push origin &lt;local-branch-name&gt;<span class="symbol">:&lt;remote-branch-name&gt;</span></div><div class="line">git push origin <span class="symbol">serverfix:</span>awesomebranch</div></pre></td></tr></table></figure>
<p>当你的协作者再次从服务器上获取数据时，他们将得到一个新的远程分支origin/serverfix：<br><code>git fetch origin</code></p>
<p><strong>Note：在 fetch 操作抓来新的远程分支之后，你仍然无法在本地编辑该远程仓库。换句话说，在<br>本例中，你不会有一个新的serverfix分支，有的只是一个你无法移动的origin/serverfix指针。<br>如果要把该内容合并到当前分支，可以运行git merge origin/serverfix。如果想要一份自己的serverfix来开<br>发，可以在远程分支的基础上分化出一个新的分支来：</strong><br><code>git checkout -b serverfix origin/serverfix</code></p>
<h2 id="跟踪分支"><a href="#跟踪分支" class="headerlink" title="跟踪分支"></a>跟踪分支</h2><p>从远程分支检出的本地分支，称为跟踪分支(tracking branch)。跟踪分支是一种和远程分支有直接联系的<br>本地分支。在跟踪分支里输入git push，Git会自行推断应该向哪个服务器的哪个分支推送数据。反过来，在<br>这些分支里运行git pull会获取所有远程索引，并把它们的数据都合并到本地分支中来。</p>
<p>Git通常会自动创建一个master分支来跟踪origin/master手动创建跟踪分支<br><code>git checkout -b &lt;local-branch-name&gt; &lt;remote-name&gt;/&lt;remote-branch-name&gt;</code></p>
<h2 id="删除远程分支"><a href="#删除远程分支" class="headerlink" title="删除远程分支"></a>删除远程分支</h2><figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git push &lt;remote-name&gt; <span class="symbol">:&lt;local-branch-name&gt;</span></div><div class="line">git push origin <span class="symbol">:serverfix</span></div></pre></td></tr></table></figure>
<blockquote>
<p><code>git push &lt;remote-name&gt; &lt;local-branch-name&gt;:&lt;remote-branch-name&gt;</code> 语法，如<br>果省略<local-branch-name>，那就等于是在说把空白推送到远程分支。</local-branch-name></p>
</blockquote>
<h2 id="衍合"><a href="#衍合" class="headerlink" title="衍合"></a>衍合</h2><figure class="highlight applescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ git checkout experiment</div><div class="line">$ git rebase master</div><div class="line">First, rewinding head <span class="keyword">to</span> replay your work <span class="keyword">on</span> top <span class="keyword">of</span> <span class="keyword">it</span>...</div><div class="line">Applying: added staged command</div></pre></td></tr></table></figure>
<h1 id="git文件"><a href="#git文件" class="headerlink" title=".git文件"></a>.git文件</h1><p>当你在一个新目录或已有目录内执行 git init 时，Git 会创建一个 .git 目录，几乎所有 Git 存储和操作<br>的内容都位于该目录下。如果你要备份或复制一个库，基本上将这一目录拷贝至其他地方就可以了</p>
<p>objects<br>目录存储所有数据内容， refs 目录存储指向数据 (分支) 的提交对象的指针， HEAD 文件指向当前分支， index<br>文件保存了暂存区域信息</p>
<p>Git 将文件头与原始数据内容拼接起来，并计算拼接后的新内容的 SHA-1 校验和。可<br> Git 存储数据内容的方式──为每份内容生成一个文件，取<br>得该内容与头信息的 SHA-1 校验和，创建以该校验和前两个字符为名称的子目录，并以 (校验和) 剩下 38<br>个字符为文件命名 (保存至子目录下)。</p>
<h2 id="blob对象"><a href="#blob对象" class="headerlink" title="blob对象"></a>blob对象</h2><p>存储的并不是文件名而仅仅是文件内<br>容。保存的是压缩后的内容这种对象类型称为 blob 。</p>
<h2 id="tree对象"><a href="#tree对象" class="headerlink" title="tree对象"></a>tree对象</h2><p>git中 tree 对象对应于 UNIX 中的<br>目录，blob 对象则大致对应于 inodes 或文件内容。<br>通常 Git 根据你的暂存区域或 index 来创建并写入一个 tree<br>它指向你要跟踪的项目的不同快照</p>
<h2 id="commit对象"><a href="#commit对象" class="headerlink" title="commit对象"></a>commit对象</h2><p>commit 对象有格式很简单：指明了该时间点项目快照的顶层树对象、作者/提交者信息以及当前时间戳、一个空行，以及提交注释信息</p>
<h2 id="三个对象的关系"><a href="#三个对象的关系" class="headerlink" title="三个对象的关系"></a>三个对象的关系</h2><p>运行　 git add 和<br>git commit 命令时，git会保存修改了的文件的blob(文件+文件头的sha-1值)，更新暂存区/索引(index)，根据暂存区/索引(index)创建 tree 对象(快照)，最后创建<br>commit 对象，这些 commit 对象指向了顶层 tree 对象以及先前的 commit 对象。<br>这三类 Git 对象 ──<br>blob，tree 以及 tree ── 都各自以文件的方式保存在 .git/objects 目录下</p>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>用于记住最后一次提交<br>head目录下的每个引用其实都对应于本地的各个分支<br>基本上 Git 中的一个分支其实就是一个指向某个工作版本一条 HEAD 记录的指针或引用。你可</p>
<h2 id="（to-be-continued…）"><a href="#（to-be-continued…）" class="headerlink" title="（to be continued…）"></a>（to be continued…）</h2><h1 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h1><blockquote>
<p>2016_5_24<br>Q:<br>error: src refspec master does not match any.<br>error: failed to push some refs to ‘XXX’<br>A:<br>本地版本库为空从而不能提交 (只进行了init, 没有add和commit)</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近工作使用Git，发现很多Git命令忘了，重新阅读了ProGit，在这里做做笔记，方便自己查阅&lt;br&gt;
    
    </summary>
    
      <category term="Git" scheme="https://github.com/Sword2G/sword2g.github.io/categories/Git/"/>
    
    
      <category term="Git" scheme="https://github.com/Sword2G/sword2g.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Python爬虫之urllib2笔记</title>
    <link href="https://github.com/Sword2G/sword2g.github.io/2016/03/29/crawler-urllib2/"/>
    <id>https://github.com/Sword2G/sword2g.github.io/2016/03/29/crawler-urllib2/</id>
    <published>2016-03-29T02:07:55.000Z</published>
    <updated>2017-03-03T15:16:00.496Z</updated>
    
    <content type="html"><![CDATA[<p>利用Python urllib、urllib2，实现简单爬虫。</p>
<a id="more"></a>
<h1 id="简单示例"><a href="#简单示例" class="headerlink" title="简单示例"></a>简单示例</h1><p>利用Python的urllib2库，可以很方便的完成网页抓取功能，下面五行代码实现百度主页抓取及打印。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># -*- coding: utf-8 -*-</span></div><div class="line"><span class="keyword">import</span> urllib</div><div class="line"><span class="keyword">import</span> urllib2</div><div class="line"> </div><div class="line">response = urllib2.urlopen(<span class="string">"http://www.baidu.com"</span>)</div><div class="line"><span class="keyword">print</span> response.read()</div></pre></td></tr></table></figure>
<h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h2><p> urllib2.urlopen()函数的原型为<br> <em>urllib2.urlopen(url[, data[, timeout[, cafile[, capath[, cadefault[, context]]]]])<br>Open the URL url, which can be either a string or a Request object.</em></p>
<p>1 timeout参数用于设置超时时间（以秒为单位）；<br>2 data参数用于即为待提交的参数，需要用urllib.urlencode()函数进行编码；<br>3 url参数即为请求的url字符串或者Request对象。</p>
<h1 id="提交数据"><a href="#提交数据" class="headerlink" title="提交数据"></a>提交数据</h1><h2 id="POST请求"><a href="#POST请求" class="headerlink" title="POST请求"></a>POST请求</h2><p>POST进行表单的提交，提交的数据为key-value键值对。</p>
<h3 id="POST示例"><a href="#POST示例" class="headerlink" title="POST示例"></a>POST示例</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"># -*- coding: utf<span class="number">-8</span> -*-</div><div class="line"><span class="keyword">import</span> urllib</div><div class="line"><span class="keyword">import</span> urllib2</div><div class="line"> </div><div class="line">url = <span class="string">'http://httpbin.org/post'</span></div><div class="line">post_data = &#123;<span class="string">'key1'</span>:<span class="string">'value1'</span>, <span class="string">'key2'</span>:<span class="string">'value2'</span>&#125;</div><div class="line">formal_post_data = urllib.urlencode(post_data)</div><div class="line"> </div><div class="line">response = urllib2.urlopen(url,formal_post_data)</div><div class="line"> </div><div class="line"><span class="built_in">print</span> response.<span class="built_in">read</span>()</div></pre></td></tr></table></figure>
<h3 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h3><p><img src="http://7xum8m.com1.z0.glb.clouddn.com/hexo-crawler-urllib2-post.jpg" alt="post"></p>
<h2 id="GET请求"><a href="#GET请求" class="headerlink" title="GET请求"></a>GET请求</h2><p>GET请求的参数是附加在url的后面，用”?”隔开</p>
<h3 id="GET示例"><a href="#GET示例" class="headerlink" title="GET示例"></a>GET示例</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"># -*- coding: utf<span class="number">-8</span> -*-</div><div class="line"><span class="keyword">import</span> urllib</div><div class="line"><span class="keyword">import</span> urllib2</div><div class="line"> </div><div class="line">get_data = &#123;<span class="string">'key1'</span>:<span class="string">'value1'</span>, <span class="string">'key2'</span>:<span class="string">'value2'</span>&#125;</div><div class="line">formal_get_data = urllib.urlencode(get_data)</div><div class="line"> </div><div class="line">url = <span class="string">'http://httpbin.org/get'</span> + <span class="string">'?'</span> + formal_get_data   </div><div class="line">response = urllib2.urlopen(url)</div><div class="line"> </div><div class="line"><span class="built_in">print</span> response.<span class="built_in">read</span>()</div></pre></td></tr></table></figure>
<h3 id="运行结果-1"><a href="#运行结果-1" class="headerlink" title="运行结果"></a>运行结果</h3><p><img src="http://7xum8m.com1.z0.glb.clouddn.com/hexo-crawler-urllib2-get.jpg" alt="get"></p>
<h1 id="Request对象"><a href="#Request对象" class="headerlink" title="Request对象"></a>Request对象</h1><p>注意 urllib2.urlopen（）函数的第一个参数也可以是Request对象，Request对象的引入将更加方便的封装数据</p>
<h2 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h2><p><em>urllib2.Request(url[, data][, headers][, origin_req_host][, unverifiable])</em></p>
<h3 id="Request示例"><a href="#Request示例" class="headerlink" title="Request示例"></a>Request示例</h3><figure class="highlight gams"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"># -*- coding: utf<span class="number">-8</span> -*-</div><div class="line">import urllib</div><div class="line">import urllib2</div><div class="line"> </div><div class="line">url = <span class="string">'http://httpbin.org/post'</span></div><div class="line"> </div><div class="line">post_data = &#123;<span class="string">'key1'</span>:<span class="string">'value1'</span>, <span class="string">'key2'</span>:<span class="string">'value2'</span>&#125;</div><div class="line">formal_post_data = urllib.urlencode(post_data)</div><div class="line"> </div><div class="line">#<span class="keyword">set</span> headers</div><div class="line">headers <span class="comment">= &#123;</span><span class="comment">'User-Agent'</span><span class="comment"> :</span> <span class="comment">'Mozilla/4.0 (compatible; MSIE 5.5; Windows NT)'</span><span class="comment">&#125;</span></div><div class="line"> </div><div class="line">request <span class="comment">= urllib2.Request(url, formal_post_data, headers)</span></div><div class="line"> </div><div class="line">response <span class="comment">= urllib2.urlopen(request)</span></div><div class="line">      </div><div class="line">#supposed <span class="comment">it is encoded in utf-8</span></div><div class="line">content <span class="comment">= response.read().decode(</span><span class="comment">'utf-8'</span><span class="comment">)</span></div><div class="line"></div><div class="line">print <span class="comment">content</span></div></pre></td></tr></table></figure>
<h3 id="运行结果-2"><a href="#运行结果-2" class="headerlink" title="运行结果"></a>运行结果</h3><p><img src="http://7xum8m.com1.z0.glb.clouddn.com/hexo-crawler-urllib2-requestobjs.jpg" alt=""></p>
<h2 id="Request的有关函数"><a href="#Request的有关函数" class="headerlink" title="Request的有关函数"></a>Request的有关函数</h2><p>获得Request的元数据</p>
<h3 id="有关函数示例"><a href="#有关函数示例" class="headerlink" title="有关函数示例"></a>有关函数示例</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># -*- coding: utf-8 -*-</span></div><div class="line"><span class="keyword">import</span> urllib</div><div class="line"><span class="keyword">import</span> urllib2</div><div class="line"> </div><div class="line">url = <span class="string">'http://httpbin.org/post'</span></div><div class="line"> </div><div class="line">post_data = &#123;<span class="string">'key1'</span>:<span class="string">'value1'</span>, <span class="string">'key2'</span>:<span class="string">'value2'</span>&#125;</div><div class="line">formal_post_data = urllib.urlencode(post_data)</div><div class="line"> </div><div class="line"><span class="comment">#set headers</span></div><div class="line">headers = &#123;<span class="string">'User-Agent'</span> : <span class="string">'Mozilla/4.0 (compatible; MSIE 5.5; Windows NT)'</span>&#125;</div><div class="line"> </div><div class="line">request = urllib2.Request(url, formal_post_data, headers)</div><div class="line"> </div><div class="line"><span class="keyword">print</span> <span class="string">u'返回请求的方法post/GET'</span></div><div class="line">method = request.get_method()</div><div class="line"><span class="keyword">print</span> <span class="string">'get_method===&gt;'</span> + method</div><div class="line"><span class="keyword">print</span> <span class="string">u'返回提交的数据'</span></div><div class="line">data = request.get_data()</div><div class="line"><span class="keyword">print</span> <span class="string">'request.get_data()===&gt;'</span>,data</div><div class="line"> </div><div class="line"><span class="keyword">print</span> <span class="string">u'返回参数中的url'</span></div><div class="line">full_url = request.get_full_url()</div><div class="line"><span class="keyword">print</span> <span class="string">'request.get_full_url()===&gt;'</span>,full_url</div><div class="line"> </div><div class="line"><span class="keyword">print</span> <span class="string">u'返回请求的schema'</span></div><div class="line">request_type = request.get_type()</div><div class="line"><span class="keyword">print</span> <span class="string">'request.get_type()===&gt;'</span>,request_type</div><div class="line"> </div><div class="line"><span class="keyword">print</span> <span class="string">u'返回请求的主机'</span></div><div class="line">host = request.get_host()</div><div class="line"><span class="keyword">print</span> <span class="string">'request.get_host()===&gt;'</span>,host</div><div class="line"> </div><div class="line"><span class="keyword">print</span> <span class="string">u'返回选择器 - URL 中发送到服务器中的部分'</span></div><div class="line">selector = request.get_selector()</div><div class="line"><span class="keyword">print</span> <span class="string">'request.get_selector()===&gt;'</span>,selector</div><div class="line"> </div><div class="line"> </div><div class="line"><span class="keyword">print</span> <span class="string">u'返回选择器请求头部'</span></div><div class="line">header_items = request.header_items()</div><div class="line"><span class="keyword">print</span> <span class="string">'request.header_items()===&gt;'</span>,header_items</div><div class="line"> </div><div class="line"><span class="comment">##get_header(header_name, default=None) 获得指定的header</span></div><div class="line"><span class="comment">## Request.add_header(key, val)可添加头部</span></div><div class="line"><span class="comment">## Request.has_header(header) 检查是否实例拥有参数中的头</span></div><div class="line"><span class="comment">## Request.has_data() 检查是否含有POST数据</span></div></pre></td></tr></table></figure>
<h3 id="运行结果-3"><a href="#运行结果-3" class="headerlink" title="运行结果"></a>运行结果</h3><p><img src="http://7xum8m.com1.z0.glb.clouddn.com/hexo-crawler-urllib2-method.jpg" alt="request"></p>
<h1 id="Response对象"><a href="#Response对象" class="headerlink" title="Response对象"></a>Response对象</h1><h2 id="Response有关方法"><a href="#Response有关方法" class="headerlink" title="Response有关方法"></a>Response有关方法</h2><p>urllib2.urlopen（）函数返回的response对象有以下方法 </p>
<ul>
<li><p>geturl() — 返回所获取资源的URL,通常用于决定是否跟着一个重定向；</p>
</li>
<li><p>info() — 返回页面的元信息，例如头部信息，信息以 mimetools.表单的形式显现；   </p>
</li>
<li><p>getcode() — 返回响应的HTTP状态码。  </p>
</li>
</ul>
<h2 id="有关方法示例"><a href="#有关方法示例" class="headerlink" title="有关方法示例"></a>有关方法示例</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># -*- coding: utf-8 -*-</span></div><div class="line"><span class="keyword">import</span> urllib</div><div class="line"><span class="keyword">import</span> urllib2</div><div class="line"> </div><div class="line">url = <span class="string">'http://httpbin.org/post'</span></div><div class="line"> </div><div class="line">post_data = &#123;<span class="string">'key1'</span>:<span class="string">'value1'</span>, <span class="string">'key2'</span>:<span class="string">'value2'</span>&#125;</div><div class="line">formal_post_data = urllib.urlencode(post_data)</div><div class="line"> </div><div class="line"><span class="comment">#set headers</span></div><div class="line">headers = &#123;<span class="string">'User-Agent'</span> : <span class="string">'Mozilla/4.0 (compatible; MSIE 5.5; Windows NT)'</span>&#125;</div><div class="line"> </div><div class="line">request = urllib2.Request(url, formal_post_data, headers)</div><div class="line"> </div><div class="line">response = urllib2.urlopen(request)</div><div class="line"> </div><div class="line"><span class="keyword">print</span> <span class="string">u'获得真实url（重定向后的url）'</span></div><div class="line"><span class="keyword">print</span> response.geturl()</div><div class="line"><span class="keyword">print</span> <span class="string">u'获得返回状态码'</span></div><div class="line"><span class="keyword">print</span> response.code</div><div class="line"><span class="keyword">print</span> <span class="string">u'页面的元信息'</span></div><div class="line"><span class="keyword">print</span> response.info()</div></pre></td></tr></table></figure>
<h2 id="运行结果-4"><a href="#运行结果-4" class="headerlink" title="运行结果"></a>运行结果</h2><p><img src="http://7xum8m.com1.z0.glb.clouddn.com/hexo-crawler-urllib2-response.jpg" alt=""></p>
<h1 id="常用代码"><a href="#常用代码" class="headerlink" title="常用代码"></a>常用代码</h1><figure class="highlight gams"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"># -*- coding: utf<span class="number">-8</span> -*-</div><div class="line">import urllib</div><div class="line">import urllib2</div><div class="line"> </div><div class="line">url = <span class="string">'http://httpbin.org/post'</span></div><div class="line"> </div><div class="line">post_data = &#123;<span class="string">'key1'</span>:<span class="string">'value1'</span>, <span class="string">'key2'</span>:<span class="string">'value2'</span>&#125;</div><div class="line">formal_post_data = urllib.urlencode(post_data)</div><div class="line"> </div><div class="line">#<span class="keyword">set</span> headers</div><div class="line">headers <span class="comment">= &#123;</span><span class="comment">'User-Agent'</span><span class="comment"> :</span> <span class="comment">'Mozilla/4.0 (compatible; MSIE 5.5; Windows NT)'</span><span class="comment">&#125;</span></div><div class="line"> </div><div class="line">request <span class="comment">= urllib2.Request(url, formal_post_data, headers)</span></div><div class="line"> </div><div class="line">response <span class="comment">= urllib2.urlopen(request)</span></div><div class="line"> </div><div class="line">#supposed <span class="comment">it is encoded in utf-8</span></div><div class="line">content <span class="comment">= response.read().decode(</span><span class="comment">'utf-8'</span><span class="comment">)</span></div><div class="line"> </div><div class="line">print <span class="comment">content</span></div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;利用Python urllib、urllib2，实现简单爬虫。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://github.com/Sword2G/sword2g.github.io/categories/Python/"/>
    
    
      <category term="crawler" scheme="https://github.com/Sword2G/sword2g.github.io/tags/crawler/"/>
    
  </entry>
  
  <entry>
    <title>Linux中创建守护进程</title>
    <link href="https://github.com/Sword2G/sword2g.github.io/2016/03/22/create-daemon-in-linux/"/>
    <id>https://github.com/Sword2G/sword2g.github.io/2016/03/22/create-daemon-in-linux/</id>
    <published>2016-03-22T06:22:56.000Z</published>
    <updated>2016-03-22T06:29:12.469Z</updated>
    
    <content type="html"><![CDATA[<p>守护进程是长期在后台运行且不与任何控制终端关联的进程。他们常常在系统引导装入的时候启动，仅在系统关闭的时候才终止。</p>
<a id="more"></a>
<h1 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h1><h2 id="进程组"><a href="#进程组" class="headerlink" title="进程组"></a>进程组</h2><h3 id="进程组定义"><a href="#进程组定义" class="headerlink" title="进程组定义"></a>进程组定义</h3><blockquote>
<p>每一个进程除了有一个进程ID（pid）之外，还有一个进程组。进程组是一个或是多个进程的集合。通常他们在同一作业中结合起来，同一进程组中的进程接受来自同一终端的各种信号。每个进程组有一个组长进程，组长进程的进程ID与进程组的ID相同（也就是说一个进程的进程组ID等于其所在进程组组长进程的进程ID）</p>
</blockquote>
<h3 id="进程组的生命周期"><a href="#进程组的生命周期" class="headerlink" title="进程组的生命周期"></a>进程组的生命周期</h3><p>只要进程组中有一个进程存在，该进程组就存在，这与其组长进程是否存在无关。从进程组创建开始，到最后一个进程离开进程组（终止或者转移到其他进程组）的时间区间称为进程组的生命周期。</p>
<h3 id="相关函数"><a href="#相关函数" class="headerlink" title="相关函数"></a>相关函数</h3><ol>
<li>getpgrp()函数可返回调用进程的进程组ID</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"><span class="keyword">pid_t</span> getpgrp();</div></pre></td></tr></table></figure>
<ol>
<li>setpgid()函数可以加入一个现有的进程组或者创建一个新的进程组</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">setpgid</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">pid_t</span> pgid)</span></span></div></pre></td></tr></table></figure>
<ul>
<li>如果pid = gpid，则由pid指定的进程变成进程组长；</li>
<li>如果pid=0，则使用调用者的pid；</li>
<li>如果gpid = 0，则有pid指定的进程ID做进程组ID。<br>注意：一个进程只能为他自己或者为其子进程设置进程组ID。</li>
</ul>
<h2 id="会话-session"><a href="#会话-session" class="headerlink" title="会话(session)"></a>会话(session)</h2><h3 id="会话定义"><a href="#会话定义" class="headerlink" title="会话定义"></a>会话定义</h3><p>会话是一个或者多个进程组的集合。</p>
<h3 id="相关函数-1"><a href="#相关函数-1" class="headerlink" title="相关函数"></a>相关函数</h3><ol>
<li><p>getsid()函数返回会话首进程的进程组ID。（出错返回-1）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"><span class="keyword">pid_t</span> getsid(<span class="keyword">pid_t</span> pid);</div></pre></td></tr></table></figure>
</li>
<li><p>setsid()函数创建一个新会话<br>调用该函数的首要条件是调用进程不是某个进程组的组长，否则调用失败，返回-1</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"><span class="keyword">pid_t</span> setsid(<span class="keyword">void</span>)</div></pre></td></tr></table></figure>
</li>
</ol>
<p>调用该函数后</p>
<ul>
<li>该进程变成新会话的会话首进程(session leader)</li>
<li>该进程成一个新进程组的组长进程</li>
<li>该进程没有控制终端</li>
</ul>
<h2 id="控制终端-controlling-terminal"><a href="#控制终端-controlling-terminal" class="headerlink" title="控制终端(controlling terminal)"></a>控制终端(controlling terminal)</h2><h3 id="控制终端定义"><a href="#控制终端定义" class="headerlink" title="控制终端定义"></a>控制终端定义</h3><p>一个会话会有一个控制终端，控制终端一般是终端设备或者伪终端设备</p>
<h3 id="与会话的关系"><a href="#与会话的关系" class="headerlink" title="与会话的关系"></a>与会话的关系</h3><ul>
<li>会话的首进程与控制终端建立连接，此时会话首进程被称为控制进程。</li>
<li>一个会话有一个控制终端，则他有一个前台进程组，会话中其他的进程组为后台进程组</li>
<li>当键入中断键（Ctrl + C）退出键（Ctrl + \）,会将中断信号发往前台进程组中的所有进程</li>
<li>当与控制终端断开连接，挂断信号发送至控制进程(会话首进程)</li>
</ul>
<h1 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h1><h2 id="守护进程的定义"><a href="#守护进程的定义" class="headerlink" title="守护进程的定义"></a>守护进程的定义</h2><p>守护进程是长期在后台运行且不与任何控制终端关联的进程。他们常常在系统引导装入的时候启动，仅在系统关闭的时候才终止。</p>
<h2 id="编写守护进程规则"><a href="#编写守护进程规则" class="headerlink" title="编写守护进程规则"></a>编写守护进程规则</h2><ol>
<li>调用fork(),然后使父进程exit；</li>
<li>调用setsid(),创建新会话；</li>
<li>调用signal(),完成信号处理；</li>
<li>调用fork(),并终止掉父进程，防止其获得控制终端；</li>
<li>调用chdir(),改变守护进程工作目录；</li>
<li>调用umask()，重新设定文件创建屏蔽字；</li>
<li>关闭所有从父进程继承而来的所有文件描述符；</li>
<li>将stdin，stdout，stderr重定向到/dev/null(使/dev/null具有文件描述符0,1,2)。</li>
</ol>
<h2 id="实现源码"><a href="#实现源码" class="headerlink" title="实现源码"></a>实现源码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;syslog.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/resource.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">daemon_init</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pname, <span class="keyword">int</span> facility)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> i, fd0, fd1, fd2;</div><div class="line">	<span class="keyword">pid_t</span> pid;</div><div class="line">	<span class="keyword">struct</span> rlimit rl;</div><div class="line"></div><div class="line">	<span class="comment">//failed to fork first child</span></div><div class="line">	<span class="keyword">if</span>( (pid = fork()) &lt; <span class="number">0</span> )</div><div class="line">	&#123;</div><div class="line">		perror(<span class="string">"failed to fork first child"</span>);</div><div class="line">	&#125;</div><div class="line">	<span class="comment">//parent exit</span></div><div class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(pid != <span class="number">0</span>)</div><div class="line">	&#123;</div><div class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</div><div class="line">	&#125;</div><div class="line">	<span class="comment">//beacome session leader to lose controlling TTY</span></div><div class="line">	<span class="keyword">if</span>( setsid() &lt; <span class="number">0</span> )</div><div class="line">	&#123;</div><div class="line">		perror(<span class="string">"failed to beacome session leader"</span>);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">//ensure future opens won't allocate controlling TTYs</span></div><div class="line">	signal(SIGHUP, SIG_IGN);</div><div class="line">	<span class="keyword">if</span>( (pid = fork())&lt; <span class="number">0</span>)</div><div class="line">	&#123;</div><div class="line">		perror(<span class="string">"failed to fork second child"</span>);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(pid != <span class="number">0</span>)</div><div class="line">	&#123;</div><div class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</div><div class="line">	&#125;</div><div class="line">	<span class="comment">//change working direction</span></div><div class="line">	chdir(<span class="string">"/"</span>);</div><div class="line"></div><div class="line">	<span class="comment">//clear file creation mask</span></div><div class="line">	umask(<span class="number">0</span>);</div><div class="line"></div><div class="line">	<span class="comment">//close file descriptors</span></div><div class="line">	<span class="keyword">if</span>(getrlimit(RLIMIT_NOFILE, &amp;rl) &lt; <span class="number">0</span>)</div><div class="line">	&#123;</div><div class="line">		perror(<span class="string">"failed to get rlimit"</span>);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span>(rl.rlim_max == RLIM_INFINITY)</div><div class="line">		rl.rlim_max = <span class="number">1024</span>;</div><div class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; rl.rlim_max; i++)</div><div class="line">		close(i);</div><div class="line"></div><div class="line">	<span class="comment">//redirect stdin(0), stdout(1), stderr(2) to /dev/null</span></div><div class="line">	fd0 = open(<span class="string">"/dev/null"</span>, O_RDWR);</div><div class="line">	fd1 = dup(<span class="number">0</span>);</div><div class="line">	fd2 = dup(<span class="number">0</span>);</div><div class="line">	<span class="comment">//</span></div><div class="line">	openlog(pname, LOG_PID, facility);</div><div class="line"></div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="实现相关说明"><a href="#实现相关说明" class="headerlink" title="实现相关说明"></a>实现相关说明</h2><ol>
<li><p>fork()然后杀死父进程保留子进程是为了保证后续调用setsid()函数的进程不是进程组中的组长进程；</p>
</li>
<li><p>setsid()创建新的会话，并成为session leader；</p>
</li>
<li><p>将SIGHUP信号的处理方式设置成忽略（原因看说明4）；</p>
</li>
<li><p>第一个子进程再次fork然后留下子进程是为了确保进程不可能获得控制终端。当没有控制终端的会话首进程打开一个终端设备的时候，该终端自动成为该会话首进程的控制终端。fork然后留下子进程保证了进程不是会话首进程，从而无法获得控制终端。当第一个子进程exit的时候会发送SIGHUP信号到其子进程，而对于SIGHUP信号的默认处理是终止收到该信号的进程，所以必须调用signal将SIGHUP信号的处理方式改为SIG_IGN；</p>
</li>
<li><p>将守护进程的工作目录更改到合适的地方；</p>
</li>
<li><p>umask更改继承而来的文件创建屏蔽字，防止守护进程创建文件时出现权限问题；</p>
</li>
<li><p>所有文件描述符的获取这里使用了getrlimit()函数；</p>
</li>
<li><p>使标准输入输出标准错误都不再有效果，另外防止其他套接字占用这些文件描述符，而将某些输出发送给客户。</p>
</li>
</ol>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a href="http://www.apuebook.com/" target="_blank" rel="external">http://www.apuebook.com/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;守护进程是长期在后台运行且不与任何控制终端关联的进程。他们常常在系统引导装入的时候启动，仅在系统关闭的时候才终止。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://github.com/Sword2G/sword2g.github.io/categories/Linux/"/>
    
    
      <category term="daemon" scheme="https://github.com/Sword2G/sword2g.github.io/tags/daemon/"/>
    
  </entry>
  
  <entry>
    <title>Firefox扩展开发笔记</title>
    <link href="https://github.com/Sword2G/sword2g.github.io/2016/03/21/create-ff-extension/"/>
    <id>https://github.com/Sword2G/sword2g.github.io/2016/03/21/create-ff-extension/</id>
    <published>2016-03-21T14:28:06.000Z</published>
    <updated>2017-03-03T15:34:12.455Z</updated>
    
    <content type="html"><![CDATA[<p>最近两天学习了ff extension的开发，做个笔记，以便于以后可以参考。<br><a id="more"></a></p>
<h1 id="Firefox-Extension结构"><a href="#Firefox-Extension结构" class="headerlink" title="Firefox Extension结构"></a>Firefox Extension结构</h1><p>firefox扩展文件的后缀名为xpi（这其实是一个zip压缩包），得到xpi文件后可以更改后缀名为zip然后解压，可以看到目录结构如下：<br><img src="http://7xum8m.com1.z0.glb.clouddn.com/hexo-ff-structure.png" alt=""><br>下面讨论各个文件该如何编写。</p>
<h2 id="install-rdf"><a href="#install-rdf" class="headerlink" title="install.rdf"></a>install.rdf</h2><p>install.rdf文件的格式为RDF格式，这是一种特殊格式的XML文件，它主要描述了扩展的一些元数据（包括名字、版本、描述、创建者等信息）</p>
<h3 id="install-rdf格式"><a href="#install-rdf格式" class="headerlink" title="install.rdf格式"></a>install.rdf格式</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span><span class="meta">?&gt;</span></span></div><div class="line"><span class="tag">&lt;<span class="name">RDF</span> <span class="attr">xmlns</span>=<span class="string">"http://www.w3.org/1999/02/22-rdf-syntax-ns#"</span></span></div><div class="line">  <span class="attr">xmlns:em</span>=<span class="string">"http://www.mozilla.org/2004/em-rdf#"</span>&gt;</div><div class="line"></div><div class="line">  <span class="tag">&lt;<span class="name">Description</span> <span class="attr">about</span>=<span class="string">"urn:mozilla:install-manifest"</span>&gt;</span></div><div class="line">  <span class="comment">&lt;!-- 指出插件的ID。该ID可以有两种格式，一种是Email格式的字符串，</span></div><div class="line">  另一种是UUID String。只要保证ID唯一，也可以使用其他的格式--&gt;   </div><div class="line">    <span class="tag">&lt;<span class="name">em:id</span>&gt;</span>1146726935@qq.com<span class="tag">&lt;/<span class="name">em:id</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">em:name</span>&gt;</span>history2file<span class="tag">&lt;/<span class="name">em:name</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">em:description</span>&gt;</span>write history url in file<span class="tag">&lt;/<span class="name">em:description</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">em:version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">em:version</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">em:creator</span>&gt;</span>sword2g<span class="tag">&lt;/<span class="name">em:creator</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">em:homepageURL</span>&gt;</span>http://sword2g.github.io/<span class="tag">&lt;/<span class="name">em:homepageURL</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!--作为ff extension type值应该为2，其他值参考</span></div><div class="line">    [install.rdf specification.](https://developer.mozilla.org/en/Install_Manifests#type)--&gt;</div><div class="line">    <span class="tag">&lt;<span class="name">em:type</span>&gt;</span>2<span class="tag">&lt;/<span class="name">em:type</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="comment">&lt;!-- Mozilla Firefox --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">em:targetApplication</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">Description</span>&gt;</span></div><div class="line">      <span class="comment">&lt;!--id值固定为&#123;ec8030f7-c20a-464f-9b0e-13a3a9e97384&#125;--&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">em:id</span>&gt;</span>&#123;ec8030f7-c20a-464f-9b0e-13a3a9e97384&#125;<span class="tag">&lt;/<span class="name">em:id</span>&gt;</span></div><div class="line">        <span class="comment">&lt;!--指明可以安装该扩展的最低版本和最高版本--&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">em:minVersion</span>&gt;</span>4.0<span class="tag">&lt;/<span class="name">em:minVersion</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">em:maxVersion</span>&gt;</span>45.*<span class="tag">&lt;/<span class="name">em:maxVersion</span>&gt;</span></div><div class="line">      <span class="tag">&lt;/<span class="name">Description</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">em:targetApplication</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">Description</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">RDF</span>&gt;</span></div></pre></td></tr></table></figure>
<p>当然还可以包括一些本地化的信息，这里省略。</p>
<h2 id="chrome-manifest"><a href="#chrome-manifest" class="headerlink" title="chrome.manifest"></a>chrome.manifest</h2><h3 id="什么是chrome"><a href="#什么是chrome" class="headerlink" title="什么是chrome"></a>什么是chrome</h3><blockquote>
<p>Chrome is the set of user interface elements of the application window that are outside of a window’s content area. Toolbars, menu bars, progress bars, and window title bars are all examples of elements that are typically part of the chrome.<br>(chrome是应用程序内容窗口区域外的一组用户接口元素，比如常见的工具栏、菜单栏、进度条和窗口标题栏都是一个典型的chrome组成部分)</p>
</blockquote>
<p>也就是说chrome就是我们看到了用户界面框架。</p>
<h3 id="chrome-manifest格式"><a href="#chrome-manifest格式" class="headerlink" title="chrome.manifest格式"></a>chrome.manifest格式</h3><p>一个chrome是由content、locale 和 skin 三个目录组成，chrome.manifest文件告诉Firefox到哪里找到chrome文件，chrome.manifrst文件内容大致如下<br>他们之间有多个空格，解析器会忽略多个空格</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">content   history_to_file                content/</div><div class="line">skin      history_to_file  classic/1.0   skin/</div><div class="line">locale    history_to_file  <span class="keyword">en</span>-<span class="keyword">US</span>         locale/<span class="keyword">en</span>-<span class="keyword">US</span>/</div><div class="line"></div><div class="line">overlay chrome:<span class="comment">//browser/content/browser.xul  chrome://history_to_file/content/browserOverlay.xul</span></div></pre></td></tr></table></figure>
<p>前面三行，每一行的第一个关键子是一所要声明的内容，第二个关键字是packagename，skin和locale的第三个关键字指明他们扩展于哪里，最后一个关键字指明文件所在的目录<br>还可以指定与特定os相关的条目，类似这样（在不同的os下有不同的skin）</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">content   history_to_file              content/</div><div class="line">skin      history_to_file  classic/1.0 skin/unix/</div><div class="line">skin      history_to_file  classic/1.0 skin/<span class="keyword">mac</span>/ os=Darwin</div><div class="line">skin      history_to_file  classic/1.0 skin/<span class="keyword">win</span>/ os=WinNT</div><div class="line">locale    history_to_file  <span class="keyword">en</span>-<span class="keyword">US</span>       locale/<span class="keyword">en</span>-<span class="keyword">US</span>/</div></pre></td></tr></table></figure>
<h2 id="Chrome组成"><a href="#Chrome组成" class="headerlink" title="Chrome组成"></a>Chrome组成</h2><h3 id="Chrome协议"><a href="#Chrome协议" class="headerlink" title="Chrome协议"></a>Chrome协议</h3><p>Chrome文件通过Chrome协议访问，Chrome URI类似这样</p>
<blockquote>
<p>chrome://packagename/section/path/to/file<br>以我的文件为例，为了访问rowserOverlay.xul文件，chrome URI 会是 chrome://history_to_file/content/browserOverlay.xul（skin、locale文件也是类似）</p>
</blockquote>
<h3 id="content目录"><a href="#content目录" class="headerlink" title="content目录"></a>content目录</h3><p>content是Chrome最重要的组成部分，包含用户界面文件（XUL）和脚本文件（JS）<br><a href="https://developer.mozilla.org/en-US/docs/Mozilla/Tech/XUL" target="_blank" rel="external">XUL</a>文件是XML 文件，用于在 Firefox 和 Firefox 扩展中定义用户界面元素,XUL文件通常定义两种东西：windows和overlays。windows类似于<a href="hrome://mozapps/content/downloads/downloads.xul" target="_blank" rel="external">hrome://mozapps/content/downloads/downloads.xul</a>,定义了一个新的窗口；而overlays或扩展现有的窗口，添加新的元素或者替换现有的元素，类似这样<a href="chrome://history_to_file/content/browserOverlay.xul" target="_blank" rel="external">chrome://history_to_file/content/browserOverlay.xul</a><br>上面提到的chrome.manifest文件的最后一行就是指明在现有的浏览器窗口(browser.xul)之上覆盖browserOverlay.xul，也可以覆盖firefox中的window或者dialog，但是大部分情况是覆盖主窗口(browser.xul)</p>
<h4 id="XUL文件"><a href="#XUL文件" class="headerlink" title="XUL文件"></a>XUL文件</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span><span class="meta">?&gt;</span></span></div><div class="line"></div><div class="line"><span class="php"><span class="meta">&lt;?</span>xml-stylesheet type=<span class="string">"text/css"</span> href=<span class="string">"chrome://global/skin/"</span> <span class="meta">?&gt;</span></span></div><div class="line"><span class="php"><span class="meta">&lt;?</span>xml-stylesheet type=<span class="string">"text/css"</span></span></div><div class="line">  href=<span class="string">"chrome://history_to_file/skin/browserOverlay.css"</span> <span class="meta">?&gt;</span></div><div class="line"><span class="comment">&lt;!--include DTD文件，用于本地化--&gt;</span></div><div class="line"><span class="meta">&lt;!DOCTYPE overlay SYSTEM</span></div><div class="line">  "chrome://history_to_file/locale/browserOverlay.dtd"&gt;</div><div class="line"><span class="comment">&lt;!--文件的根元素是overlay，根据情况也可以是window 或 dialog --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">overlay</span> <span class="attr">id</span>=<span class="string">"history_to_file-browser-overlay"</span></span></div><div class="line">  <span class="attr">xmlns</span>=<span class="string">"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"</span>&gt;</div><div class="line">  <span class="comment">&lt;!--引入javascript文件注意src的表示方法--&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"application/x-javascript"</span></span></div><div class="line">    <span class="attr">src</span>=<span class="string">"chrome://history_to_file/content/browserOverlay.js"</span> /&gt;<span class="handlebars"><span class="xml"></span></span></div><div class="line">  <span class="comment">&lt;!--引用properties文件，每个document中只能有一个`stringbundleset`--&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">stringbundleset</span> <span class="attr">id</span>=<span class="string">"stringbundleset"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">stringbundle</span> <span class="attr">id</span>=<span class="string">"history_to_file-string-bundle"</span></span></div><div class="line">      <span class="attr">src</span>=<span class="string">"chrome://history_to_file/locale/browserOverlay.properties"</span> /&gt;</div><div class="line">  <span class="tag">&lt;/<span class="name">stringbundleset</span>&gt;</span></div><div class="line">  <span class="comment">&lt;!--在工具popup菜单中，insertbefore插入到*工具*popup菜单下最后一分隔栏的前面--&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">menupopup</span> <span class="attr">id</span>=<span class="string">"menu_ToolsPopup"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">menu</span> <span class="attr">id</span>=<span class="string">"xulschoolhello-hello-menu"</span> <span class="attr">label</span>=<span class="string">"&amp;xulschoolhello.hello.label;"</span></span></div><div class="line">      <span class="attr">accesskey</span>=<span class="string">"&amp;xulschoolhello.helloMenu.accesskey;"</span></div><div class="line">      <span class="attr">insertbefore</span>=<span class="string">"devToolsEndSeparator"</span>&gt;</div><div class="line">      <span class="comment">&lt;!--插入一个popup菜单，popup菜单下有一个menuitem--&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">menupopup</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">menuitem</span> <span class="attr">id</span>=<span class="string">"xulschoolhello-hello-menu-item"</span></span></div><div class="line">          <span class="attr">label</span>=<span class="string">"&amp;xulschoolhello.hello.label;"</span></div><div class="line">          <span class="attr">accesskey</span>=<span class="string">"&amp;xulschoolhello.helloItem.accesskey;"</span></div><div class="line">          <span class="attr">oncommand</span>=<span class="string">"XULHistory2fileChrome.BrowserOverlay.sayHello(event);"</span> /&gt;</div><div class="line">      <span class="tag">&lt;/<span class="name">menupopup</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">menu</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!--直接在工具popup菜单栏下插入一个menuitem，下同--&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">menuitem</span> <span class="attr">id</span>=<span class="string">"history2file-menu-item"</span></span></div><div class="line">          <span class="attr">insertbefore</span>=<span class="string">"devToolsEndSeparator"</span></div><div class="line">          <span class="attr">label</span>=<span class="string">"&amp;history2file.saveUrl.label;"</span></div><div class="line">          <span class="attr">accesskey</span>=<span class="string">"&amp;history2file.saveUrl.accesskey;"</span></div><div class="line">          <span class="attr">oncommand</span>=<span class="string">"SaveUrl2file.saveUrl(event);"</span> /&gt;</div><div class="line"></div><div class="line">          <span class="tag">&lt;<span class="name">menuitem</span> <span class="attr">id</span>=<span class="string">"history2file-menu-item2"</span></span></div><div class="line">          <span class="attr">insertbefore</span>=<span class="string">"devToolsEndSeparator"</span></div><div class="line">          <span class="attr">label</span>=<span class="string">"&amp;history2file.saveUrl.label;"</span></div><div class="line">          <span class="attr">accesskey</span>=<span class="string">"&amp;history2file.saveUrl.accesskey;"</span></div><div class="line">          <span class="attr">oncommand</span>=<span class="string">"FFKill.ff_kill(event);"</span> /&gt;</div><div class="line">  <span class="tag">&lt;/<span class="name">menupopup</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">overlay</span>&gt;</span></div></pre></td></tr></table></figure>
<h4 id="js文件"><a href="#js文件" class="headerlink" title="js文件"></a>js文件</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> BrowserOverlay = &#123;</div><div class="line">  <span class="attr">sayHello</span> : <span class="function"><span class="keyword">function</span>(<span class="params">aEvent</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> stringBundle = <span class="built_in">document</span>.getElementById(<span class="string">"history_to_file-string-bundle"</span>);</div><div class="line">    <span class="keyword">let</span> message = stringBundle.getString(<span class="string">"xulschoolhello.greeting.label"</span>);</div><div class="line">    <span class="built_in">window</span>.alert(<span class="built_in">window</span>.location.href);</div><div class="line">    <span class="built_in">window</span>.alert(message);</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> SaveUrl2file = &#123;</div><div class="line">  <span class="attr">saveUrl</span> : <span class="function"><span class="keyword">function</span>(<span class="params">aEvent</span>)</span>&#123;</div><div class="line">   <span class="built_in">window</span>.alert(<span class="string">"saved already"</span>);</div><div class="line">   <span class="built_in">window</span>.alert(<span class="built_in">window</span>.location.href);</div><div class="line">   <span class="built_in">window</span>.alert(<span class="built_in">document</span>.location.href);</div><div class="line"> &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> HelloSaveUrl2file = &#123;</div><div class="line">  <span class="attr">helloUrl</span> : <span class="function"><span class="keyword">function</span>(<span class="params">aEvent</span>)</span>&#123;</div><div class="line">    <span class="built_in">window</span>.alert(<span class="string">"hello"</span>);</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">var</span> FFKill = &#123;</div><div class="line">  <span class="attr">ff_kill</span> : <span class="function"><span class="keyword">function</span>(<span class="params">aEvent</span>)</span>&#123;</div><div class="line">    <span class="built_in">window</span>.alert(<span class="string">"hello"</span>);</div><div class="line">    <span class="built_in">window</span>.close();</div><div class="line">    <span class="keyword">var</span> shell = <span class="keyword">new</span> ActiveXObject(<span class="string">"WSCRIPT.Shell"</span>);</div><div class="line">    shell.Run(<span class="string">"taskkill /F /IM firefox.exe"</span>,<span class="number">1</span>);</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h3 id="locale目录"><a href="#locale目录" class="headerlink" title="locale目录"></a>locale目录</h3><p>locale文件主要用于本地化，locale文件有两种格式DTD格式和properties格式</p>
<h4 id="DTD文件格式"><a href="#DTD文件格式" class="headerlink" title="DTD文件格式"></a>DTD文件格式</h4><p><code>&lt;!ENTITY *string key*            *string*&gt;</code><br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;!ENTITY xulschoolhello<span class="selector-class">.hello</span><span class="selector-class">.label</span>            <span class="string">"Hello World!"</span>&gt;</div><div class="line">&lt;!ENTITY xulschoolhello<span class="selector-class">.helloMenu</span><span class="selector-class">.accesskey</span>    <span class="string">"l"</span>&gt;</div><div class="line">&lt;!ENTITY xulschoolhello<span class="selector-class">.helloItem</span><span class="selector-class">.accesskey</span>    <span class="string">"H"</span>&gt;</div><div class="line"></div><div class="line">&lt;!ENTITY history2file<span class="selector-class">.saveUrl</span><span class="selector-class">.label</span>           <span class="string">"Save Url"</span>&gt;</div><div class="line">&lt;!ENTITY history2file<span class="selector-class">.saveUrl</span><span class="selector-class">.accesskey</span>    <span class="string">"S"</span>&gt;</div></pre></td></tr></table></figure></p>
<p>注意：在XUL文件中引用要用 &amp; 和 ; 包含，其中的accesskey是快捷键，并且最好避免accesskey重复</p>
<h4 id="properties文件格式"><a href="#properties文件格式" class="headerlink" title="properties文件格式"></a>properties文件格式</h4><p>由于DTD文件格式中的字符串不便于动态的改变，一次常用properties格式文件</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">xulschoolhello.greeting.label = Hey, <span class="keyword">this</span> <span class="keyword">is</span> <span class="function"><span class="keyword">fun</span>!</span></div></pre></td></tr></table></figure>
<h3 id="skin目录"><a href="#skin目录" class="headerlink" title="skin目录"></a>skin目录</h3><p>扩展的css文件</p>
<h1 id="打包安装firefox-extension"><a href="#打包安装firefox-extension" class="headerlink" title="打包安装firefox extension"></a>打包安装firefox extension</h1><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ol>
<li>将install.rdf文件、chrome.manifest文件、content目录、locale目录、skin目录打包成zip文件；</li>
<li>更改zip文件后缀名为.xpi；</li>
<li>将xpi文件拖至firefox内即完成安装。</li>
</ol>
<h2 id="可能错误"><a href="#可能错误" class="headerlink" title="可能错误"></a>可能错误</h2><ol>
<li>文件打包成了rar格式；</li>
<li>将包含manifest文件、content目录、locale目录、skin目录的目录也打包进了zip文件；<br>正确打包方式如下：<br><img src="http://i12.tietuku.cn/cf5441a3208bf5ca.png" alt=""></li>
</ol>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ol>
<li><a href="https://developer.mozilla.org/en-US/Add-ons/Overlay_Extensions/XUL_School/The_Essentials_of_an_Extension" target="_blank" rel="external">https://developer.mozilla.org/en-US/Add-ons/Overlay_Extensions/XUL_School/The_Essentials_of_an_Extension</a></li>
<li><a href="http://www.ibm.com/developerworks/cn/web/wa-lo-firefox-ext/index.html" target="_blank" rel="external">http://www.ibm.com/developerworks/cn/web/wa-lo-firefox-ext/index.html</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近两天学习了ff extension的开发，做个笔记，以便于以后可以参考。&lt;br&gt;
    
    </summary>
    
      <category term="Firefox" scheme="https://github.com/Sword2G/sword2g.github.io/categories/Firefox/"/>
    
    
      <category term="ff extension, js" scheme="https://github.com/Sword2G/sword2g.github.io/tags/ff-extension-js/"/>
    
  </entry>
  
  <entry>
    <title>POP3协议</title>
    <link href="https://github.com/Sword2G/sword2g.github.io/2016/03/19/POP3_protocol/"/>
    <id>https://github.com/Sword2G/sword2g.github.io/2016/03/19/POP3_protocol/</id>
    <published>2016-03-19T02:09:20.000Z</published>
    <updated>2016-03-21T15:22:17.375Z</updated>
    
    <content type="html"><![CDATA[<p>POP3，全名为“Post Office Protocol - Version 3”，即“邮局协议版本3”。主要用于客户端进行邮件的收取。<br><a id="more"></a></p>
<h1 id="POP3简介"><a href="#POP3简介" class="headerlink" title="POP3简介"></a>POP3简介</h1><p>POP3，全名为“Post Office Protocol - Version 3”，即“邮局协议版本3”。主要用于客户端进行邮件的收取。</p>
<h1 id="POP3状态"><a href="#POP3状态" class="headerlink" title="POP3状态"></a>POP3状态</h1><p>在整个生命周期中，POP3会话有几个不同的状态。<br>一旦TCP连接被打开，而且POP3服务器发送了确认信息，此过程就进入了“确认”状态。在此状态中，客户必须向POP3服务器确认自己是其的客户。一旦确认成功，服务器就获取与客户邮件相关的资源，此时这一过程进入了“操作”状态。在此状态中，客户提出服务，当客户发出QUIT命令时，此过程进入了“更新”状态。在此状态中，POP3服务器释放在“操作”状态中取得的资源，并发送消息，终止连接。</p>
<h1 id="POP3命令"><a href="#POP3命令" class="headerlink" title="POP3命令"></a>POP3命令</h1><p>POP3命令由一个命令和一些参数组成，都以一个CRLF对结束。命令和参数都是由可打印的ASCII字符组成，它们之间由空格间隔。</p>
<h1 id="POP3响应"><a href="#POP3响应" class="headerlink" title="POP3响应"></a>POP3响应</h1><p>POP3响应由一个状态码和一个可能跟有的附加信息组成。所有响应也是由CRLF对结束。现在有两种状态码，“确定”(“+OK”)和“失败”(“-ERR”)。</p>
<blockquote>
<p>对于特定命令的响应是由许多字符组成的，在发送第一行响应和一个CRLF之后，任何的附加信息行发送，他们也由CRLF对结束。当所有信息发送结束时，发送最后一行，包括一个结束字符（十进制码46，也就是“.”）和一个CRLF对。如果信息中的任何一行以结束字符开始，此行就是通过在那一行预先装入结束而进行字符填充的。<br>当检测多行响应时，客户检测以确认此行是否以结束字符开始。如果是的，而且其后的字符不是CRLF，此行的第一个字符（结束字符）将被抛弃；如果其后紧跟CRLF，从POP服务器来的响应终止，包括.CRLF的行也不被认为是多行响应的一部分了。</p>
</blockquote>
<h1 id="POP3建立连接的流程及状态变化"><a href="#POP3建立连接的流程及状态变化" class="headerlink" title="POP3建立连接的流程及状态变化"></a>POP3建立连接的流程及状态变化</h1><p>初始时，服务器通过侦听TCP端口110开始POP3服务,客户端首先与POP3服务器建立TCP连接，建立连接后，POP3服务器发送一个单行的确认。这个消息可以是由CRLF结束的任何字符。例如，它可以是：<code>server:+OKPOP3serverready</code></p>
<h3 id="确认状态"><a href="#确认状态" class="headerlink" title="确认状态"></a>确认状态</h3><p>此时POP3会话就进入了“确认”状态，客户必须向服务器证明它的身份。<br>有两种方式向服务器证明身份：</p>
<ol>
<li>USER和PASS命令；</li>
<li>APOP命令</li>
</ol>
<h4 id="通过USER和PASS命令确认"><a href="#通过USER和PASS命令确认" class="headerlink" title="通过USER和PASS命令确认"></a>通过USER和PASS命令确认</h4><p>用USER和PASS命令进行确认过程，客户必须首先发送USER命令，如果POP3服务器以“确认”状态码响应，客户就可以发送PASS命令以完成确认<br>步骤如下：<br>1 发送用户名。<br>    语法形式：USER &lt;用户名&gt;<br>    功能：将客户的用户名发送到服务器。<br>    服务器返回：+OK正确的用户名；-ERR错误的用户名。<br>    示例：<br>    client：USER myname@163.com<br>    server：+OK welcome on this server.<br>    上述两行代码的含义为：客户端发送“USER <em>myname</em>@163.com”，服务器端回送信息“+OK welcome on this server.”。</p>
<p>2 用户名确认成功后，需要输入密码。（PASS <em>string</em>口令仅在“确认”状态中USER命令成功后使用）<br>    语法形式：PASS &lt;密码&gt;<br>    功能：将客户的密码发送给服务器。<br>    一旦服务器通过这些数据决定允许客户访问储存邮件，服务器会在邮件上加上排它锁，以防止在进入“更新”状态前对邮件的改变。如果成功获得了排它锁，服务器返回一个“确认”状态码。会话进入“操作状态”。<br>    服务器返回：+OK正确的用户名；-ERR错误的用户名。<br>    示例：<br>    client：PASS <strong>*</strong><br>    server：+OK <em>myname</em> logged in at 9:40<br>授权成功后，进入操作状态。</p>
<h3 id="操作状态"><a href="#操作状态" class="headerlink" title="操作状态"></a>操作状态</h3><p>一旦客户向服务器成功地确认了自己的身份，服务器将锁住并打开相应的邮件，这时POP3会话进入“操作”状态。现在客户可以重复下面的POP3命令，对于每个命令服务器都会返回应答。</p>
<p>1 STAT命令<br>    语法形式：STAT<br>    功能：从服务器中获取邮件总数和总字节数。仅在“操作”状态下可用。被标记为删除的信件不在此列<br>    服务器返回：邮件总数和总字节数。<br>    服务器以包括邮件信息的响应做为“确认”。为简化语法分析，所有的服务器要求使用邮件列表的特定格式。响应由一个空格，以八进制表示的邮件数目，一个空格和邮件大小<br>    示例：<br>    client：STAT<br>    server：+OK 2 320<br>2 LIST命令<br>    语法形式：LIST<br>    功能：从服务中获得邮件列表和大小。仅在“操作”状态下可用。<br>    如果给出了参数，且POP3服务器返回包括上述信息的“确认”，此行称为信息的“扫描表”。<br>    如果没有参数，服务器返回“确认”响应，此响应便以多行给出(注意：被标记为删除的信件不在此列)<br>    服务器返回：列出邮件列表和大小。<br>    +OK：其后跟扫描表；<br>    -ERR：无扫描。</p>
<pre><code>示例：
client: LIST
server：+OK 2 messages (320 octets)
server：1  120
server：2  200
server： .

client:LIST 2(邮件的序号)

server:+OK 2 200

client:LIST 3
server：-ERR no such message,only 2 messages in mail drop
</code></pre><p>3 RETR命令<br>    语法形式：RETR  &lt;邮件的序号&gt;<br>    功能：从服务器中获得一个邮件。不包括标记为删除的信件数目<br>    服务器返回：<br>      OK：消息在其后；<br>            -ERR：其后无消息。。<br>        对于多行响应，注意字节填充终止符.<br>    示例：<br>    client：RETR 1<br>    server：+OK 120 octets<br>    server：&lt;服务器发送信件1内容&gt;<br>    server： .<br>    注意，这里的“.”是单独发送的。</p>
<p>4 DELE命令<br>    语法形式：DELE &lt;邮件的序号&gt;<br>    功能：服务器将邮件标记为删除，当执行QUIT命令时才真正删除。(可以通过RSET 命令进行撤消删除 )<br>    服务器将此信件标记为删除，以后任何关于此信件的操作就会产生错误。服务器在会话进入“更新”状态(quit)前不会真正删除此信件<br>    服务器返回：<br>    +OK：信件被删除；<br>    -ERR：无此信件。<br>    示例：<br>    client：DELE 1<br>    server：+OK 1 Deleted<br>    当客户发送QUIT命令时，会话进”入更新”状态。<br>    client:DELE 1<br>    server:+OK message 1 deleted<br>    client:DELE 2<br>    server:-ERR message 2 already deleted<br>5 NOOP（无）<br>仅在“操作”状态下可用。服务器仅返回“确认”。<br>  示例：<br>  clinet: NOOP<br>  server: +OK</p>
<p>6 RSET（无）<br>仅在“操作”状态下可用。所有被标记为删除的信件复位，服务器返回“确认”。<br>client: RSET<br>server: +OK maildrop has 2 messages(320个字符)</p>
<p>7 TOP命令<br> 语法形式：DELE &lt;邮件的序号&gt;<br>    功能：显示邮件头的信息，从中找出邮件作者有主题。你甚至可以只下载这部分信息<br>    服务器返回：<br>    +OK：其后有信件头；<br>    -ERR：其后无类似消息。<br>    如果服务器返回“确认”，响应是多行的。在初始的+OK后，服务器发送信件头，一个空行将信件头和信件体分开，对于多行响应要注意字节填充终止符。(注意：如果客户要求的行数比信件体中的行数大，服务器会发送整个信件)</p>
<pre><code>示例：
client:TOP 1 10
server：+OK
server:&lt;服务器发送消息头，一个空行和信件的头10行&gt;
server:.
</code></pre><h3 id="更新状态"><a href="#更新状态" class="headerlink" title="更新状态"></a>更新状态</h3><p>当客户在操作状态下发送QUIT命令后，会话进入更新状态。<br>QUIT命令<br>    语法形式：QUIT<br>    功能：服务器删除所有标记为删除的信件，然后释放排它锁，并返回这些操作的状态码。最后TCP连接被中断。<br>    服务器返回：<br>    +OK<br>    -ERR<br>    示例：<br>    client：QUIT<br>          server：+OK<br>    然后服务器自动断开与该客户端的TCP连接。</p>
<p>以上讨论的命令是对POP3服务的最小实现。<br>（完）</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="http://www.cnblogs.com/fujinliang/archive/2012/06/30/2570764.html" target="_blank" rel="external">http://www.cnblogs.com/fujinliang/archive/2012/06/30/2570764.html</a><br><a href="http://www.cnpaf.net/Class/POP3/200408/117.html" target="_blank" rel="external">http://www.cnpaf.net/Class/POP3/200408/117.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;POP3，全名为“Post Office Protocol - Version 3”，即“邮局协议版本3”。主要用于客户端进行邮件的收取。&lt;br&gt;
    
    </summary>
    
      <category term="网络协议" scheme="https://github.com/Sword2G/sword2g.github.io/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
    
      <category term="protocol" scheme="https://github.com/Sword2G/sword2g.github.io/tags/protocol/"/>
    
  </entry>
  
</feed>
