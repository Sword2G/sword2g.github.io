<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>No root,no fruit</title>
  <subtitle>just do it！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://github.com/Sword2G/sword2g.github.io/"/>
  <updated>2017-03-25T16:05:27.203Z</updated>
  <id>https://github.com/Sword2G/sword2g.github.io/</id>
  
  <author>
    <name>sword2g</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Nginx 请求体读取流程</title>
    <link href="https://github.com/Sword2G/sword2g.github.io/2016/09/27/nginx-request-read-flowchart/"/>
    <id>https://github.com/Sword2G/sword2g.github.io/2016/09/27/nginx-request-read-flowchart/</id>
    <published>2016-09-27T02:14:57.000Z</published>
    <updated>2017-03-25T16:05:27.203Z</updated>
    
    <content type="html"><![CDATA[<p>Nginx 请求体读取流程，转载改编自<a href="http://blog.csdn.net/fengmo_q/article/details/8140663" target="_blank" rel="external">http://blog.csdn.net/fengmo_q/article/details/8140663</a><br><a id="more"></a></p>
<h1 id="请求体读取流程"><a href="#请求体读取流程" class="headerlink" title="请求体读取流程"></a>请求体读取流程</h1><p>nginx核心本身不会主动读取请求体，这个工作是交给请求处理阶段的模块来做。</p>
<p>nginx核心提供了ngx_http_read_client_request_body()接口来读取请求体，另外还提供了一个丢弃请求体的接口-ngx_http_discard_request_body()，在请求执行的各个阶段中，任何一个阶段的模块如果对请求体感兴趣或者希望丢掉客户端发过来的请求体，可以分别调用这两个接口来完成。</p>
<p>由于内存的限制，ngx_http_read_client_request_body()接口读取的请求体会部分或者全部写入一个临时文件中，根据请求体的大小以及相关的指令配置，请求体可能完整放置在一块连续内存中，也可能分别放置在两块不同内存中，还可能全部存在一个临时文件中，最后还可能一部分在内存，剩余部分在临时文件中。下面先介绍一下和这些不同存储行为相关的指令：</p>
<ul>
<li>client_body_buffer_size：设置缓存请求体的buffer大小，默认为系统页大小的2倍，当请求体的大小超过此大小时，nginx会把请求体写入到临时文件中。可以根据业务需求设置合适的大小，尽量避免磁盘io操作；</li>
<li>client_body_in_single_buffer：指示是否将请求体完整的存储在一块连续的内存中，默认为off，如果此指令被设置为on，则nginx会保证请求体在不大于client_body_buffer_size设置的值时，被存放在一块连续的内存中，但超过大小时会被整个写入一个临时文件；</li>
<li>client_body_in_file_only：设置是否总是将请求体保存在临时文件中，默认为off，当此指定被设置为on时，即使客户端显示指示了请求体长度为0时，nginx还是会为请求创建一个临时文件。</li>
</ul>
<h2 id="ngx-http-read-client-request-body"><a href="#ngx-http-read-client-request-body" class="headerlink" title="ngx_http_read_client_request_body"></a>ngx_http_read_client_request_body</h2><p>ngx_http_read_client_request_body()接口定义如下<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">ngx_http_read_client_request_body</span><span class="params">(ngx_http_request_t *r,  ngx_http_client_body_handler_pt post_handler)</span></span></div></pre></td></tr></table></figure></p>
<p>接口有2个参数，第1个为指向请求结构的指针，第2个为一个函数指针，当请求体读完时，它会被调用。</p>
<p>ngx_http_read_client_request_body 会检查该请求的请求体是否已经被读取或者被丢弃了，如果是的话，则直接调用回调函数并返回NGX_OK，这里实际上是为子请求检查，子请求是nginx中的一个概念，nginx中可以在当前请求中发起另外一个或多个全新的子请求来访问其他的location，关于子请求的具体介绍会在后面的章节作详细分析，一般而言子请求不需要自己去读取请求体。</p>
<p>接着调用ngx_http_test_expect()检查客户端是否发送了Expect: 100-continue头，是的话则给客户端回复”HTTP/1.1 100 Continue”，根据http 1.1协议，客户端可以发送一个Expect头来向服务器表明期望发送请求体，服务器如果允许客户端发送请求体，则会回复”HTTP/1.1 100 Continue”，客户端收到时，才会开始发送请求体。</p>
<p>接下来，函数删掉了读事件上的定时器，因为这时本身就不需要请求体，所以也无所谓客户端发送的快还是慢了，当然后面还会将到，当nginx已经处理完该请求但客户端还没有发送完无用的请求体时，nginx会在读事件上再挂上定时器。</p>
<p>接着继续为接收请求体做准备工作，分配一个ngx_http_request_body_t结构，并保存在r-&gt;request_body，这个结构用来保存请求体读取过程用到的缓存引用，临时文件引用，剩余请求体大小等信息。</p>
<p>ngx_http_request_body_t 定义如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;  </div><div class="line">    <span class="keyword">ngx_temp_file_t</span>                  *temp_file;  </div><div class="line">    <span class="keyword">ngx_chain_t</span>                      *bufs;  </div><div class="line">    <span class="keyword">ngx_buf_t</span>                        *buf;  </div><div class="line">    <span class="keyword">off_t</span>                             rest;  </div><div class="line">    <span class="keyword">ngx_chain_t</span>                      *to_write;  </div><div class="line">    ngx_http_client_body_handler_pt   post_handler;  </div><div class="line">&#125; <span class="keyword">ngx_http_request_body_t</span>;</div></pre></td></tr></table></figure></p>
<p>做好准备工作之后，函数开始检查请求是否带有content_length头，如果没有该头或者客户端发送了一个值为0的content_length头，表明没有请求体，这时直接调用回调函数并返回NGX_OK即可。当然如果client_body_in_file_only指令被设置为on，且content_length为0时，该函数在调用回调函数之前，会创建一个空的临时文件。</p>
<p>如果客户端请求确实表明了要发送请求体，该函数会先检查是否在读取请求头时预读了请求体，这里的检查是通过判断保存请求头的缓存(r-&gt;header_in)中是否还有未处理的数据。</p>
<ul>
<li>如果有预读数据，则分配一个ngx_buf_t结构，并将r-&gt;header_in中的预读数据保存在其中，并且如果r-&gt;header_in中还有剩余空间，并且能够容下剩余未读取的请求体，这些空间将被继续使用，而不用分配新的缓存，当然甚至如果请求体已经被整个预读了，则不需要继续处理了，此时调用回调函数后返回。</li>
<li>如果没有预读数据或者预读不完整，该函数会分配一块新的内存（除非r-&gt;header_in还有足够的剩余空间），另外如果request_body_in_single_buf指令被设置为no，则预读的数据会被拷贝进新开辟的内存块中，真正读取请求体的操作是在ngx_http_do_read_client_request_body()函数，该函数循环的读取请求体并保存在缓存中，如果缓存被写满了，其中的数据会被清空并写回到临时文件中。当然这里有可能不能一次将数据读到，该函数会挂载读事件并设置读事件handler为ngx_http_read_client_request_body_handler，另外nginx核心对两次请求体的读事件之间也做了超时设置，client_body_timeout指令可以设置这个超时时间，默认为60s，如果下次读事件超时了，nginx会返回408给客户端。</li>
</ul>
<p>最终读完请求体后，ngx_http_do_read_client_request_body()会根据配置，将请求体调整到预期的位置(内存或者文件)，所有情况下请求体都可以从r-&gt;request_body的bufs链表得到，该链表最多可能有2个节点，每个节点为一个buffer，但是这个buffer的内容可能是保存在内存中，也可能是保存在磁盘文件中。</p>
<h2 id="ngx-http-discard-request-body"><a href="#ngx-http-discard-request-body" class="headerlink" title="ngx_http_discard_request_body"></a>ngx_http_discard_request_body</h2><p>一个模块想要主动的丢弃客户端发过的请求体，可以调用nginx核心提供的ngx_http_discard_request_body()接口，主动丢弃的原因可能有很多种，如模块的业务逻辑压根不需要请求体 ，客户端发送了过大的请求体，另外为了兼容http1.1协议的pipeline请求，模块有义务主动丢弃不需要的请求体。总之为了保持良好的客户端兼容性，nginx必须主动丢弃无用的请求体。函数定义如下：<br><figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line">ngx_http_discard_request_body(ngx_http_request_t *r)  </div><div class="line">&#123;  </div><div class="line">    ssize_t       size;  </div><div class="line">    ngx_event_t  *rev;  </div><div class="line">  </div><div class="line">    <span class="function"><span class="title">if</span> (r != r-&gt;</span><span class="function"><span class="title">main</span> || r-&gt;</span>discard_body) &#123;  </div><div class="line">        return NGX_OK;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="keyword">if</span> (ngx_http_test_expect(r) != NGX_OK) &#123;  </div><div class="line">        return NGX_HTTP_INTERNAL_SERVER_ERROR;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="function"><span class="title">rev</span> = r-&gt;</span><span class="function"><span class="title">connection</span>-&gt;</span>read;  </div><div class="line">  </div><div class="line">    <span class="function"><span class="title">ngx_log_debug0</span>(NGX_LOG_DEBUG_HTTP, rev-&gt;</span><span class="built_in">log</span>, <span class="number">0</span>, <span class="string">"http set discard body"</span>);  </div><div class="line">  </div><div class="line">    <span class="function"><span class="title">if</span> (rev-&gt;</span>timer_set) &#123;  </div><div class="line">        ngx_del_timer(rev);  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="function"><span class="title">if</span> (r-&gt;</span><span class="function"><span class="title">headers_in</span>.content_length_n &lt;= 0 || r-&gt;</span>request_body) &#123;  </div><div class="line">        return NGX_OK;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="function"><span class="title">size</span> = r-&gt;</span><span class="function"><span class="title">header_in</span>-&gt;</span><span class="function"><span class="title">last</span> - r-&gt;</span><span class="function"><span class="title">header_in</span>-&gt;</span>pos;  </div><div class="line">  </div><div class="line">    <span class="keyword">if</span> (size) &#123;  </div><div class="line">        <span class="function"><span class="title">if</span> (r-&gt;</span>headers_in.content_length_n &gt; size) &#123;  </div><div class="line">            <span class="function"><span class="title">r</span>-&gt;</span><span class="function"><span class="title">header_in</span>-&gt;</span>pos += size;  </div><div class="line">            <span class="function"><span class="title">r</span>-&gt;</span>headers_in.content_length_n -= size;  </div><div class="line">  </div><div class="line">        &#125; <span class="keyword">else</span> &#123;  </div><div class="line">            <span class="function"><span class="title">r</span>-&gt;</span><span class="function"><span class="title">header_in</span>-&gt;</span><span class="function"><span class="title">pos</span> += (size_t) r-&gt;</span>headers_in.content_length_n;  </div><div class="line">            <span class="function"><span class="title">r</span>-&gt;</span>headers_in.content_length_n = <span class="number">0</span>;  </div><div class="line">            return NGX_OK;  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="function"><span class="title">r</span>-&gt;</span>read_event_handler = ngx_http_discarded_request_body_handler;  </div><div class="line">  </div><div class="line">    <span class="keyword">if</span> (ngx_handle_read_event(rev, <span class="number">0</span>) != NGX_OK) &#123;  </div><div class="line">        return NGX_HTTP_INTERNAL_SERVER_ERROR;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="keyword">if</span> (ngx_http_read_discarded_request_body(r) == NGX_OK) &#123;  </div><div class="line">        <span class="function"><span class="title">r</span>-&gt;</span>lingering_close = <span class="number">0</span>;  </div><div class="line">  </div><div class="line">    &#125; <span class="keyword">else</span> &#123;  </div><div class="line">        <span class="function"><span class="title">r</span>-&gt;</span>count++;  </div><div class="line">        <span class="function"><span class="title">r</span>-&gt;</span>discard_body = <span class="number">1</span>;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    return NGX_OK;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>函数的开始同样先判断了不需要再做处理的情况：子请求不需要处理，已经调用过此函数的也不需要再处理。接着调用ngx_http_test_expect() 处理http1.1 expect的情况，根据http1.1的expect机制，如果客户端发送了expect头，而服务端不希望接收请求体时，必须返回417(Expectation Failed)错误。nginx并没有这样做，它只是简单的让客户端把请求体发送过来，然后丢弃掉。</p>
<p>函数同样还会检查请求头中的content-length头，客户端如果打算发送请求体，就必须发送content-length头，同时还会查看其他地方是不是已经读取了请求体。如果确实有待处理的请求体，函数接着检查请求头buffer中预读的数据，预读的数据会直接被丢掉，当然如果请求体已经被全部预读，函数就直接返回了。</p>
<p>如果还有剩余的请求体未处理，该函数调用ngx_handle_read_event()在事件处理机制中挂载好读事件，并把读事件的处理函数设置为ngx_http_discarded_request_body_handler。<br>做好这些准备之后，该函数最后调用ngx_http_read_discarded_request_body()</p>
<p>ngx_http_read_discarded_request_body接口读取客户端过来的请求体并丢弃。如果客户端并没有一次将请求体发过来，函数会返回，剩余的数据等到下一次读事件过来时，交给ngx_http_discarded_request_body_handler()来处理，这时，请求的discard_body将被设置为1用来标识这种情况。另外请求的引用数(count)也被加1，这样做的目的是客户端可能在nginx处理完请求之后仍未完整发送待发送的请求体，增加引用是防止nginx核心在处理完请求后直接释放了请求的相关资源。<br>ngx_http_read_discarded_request_body函数非常简单，它循环的从链接中读取数据并丢弃，直到读完接收缓冲区的所有数据，如果请求体已经被读完了，该函数会设置读事件的处理函数为ngx_http_block_reading，这个函数仅仅删除水平触发的读事件，防止同一事件不断被触发。</p>
<h3 id="ngx-http-discarded-request-body-handler"><a href="#ngx-http-discarded-request-body-handler" class="headerlink" title="ngx_http_discarded_request_body_handler"></a>ngx_http_discarded_request_body_handler</h3><p>读事件的处理函数ngx_http_discarded_request_body_handler，这个函数每次读事件来时会被调用，函数定义如下：</p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line">ngx_http_discarded_request_body_handler(ngx_http_request_t *r)  </div><div class="line">&#123;  </div><div class="line">    ...  </div><div class="line">  </div><div class="line">    <span class="function"><span class="title">c</span> = r-&gt;</span>connection;  </div><div class="line">    <span class="function"><span class="title">rev</span> = c-&gt;</span>read;  </div><div class="line">  </div><div class="line">    <span class="function"><span class="title">if</span> (rev-&gt;</span>timedout) &#123;  </div><div class="line">        <span class="function"><span class="title">c</span>-&gt;</span>timedout = <span class="number">1</span>;  </div><div class="line">        <span class="function"><span class="title">c</span>-&gt;</span>error = <span class="number">1</span>;  </div><div class="line">        ngx_http_finalize_request(r, NGX_ERROR);  </div><div class="line">        return;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="function"><span class="title">if</span> (r-&gt;</span>lingering_time) &#123;  </div><div class="line">        <span class="function"><span class="title">timer</span> = (ngx_msec_t) (r-&gt;</span>lingering_time - ngx_time());  </div><div class="line">  </div><div class="line">        <span class="keyword">if</span> (timer &lt;= <span class="number">0</span>) &#123;  </div><div class="line">            <span class="function"><span class="title">r</span>-&gt;</span>discard_body = <span class="number">0</span>;  </div><div class="line">            <span class="function"><span class="title">r</span>-&gt;</span>lingering_close = <span class="number">0</span>;  </div><div class="line">            ngx_http_finalize_request(r, NGX_ERROR);  </div><div class="line">            return;  </div><div class="line">        &#125;  </div><div class="line">  </div><div class="line">    &#125; <span class="keyword">else</span> &#123;  </div><div class="line">        timer = <span class="number">0</span>;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    rc = ngx_http_read_discarded_request_body(r);  </div><div class="line">  </div><div class="line">    <span class="keyword">if</span> (rc == NGX_OK) &#123;  </div><div class="line">        <span class="function"><span class="title">r</span>-&gt;</span>discard_body = <span class="number">0</span>;  </div><div class="line">        <span class="function"><span class="title">r</span>-&gt;</span>lingering_close = <span class="number">0</span>;  </div><div class="line">        ngx_http_finalize_request(r, NGX_DONE);  </div><div class="line">        return;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="comment">/* rc == NGX_AGAIN */</span>  </div><div class="line">  </div><div class="line">    <span class="keyword">if</span> (ngx_handle_read_event(rev, <span class="number">0</span>) != NGX_OK) &#123;  </div><div class="line">        <span class="function"><span class="title">c</span>-&gt;</span>error = <span class="number">1</span>;  </div><div class="line">        ngx_http_finalize_request(r, NGX_ERROR);  </div><div class="line">        return;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="keyword">if</span> (timer) &#123;  </div><div class="line">  </div><div class="line">        clcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module);  </div><div class="line">  </div><div class="line">        timer *= <span class="number">1000</span>;  </div><div class="line">  </div><div class="line">        <span class="function"><span class="title">if</span> (timer &gt; clcf-&gt;</span>lingering_timeout) &#123;  </div><div class="line">            <span class="function"><span class="title">timer</span> = clcf-&gt;</span>lingering_timeout;  </div><div class="line">        &#125;  </div><div class="line">  </div><div class="line">        ngx_add_timer(rev, timer);  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>函数一开始就处理了读事件超时的情况，之前说到在ngx_http_discard_request_body()函数中已经删除了读事件的定时器，那么什么时候会设置定时器呢？答案就是在nginx已经处理完该请求，但是又没有完全将该请求的请求体丢弃的时候（客户端可能还没有发送过来），在ngx_http_finalize_connection()函数中，如果检查到还有未丢弃的请求体时，nginx会添加一个读事件定时器，它的时长为lingering_timeout指令所指定，默认为5秒，不过这个时间仅仅两次读事件之间的超时时间，等待请求体的总时长为lingering_time指令所指定，默认为30秒。这种情况中，该函数如果检测到超时事件则直接返回并断开连接。同样，还需要控制整个丢弃请求体的时长不能超过lingering_time设置的时间，如果超过了最大时长，也会直接返回并断开连接。</p>
<p>如果读事件发生在请求处理完之前，则不用处理超时事件，也不用设置定时器，函数只是简单的调用ngx_http_read_discarded_request_body()来读取并丢弃数据。读取完请求头后，nginx就进入请求的处理阶段。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://blog.csdn.net/fengmo_q/article/details/8161818" target="_blank" rel="external">http://blog.csdn.net/fengmo_q/article/details/8161818</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Nginx 请求体读取流程，转载改编自&lt;a href=&quot;http://blog.csdn.net/fengmo_q/article/details/8140663&quot;&gt;http://blog.csdn.net/fengmo_q/article/details/8140663&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://github.com/Sword2G/sword2g.github.io/categories/Linux/"/>
    
    
      <category term="Nginx" scheme="https://github.com/Sword2G/sword2g.github.io/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>Nginx 请求读取流程</title>
    <link href="https://github.com/Sword2G/sword2g.github.io/2016/09/20/nginx-flowchart/"/>
    <id>https://github.com/Sword2G/sword2g.github.io/2016/09/20/nginx-flowchart/</id>
    <published>2016-09-20T07:45:25.000Z</published>
    <updated>2017-03-25T15:39:45.169Z</updated>
    
    <content type="html"><![CDATA[<p>Nginx 请求读取流程，转载改编自<a href="http://blog.csdn.net/fengmo_q/article/details/7736695" target="_blank" rel="external">http://blog.csdn.net/fengmo_q/article/details/7736695</a><br><a id="more"></a></p>
<h1 id="读取流程"><a href="#读取流程" class="headerlink" title="读取流程"></a>读取流程</h1><p>nginx 在init process阶段的ngx_event_process_init函数中会为每一个监听套接字分配一个连接结构（ngx_connection_t），并将该连接结构的读事件成员（read-&gt;handler）的事件处理函数设置为ngx_event_accept。如果没有使用accept互斥锁，在这个函数中会将该读事件挂载到nginx的事件处理模型上（poll或者epoll等），否则，会等到init process阶段结束，在工作进程的事件处理循环中，由获取accept_mutex的worker进程将该读事件挂载到nginx的事件处理模型。当一个工作进程在某个时刻将监听事件挂载上事件处理模型之后，nginx就可以正式的接收并处理客户端过来的请求了。当客户端发起新连接时，域名解析服务器将该域名解析到一台由nginx监听的服务器上，nginx的事件处理模型接收到这个读事件之后，会速度交由之前注册好的事件处理函数ngx_event_accept来处理。</p>
<p>在ngx_event_accept函数中，nginx调用accept函数，从已连接队列得到一个连接以及对应的套接字，接着分配一个连接结构（ngx_connection_t），并将新得到的套接字保存在该连接结构中，然后调用ngx_listening_t-&gt;handler，即ngx_http_init_connection。</p>
<p>ngx_http_init_connection 将当前连接的读事件revent-&gt;handler设置为ngx_http_init_request，此时如果该连接上已经有数据过来（设置了deferred accept)，则会直接调用ngx_http_init_request函数来处理该请求，反之则设置一个定时器并在事件处理模型上挂载一个读事件，等待数据到来或者超时。当然这里不管是已经有数据到来，或者需要等待数据到来，又或者等待超时，最终都会进入读事件的处理函数-ngx_http_init_request。</p>
<p>ngx_http_init_connection函数最重要的工作是初始化读写事件的处理函数：将该连接结构的写事件的处理函数设置为ngx_http_empty_handler，这个事件处理函数不会做任何操作，实际上nginx默认连接第一次可写，不会挂载写事件，如果有数据需要发送，nginx会直接写到这个连接，只有在发生一次写不完的情况下，才会挂载写事件到事件模型上，并设置真正的写事件处理函数，这里后面的章节还会做详细介绍；读事件的处理函数设置为ngx_http_init_request，此时如果该连接上已经有数据过来（设置了deferred accept)，则会直接调用ngx_http_init_request函数来处理该请求，反之则设置一个定时器并在事件处理模型上挂载一个读事件，等待数据到来或者超时。当然这里不管是已经有数据到来，或者需要等待数据到来，又或者等待超时，最终都会进入读事件的处理函数-ngx_http_init_request。</p>
<p>ngx_http_init_request函数主要工作即是初始化请求，由于它是一个事件处理函数，它只有唯一一个ngx_event_t *类型的参数，ngx_event_t 结构在nginx中表示一个事件，事件处理的上下文类似于一个中断处理的上下文，为了在这个上下文得到相关的信息，nginx中一般会将连接结构的引用保存在事件结构的data字段，请求结构的引用则保存在连接结构的data字段，这样在事件处理函数中可以方便的得到对应的连接结构和请求结构。<br>函数首先判断该事件是否是超时事件，如果是的话直接关闭连接并返回；<br>反之则是指之前accept的连接上有请求过来需要处理，ngx_http_init_request函数首先在连接的内存池中为该请求分配一个ngx_http_request_t结构，这个结构将用来保存该请求所有的信息。</p>
<p>然后nginx根据该请求的接收端口和地址找到一个默认虚拟服务器配置（listen指令的default_server属性用来标识一个默认虚拟服务器，否则监听在相同端口和地址的多个虚拟服务器，其中第一个定义的则为默认），因为在nginx配置文件中可以设置多个监听在不同端口和地址的虚拟服务器（每个server块对应一个虚拟服务器），另外还根据域名（server_name指令可以配置该虚拟服务器对应的域名）来区分监听在相同端口和地址的虚拟服务器，每个虚拟服务器可以拥有不同的配置内容，而这些配置内容决定了nginx在接收到一个请求之后如何处理该请求。找到之后，相应的配置被保存在该请求对应的ngx_http_request_t结构中。注意这里根据端口和地址找到的默认配置只是临时使用一下，最终nginx会根据域名找到真正的虚拟服务器配置。该函数还会做如下事情：</p>
<p>1 将连接的读事件的处理函数设置为ngx_http_process_request_line函数，这个函数用来处理请求行<br>2 为这个请求分配一个缓冲区用来保存它的请求头，地址保存在header_in字段<br>3 为这个请求分配一个内存池，后续所有与该请求相关的内存分配一般都会使用该内存池<br>4 创建所有模块的上下文ctx指针数组，变量数据<br>5 将该请求的main字段设置为它本身，表示这是一个主请求<br>6 将该请求的count字段设置为1，count字段表示请求的引用计数<br>7 将当前时间保持在start_sec和start_msec字段，这个时间是该请求的起始时刻，将被用来计算一个请求的处理时间（request time），nginx使用的这个起始点和apache略有差别，nginx中请求的起始点是接收到客户端的第一个数据包开始，而apache则是接收到客户端的整个request line后开始算起；<br>8 初始化请求的其他字段，比如将uri_changes设置为11，表示最多可以将该请求的uri改写10次，subrequests被设置为201，表示一个请求最多可以发起200个子请求；</p>
<p>做完所有这些初始化工作之后，ngx_http_init_request函数会调用读事件的处理函数来真正的解析客户端发过来的数据，也就是会进入ngx_http_process_request_line函数中处理。</p>
<p>ngx_http_process_request_line函数的主要作用即是解析请求行，同样由于涉及到网络IO操作，即使是很短的一行请求行可能也不能被一次读完，所以ngx_http_process_request_line可能会被多次调用，在之前的ngx_http_init_request函数中，ngx_http_process_request_line函数被设置为读事件的处理函数，它也只拥有一个唯一的ngx_event_t *类型参数，并且在函数的开头，同样需要判断是否是超时事件，如果是的话，则关闭这个请求和连接；否则开始正常的解析流程。<br>先调用ngx_http_read_request_header函数读取数据。</p>
<p>ngx_http_read_request_header函数首先检查请求的header_in指向的缓冲区内是否有数据，有的话直接返回；否则从连接读取数据并保存在请求的header_in指向的缓存区，而且只要缓冲区有空间的话，会一次尽可能多的读数据，读到多少返回多少；如果客户端暂时没有发任何数据过来，并返回NGX_AGAIN。<br>返回之前会做2件事情：<br>1，设置一个定时器，时长默认为60s，可以通过指令client_header_timeout设置，如果定时事件到达之前没有任何可读事件，nginx将会关闭此请求；<br>2，调用ngx_handle_read_event函数处理一下读事件-如果该连接尚未在事件处理模型上挂载读事件，则将其挂载上；如果客户端提前关闭了连接或者读取数据发生了其他错误，则给客户端返回一个400错误（当然这里并不保证客户端能够接收到响应数据，因为客户端可能都已经关闭了连接），最后函数返回NGX_ERROR。<br>如果ngx_http_read_request_header函数正常的读取到了数据，ngx_http_process_request_line函数将调用ngx_http_parse_request_line函数来解析。</p>
<p>ngx_http_parse_request_line 函数根据http协议规范中对请求行的定义实现了一个有限状态机，经过这个状态机，nginx会记录请求行中的请求方法（Method），请求uri以及http协议版本在缓冲区中的起始位置，在解析过程中还会记录一些其他有用的信息，以便后面的处理过程中使用。如果解析请求行的过程中没有产生任何问题，该函数会返回NGX_OK；如果请求行不满足协议规范，该函数会立即终止解析过程，并返回相应错误号；如果缓冲区数据不够，该函数返回NGX_AGAIN。</p>
<p>如果ngx_http_parse_request_line函数返回了错误，则直接给客户端返回400错误；<br>如果返回NGX_AGAIN，则需要判断一下是否是由于缓冲区空间不够，还是已读数据不够。如果是缓冲区大小不够了，nginx会调用ngx_http_alloc_large_header_buffer函数来分配另一块大缓冲区，如果大缓冲区还不够装下整个请求行，nginx则会返回414错误给客户端，否则分配了更大的缓冲区并拷贝之前的数据之后，继续调用ngx_http_read_request_header函数读取数据来进入请求行自动机处理，直到请求行解析结束；<br>如果返回了NGX_OK，则表示请求行被正确的解析出来了，这时先记录好请求行的起始地址以及长度，并将请求uri的path和参数部分保存在请求结构的uri字段，请求方法起始位置和长度保存在method_name字段，http版本起始位置和长度记录在http_protocol字段。还要从uri中解析出参数以及请求资源的拓展名，分别保存在args和exten字段。</p>
<p>接下来要做的就是读取请求头了，首先nginx会为请求头分配空间，ngx_http_headers_in_t结构的headers字段为一个链表结构，它被用来保存所有请求头，初始为它分配了20个节点，每个节点的类型为ngx_table_elt_t，保存请求头的name/value值对，还可以看到ngx_http_headers_in_t结构有很多类型为ngx_table_elt_t*的指针成员，而且从它们的命名可以看出是一些常见的请求头名字，nginx对这些常用的请求头在ngx_http_headers_in_t结构里面保存了一份引用，后续需要使用的话，可以直接通过这些成员得到，另外也事先为cookie头分配了2个元素的数组空间，做完这些内存准备工作之后，该请求对应的读事件结构的处理函数被设置为ngx_http_process_request_headers。</p>
<p>ngx_http_process_request_headers函数循环的读取所有的请求头，并保存和初始化和请求头相关的结构，因为nginx对读取请求头有超时限制，ngx_http_process_request_headers函数作为读事件处理函数，一并处理了超时事件，如果读超时了，nginx直接给该请求返回408错误。读取和解析请求头的逻辑和处理请求行差不多，总的流程也是循环的调用ngx_http_read_request_header函数读取数据。</p>
<p>ngx_http_read_request_header函数读取数据时如果当前连接并没有数据过来，则直接返回，等待下一次读事件到来，如果读到了一些数据则调用ngx_http_parse_header_line函数来解析，同样的该解析函数实现为一个有限状态机，逻辑很简单，只是根据http协议的解析一个请求头的name/vale对，每次调用该函数最多解析出一个请求头，该函数返回4种不同返回值，表示不同解析结果：</p>
<p>1 返回NGX_OK，表示解析出了一行请求头，这时还要判断解析出的请求头名字里面是否有非法字符，名字里面合法的字符包括字母，数字和连字符（-），另外如果设置了underscores_in_headers指令为on，则下划线也是合法字符，但是nginx默认下划线不合法，当请求头里面包含了非法的字符，nginx默认只是忽略这一行请求头；如果一切都正常，nginx会将该请求头及请求头名字的hash值保存在请求结构体的headers_in成员的headers链表,而且对于一些常见的请求头，如Host，Connection，nginx采用了类似于配置指令的方式，事先给这些请求头分配了一个处理函数，当解析出一个请求头时，会检查该请求头是否有设置处理函数，有的话则调用之，nginx所有有处理函数的请求头都记录在ngx_http_headers_in全局数组中。</p>
<p>2 返回NGX_AGAIN，表示当前接收到的数据不够，一行请求头还未结束，需要继续下一轮循环。在下一轮循环中，nginx首先检查请求头缓冲区header_in是否已满，如够满了，则调用ngx_http_alloc_large_header_buffer函数分配更多缓冲区，当ngx_http_alloc_large_header_buffer函数返回NGX_DECLINED）时，表示客户端发送了过大的一行请求头，或者是整个请求头部超过了限制，nginx会返回494错误，注意到nginx再返回494错误之前将请求的lingering_close 标识置为了1，这样做的目的是在返回响应之丢弃掉客户端发过来的其他数据</p>
<p>3 返回NGX_HTTP_PARSE_INVALID_HEADER，表示请求头解析过程中遇到错误，一般为客户端发送了不符合协议规范的头部，此时nginx返回400错误。</p>
<p>4 返回NGX_HTTP_PARSE_HEADER_DONE，表示所有请求头已经成功的解析，这时请求的状态被设置为NGX_HTTP_PROCESS_REQUEST_STATE，意味着结束了请求读取阶段，正式进入了请求处理阶段，但是实际上请求可能含有请求体，nginx在请求读取阶段并不会去读取请求体，这个工作交给了后续的请求处理阶段的模块，这样做的目的是nginx本身并不知道这些请求体是否有用，如果后续模块并不需要的话，一方面请求体一般较大，如果全部读取进内存，则白白耗费大量的内存空间，另一方面即使nginx将请求体写进磁盘，但是涉及到磁盘io，会耗费比较多时间。所以交由后续模块来决定读取还是丢弃请求体是最明智的办法。</p>
<p>当nginx解析到两个回车换行符时，就表示请求头读取结束，nginx调用ngx_http_process_request函数处理请求。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://blog.csdn.net/fengmo_q/article/details/7736695" target="_blank" rel="external">http://blog.csdn.net/fengmo_q/article/details/7736695</a><br><a href="http://blog.itpub.net/15480802/viewspace-1393025/" target="_blank" rel="external">http://blog.itpub.net/15480802/viewspace-1393025/</a><br><a href="http://tengine.taobao.org/book/chapter_02.html" target="_blank" rel="external">http://tengine.taobao.org/book/chapter_02.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Nginx 请求读取流程，转载改编自&lt;a href=&quot;http://blog.csdn.net/fengmo_q/article/details/7736695&quot;&gt;http://blog.csdn.net/fengmo_q/article/details/7736695&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://github.com/Sword2G/sword2g.github.io/categories/Linux/"/>
    
    
      <category term="Nginx" scheme="https://github.com/Sword2G/sword2g.github.io/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>Nginx 基础数据结构(四)</title>
    <link href="https://github.com/Sword2G/sword2g.github.io/2016/09/20/nginx_connection_s/"/>
    <id>https://github.com/Sword2G/sword2g.github.io/2016/09/20/nginx_connection_s/</id>
    <published>2016-09-20T04:31:19.000Z</published>
    <updated>2017-05-08T10:15:59.525Z</updated>
    
    <content type="html"><![CDATA[<p>Nginx 连接相关重要数据结构————ngx_connection_s  。<br><a id="more"></a></p>
<h1 id="Nginx工作流程"><a href="#Nginx工作流程" class="headerlink" title="Nginx工作流程"></a>Nginx工作流程</h1><p>首先，nginx在启动时，会解析配置文件，得到需要监听的端口与ip地址，然后在nginx的master进程里面，先初始化好这个监控的socket(创建socket，设置addrreuse等选项，绑定到指定的ip地址端口，再listen)，然后再fork出多个子进程出来，然后子进程会竞争accept新的连接。此时，客户端就可以向nginx发起连接了。当客户端与服务端通过三次握手建立好一个连接后，nginx的某一个子进程会accept成功，得到这个建立好的连接的socket，然后创建nginx对连接的封装，即ngx_connection_t结构体。接着，设置读写事件处理函数并添加读写事件来与客户端进行数据的交换。最后，nginx或客户端来主动关掉连接，到此，一个连接就寿终正寝了，ngx_connection_t被释放。</p>
<h1 id="ngx-connection-s-数据结构"><a href="#ngx-connection-s-数据结构" class="headerlink" title="ngx_connection_s 数据结构"></a>ngx_connection_s 数据结构</h1><p>在nginx中ngx_connection_s就是对tcp连接的封装，其中包括连接的socket(该socket的属性和数据信息)。利用nginx封装的ngx_connection_s，我们可以很方便的使用nginx来处理与连接相关的事情，比如，建立连接，发送与接受数据等。而nginx中的http请求的处理就是建立在ngx_connection_s之上的，所以nginx不仅可以作为一个web服务器，也可以作为邮件服务器。当然，利用nginx提供的ngx_connection_s，我们可以与任何后端服务打交道。</p>
<p>ngx_connection_s的定义保存在/src/core/ngx_connection.h</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> ngx_connection_s &#123;</div><div class="line">    <span class="comment">// 用来关联其他的ngx_connection_s结构体</span></div><div class="line">    <span class="keyword">void</span>               *data;</div><div class="line">    <span class="comment">//连接的读事件  </span></div><div class="line">    <span class="keyword">ngx_event_t</span>        *read;</div><div class="line">    <span class="comment">//连接的写事件</span></div><div class="line">    <span class="keyword">ngx_event_t</span>        *write;</div><div class="line">    <span class="comment">//套接字对应的fd</span></div><div class="line">    <span class="keyword">ngx_socket_t</span>        fd;</div><div class="line"></div><div class="line">    <span class="comment">//指向完成数据接收函数的函数指针</span></div><div class="line">    ngx_recv_pt         recv;</div><div class="line">    ngx_send_pt         send;</div><div class="line"></div><div class="line">    <span class="comment">//指向完成批量数据接收函数的函数指针</span></div><div class="line">    ngx_recv_chain_pt   recv_chain;</div><div class="line">    ngx_send_chain_pt   send_chain;</div><div class="line"></div><div class="line">    <span class="comment">//该网络连接的socket监听（ngx_listening_s）结构体，ngx_listening_s结构体中的*connection成员又将指向该ngx_connection_s结构体</span></div><div class="line">    <span class="keyword">ngx_listening_t</span>    *listening;</div><div class="line">    <span class="comment">// 该连接已发送的数据</span></div><div class="line">    <span class="keyword">off_t</span>               sent;</div><div class="line">    <span class="comment">//日志对象 </span></div><div class="line">    <span class="keyword">ngx_log_t</span>          *<span class="built_in">log</span>;</div><div class="line">    *内存池。当accept一个新的连接时，会创建一个内存池，而在这个连接结束时会销毁内存池。内存池大小是由上面listening成员的pool_size决定的*/</div><div class="line">    <span class="keyword">ngx_pool_t</span>         *pool;</div><div class="line"></div><div class="line">    <span class="keyword">int</span>                 type;</div><div class="line">    <span class="comment">//连接客户端的sockaddr</span></div><div class="line">    <span class="keyword">struct</span> sockaddr    *sockaddr;</div><div class="line">    <span class="keyword">socklen_t</span>           socklen;</div><div class="line">    <span class="comment">//连接客户端字符串形式的IP</span></div><div class="line">    <span class="keyword">ngx_str_t</span>           addr_text;</div><div class="line">    <span class="comment">// 代理地址，用于http代理模块</span></div><div class="line">    <span class="keyword">ngx_str_t</span>           proxy_protocol_addr;</div><div class="line">    <span class="keyword">in_port_t</span>           proxy_protocol_port;</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> (NGX_SSL || NGX_COMPAT)</span></div><div class="line">    <span class="keyword">ngx_ssl_connection_t</span>  *ssl;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">    <span class="comment">// 本地监听socket的地址结构。该信息来自ngx_listening_t结构体，最初来源于配置文件</span></div><div class="line">    <span class="keyword">struct</span> sockaddr    *local_sockaddr;</div><div class="line">    <span class="keyword">socklen_t</span>           local_socklen;</div><div class="line">    <span class="comment">//用户接受、缓存客户端发来的字符流，buffer是由连接内存池分配的，大小自由决定  </span></div><div class="line">    <span class="keyword">ngx_buf_t</span>          *buffer;</div><div class="line">    <span class="comment">/*用来将当前连接以双向链表元素的形式添加到ngx_cycle_t核心结构体的reuseable_connection_queue双向链表中，表示可以重用的连接*/</span>  </div><div class="line">    <span class="keyword">ngx_queue_t</span>         <span class="built_in">queue</span>;</div><div class="line">    <span class="comment">//连接使用次数。ngx_connection_t每建立一条来自client的连接或主动向server发起连接时，number都会加1</span></div><div class="line">    <span class="keyword">ngx_atomic_uint_t</span>   number;</div><div class="line">    <span class="comment">//处理的请求次数  </span></div><div class="line">    <span class="keyword">ngx_uint_t</span>          requests;</div><div class="line">    <span class="comment">//缓存中的业务类型，各个模块有自己的一些定义</span></div><div class="line">    <span class="keyword">unsigned</span>            buffered:<span class="number">8</span>;</div><div class="line">    <span class="comment">//本连接的日志级别，只定义了5个值，由ngx_connection_log_error_e枚举表示</span></div><div class="line">    <span class="keyword">unsigned</span>            log_error:<span class="number">3</span>;     <span class="comment">/* ngx_connection_log_error_e */</span></div><div class="line">    <span class="comment">// 1表示连接已超时</span></div><div class="line">    <span class="keyword">unsigned</span>            timedout:<span class="number">1</span>;</div><div class="line">    <span class="comment">// 1表示处理过程出现了错误</span></div><div class="line">    <span class="keyword">unsigned</span>            error:<span class="number">1</span>;</div><div class="line">    <span class="comment">//1表示连接已经销毁</span></div><div class="line">    <span class="keyword">unsigned</span>            destroyed:<span class="number">1</span>;</div><div class="line">    <span class="comment">//1表示连接处于空闲状态，如keepalive两次请求中间的状态</span></div><div class="line">    <span class="keyword">unsigned</span>            idle:<span class="number">1</span>;</div><div class="line">    <span class="comment">//1表示连接可重用，与上面的queue字段对应使</span></div><div class="line">    <span class="keyword">unsigned</span>            reusable:<span class="number">1</span>;</div><div class="line">    <span class="comment">//1表示连接关闭  </span></div><div class="line">    <span class="keyword">unsigned</span>            close:<span class="number">1</span>;</div><div class="line">    <span class="keyword">unsigned</span>            shared:<span class="number">1</span>;</div><div class="line">    <span class="comment">// 1表示正在发送文件数据</span></div><div class="line">    <span class="keyword">unsigned</span>            sendfile:<span class="number">1</span>;</div><div class="line">    <span class="comment">// 1表示连接套接字对应的发送缓冲区必须满足最低设置的大小阀值时，事件驱动模块才会分发该事件</span></div><div class="line">    <span class="keyword">unsigned</span>            sndlowat:<span class="number">1</span>;</div><div class="line">    <span class="keyword">unsigned</span>            tcp_nodelay:<span class="number">2</span>;   <span class="comment">/* ngx_connection_tcp_nodelay_e */</span></div><div class="line">    <span class="keyword">unsigned</span>            tcp_nopush:<span class="number">2</span>;    <span class="comment">/* ngx_connection_tcp_nopush_e */</span></div><div class="line"></div><div class="line">    <span class="keyword">unsigned</span>            need_last_buf:<span class="number">1</span>;</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> (NGX_HAVE_AIO_SENDFILE || NGX_COMPAT)</span></div><div class="line">    <span class="keyword">unsigned</span>            busy_count:<span class="number">2</span>;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> (NGX_THREADS || NGX_COMPAT)</span></div><div class="line">    <span class="keyword">ngx_thread_task_t</span>  *sendfile_task;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h1 id="ngx-listening-s"><a href="#ngx-listening-s" class="headerlink" title="ngx_listening_s"></a>ngx_listening_s</h1><p>与监听有关的数据保存在 ngx_listening_s 定义之中</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> ngx_listening_s  <span class="keyword">ngx_listening_t</span>;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> ngx_listening_s &#123;</div><div class="line">    <span class="comment">// 套接字fd</span></div><div class="line">    <span class="keyword">ngx_socket_t</span>        fd;</div><div class="line">    <span class="comment">// 监听sockaddr地址</span></div><div class="line">    <span class="keyword">struct</span> sockaddr    *sockaddr;</div><div class="line">    <span class="comment">// struct sockaddr 长度 = size of sockaddr</span></div><div class="line">    <span class="keyword">socklen_t</span>           socklen;    </div><div class="line">    <span class="comment">// addr_text 存储字符串形式的ip地址</span></div><div class="line">    <span class="keyword">size_t</span>              addr_text_max_len;</div><div class="line">    <span class="keyword">ngx_str_t</span>           addr_text;</div><div class="line"></div><div class="line">    <span class="comment">//套接字类型 SOCK_STREAM、SOCK_DGRAM、SOCK_RAW</span></div><div class="line">    <span class="keyword">int</span>                 type;</div><div class="line">    <span class="comment">//backlog 长度</span></div><div class="line">    <span class="keyword">int</span>                 backlog;</div><div class="line">    <span class="comment">//套接字接收缓冲区大小 </span></div><div class="line">    <span class="keyword">int</span>                 rcvbuf;</div><div class="line">    <span class="comment">//套接字发送缓冲区大小  </span></div><div class="line">    <span class="keyword">int</span>                 sndbuf;</div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> (NGX_HAVE_KEEPALIVE_TUNABLE)</span></div><div class="line">    <span class="keyword">int</span>                 keepidle;</div><div class="line">    <span class="keyword">int</span>                 keepintvl;</div><div class="line">    <span class="keyword">int</span>                 keepcnt;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line">    <span class="comment">/* handler of accepted connection ,tcp连接建立成功后调用方法*/</span></div><div class="line">    ngx_connection_handler_pt   handler;</div><div class="line">    <span class="comment">//保存当前监听端口对应着的所有主机名</span></div><div class="line">    <span class="keyword">void</span>               *servers;  <span class="comment">/* array of ngx_http_in_addr_t, for example */</span></div><div class="line"></div><div class="line">    <span class="keyword">ngx_log_t</span>           <span class="built_in">log</span>;</div><div class="line">    <span class="keyword">ngx_log_t</span>          *logp;</div><div class="line"></div><div class="line">    <span class="comment">// 内存池的初始大小</span></div><div class="line">    <span class="keyword">size_t</span>              pool_size;</div><div class="line">    <span class="comment">/* should be here because of the AcceptEx() preread */</span></div><div class="line">    <span class="keyword">size_t</span>              post_accept_buffer_size;</div><div class="line">    <span class="comment">/* should be here because of the deferred accept ,连接timeout，超时对其连接*/</span></div><div class="line">    <span class="keyword">ngx_msec_t</span>          post_accept_timeout;</div><div class="line"></div><div class="line">    <span class="keyword">ngx_listening_t</span>    *previous;</div><div class="line">    <span class="comment">// 当前监听句柄对应的ngx_connection_t结构体，注意ngx_connection_t中的 *listening 字段</span></div><div class="line">    <span class="keyword">ngx_connection_t</span>   *connection;</div><div class="line"></div><div class="line">    <span class="keyword">ngx_uint_t</span>          worker;</div><div class="line"></div><div class="line">    <span class="comment">//1表示监听句柄有效，为0表示正常关闭 </span></div><div class="line">    <span class="keyword">unsigned</span>            open:<span class="number">1</span>;</div><div class="line">    <span class="comment">//1表示不关闭原先打开的监听端口，为0表示关闭曾经打开的监听端口</span></div><div class="line">    <span class="keyword">unsigned</span>            remain:<span class="number">1</span>;</div><div class="line">    <span class="comment">//1表示跳过设置当前ngx_listening_t结构体中的套接字，为0时正常初始化套接字</span></div><div class="line">    <span class="keyword">unsigned</span>            ignore:<span class="number">1</span>;</div><div class="line"></div><div class="line">    <span class="keyword">unsigned</span>            bound:<span class="number">1</span>;       <span class="comment">/* already bound */</span></div><div class="line">    <span class="keyword">unsigned</span>            inherited:<span class="number">1</span>;   <span class="comment">/* inherited from previous process */</span></div><div class="line">    <span class="keyword">unsigned</span>            nonblocking_accept:<span class="number">1</span>;</div><div class="line">    <span class="comment">// 1表示当前结构体对应的套接字已经监听</span></div><div class="line">    <span class="keyword">unsigned</span>            listen:<span class="number">1</span>;</div><div class="line">    <span class="keyword">unsigned</span>            nonblocking:<span class="number">1</span>;</div><div class="line">    <span class="keyword">unsigned</span>            shared:<span class="number">1</span>;    <span class="comment">/* shared between threads or processes */</span></div><div class="line">    <span class="comment">// 表示将网络地址转变为字符串形式的地址</span></div><div class="line">    <span class="keyword">unsigned</span>            addr_ntop:<span class="number">1</span>;</div><div class="line">    <span class="keyword">unsigned</span>            wildcard:<span class="number">1</span>;</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> (NGX_HAVE_INET6)</span></div><div class="line">    <span class="keyword">unsigned</span>            ipv6only:<span class="number">1</span>;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">    <span class="keyword">unsigned</span>            reuseport:<span class="number">1</span>;</div><div class="line">    <span class="keyword">unsigned</span>            add_reuseport:<span class="number">1</span>;</div><div class="line">    <span class="keyword">unsigned</span>            keepalive:<span class="number">2</span>;</div><div class="line"></div><div class="line">    <span class="keyword">unsigned</span>            deferred_accept:<span class="number">1</span>;</div><div class="line">    <span class="keyword">unsigned</span>            delete_deferred:<span class="number">1</span>;</div><div class="line">    <span class="keyword">unsigned</span>            add_deferred:<span class="number">1</span>;</div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> (NGX_HAVE_DEFERRED_ACCEPT &amp;&amp; defined SO_ACCEPTFILTER)</span></div><div class="line">    <span class="keyword">char</span>               *accept_filter;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> (NGX_HAVE_SETFIB)</span></div><div class="line">    <span class="keyword">int</span>                 setfib;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> (NGX_HAVE_TCP_FASTOPEN)</span></div><div class="line">    <span class="keyword">int</span>                 fastopen;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>ngx_http_request_s 是 Nginx 对 http 请求的封装，定义保存在/src/http/ngx_http_request.h<br>，具体的数据结构如下，</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div><div class="line">241</div><div class="line">242</div><div class="line">243</div><div class="line">244</div><div class="line">245</div><div class="line">246</div><div class="line">247</div><div class="line">248</div><div class="line">249</div><div class="line">250</div><div class="line">251</div><div class="line">252</div><div class="line">253</div><div class="line">254</div><div class="line">255</div><div class="line">256</div><div class="line">257</div><div class="line">258</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> ngx_http_request_s &#123;</div><div class="line">    <span class="keyword">uint32_t</span>                          signature;         <span class="comment">/* "HTTP" */</span></div><div class="line"></div><div class="line">    <span class="comment">//请求对应的客户端连接，是一个指向 ngx_connection_s 结构的指针</span></div><div class="line">    <span class="keyword">ngx_connection_t</span>                 *connection;</div><div class="line">    <span class="comment">//指向存放所有HTTP模块上下文结构体的指针数组  </span></div><div class="line">    <span class="keyword">void</span>                            **ctx;</div><div class="line">    <span class="comment">//指向请求对应的存放main级别配置结构体的指针数组</span></div><div class="line">    <span class="keyword">void</span>                            **main_conf;</div><div class="line">    <span class="comment">//指向请求对应的存放srv级别配置结构体的指针数组</span></div><div class="line">    <span class="keyword">void</span>                            **srv_conf;</div><div class="line">    <span class="comment">//指向请求对应的存放loc级别配置结构体的指针数组</span></div><div class="line">    <span class="keyword">void</span>                            **loc_conf;</div><div class="line"></div><div class="line">    <span class="comment">/* </span></div><div class="line">     * 在接收完http头部，第一次在业务上处理http请求时，http框架提供的处理方法是ngx_http_process_request。 </div><div class="line">     但如果该方法无法一次处理完该请求的全部业务，在归还控制权到epoll时间模块后，该请求再次被回调时， </div><div class="line">     将通过Ngx_http_request_handler方法来处理，而这个方法中对于可读事件的处理就是调用read_event_handler处理请求。 </div><div class="line">     也就是说，http模块希望在底层处理请求的读事件时，重新实现read_event_handler方法 </div><div class="line">    */  </div><div class="line">    ngx_http_event_handler_pt         read_event_handler;</div><div class="line">    ngx_http_event_handler_pt         write_event_handler;</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> (NGX_HTTP_CACHE)</span></div><div class="line">    <span class="keyword">ngx_http_cache_t</span>                 *cache;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">    <span class="comment">//upstream机制用到的结构体</span></div><div class="line">    <span class="keyword">ngx_http_upstream_t</span>              *upstream;</div><div class="line">    <span class="keyword">ngx_array_t</span>                      *upstream_states;</div><div class="line">                                         <span class="comment">/* of ngx_http_upstream_state_t */</span></div><div class="line">    <span class="comment">//该请求的内存池</span></div><div class="line">    <span class="keyword">ngx_pool_t</span>                       *pool;</div><div class="line">    <span class="comment">//用于保存请求头的缓冲区</span></div><div class="line">    <span class="keyword">ngx_buf_t</span>                        *header_in;</div><div class="line">    <span class="comment">/*ngx_http_process_request_headers在接收、解析完http请求的头部后，会把解析完的每一个http头部加入到headers_in的headers链表中，同时会构造headers_in中的其他成员  */</span></div><div class="line">    <span class="keyword">ngx_http_headers_in_t</span>             headers_in;</div><div class="line">    <span class="comment">/*http模块会把想要发送的http相应信息放到headers_out中，期望http框架将headers_out中的成员序列化为http响应包发送给用户 */</span></div><div class="line">    <span class="keyword">ngx_http_headers_out_t</span>            headers_out;</div><div class="line">    <span class="comment">//接收请求中包体的数据结构</span></div><div class="line">    <span class="keyword">ngx_http_request_body_t</span>          *request_body;</div><div class="line"></div><div class="line">    <span class="comment">//延迟关闭连接的时间</span></div><div class="line">    <span class="keyword">time_t</span>                            lingering_time;</div><div class="line">    <span class="comment">//当前请求初始化时的时间</span></div><div class="line">    <span class="keyword">time_t</span>                            start_sec;</div><div class="line">    <span class="keyword">ngx_msec_t</span>                        start_msec;</div><div class="line"></div><div class="line">    <span class="comment">//下面的9个成员是函数ngx_http_process_request_line方法在接收、解析http请求行时解析出的信息 </span></div><div class="line">    <span class="keyword">ngx_uint_t</span>                        method;</div><div class="line">    <span class="keyword">ngx_uint_t</span>                        http_version;</div><div class="line"></div><div class="line">    <span class="keyword">ngx_str_t</span>                         request_line;</div><div class="line">    <span class="keyword">ngx_str_t</span>                         uri;</div><div class="line">    <span class="keyword">ngx_str_t</span>                         args;</div><div class="line">    <span class="keyword">ngx_str_t</span>                         exten;</div><div class="line">    <span class="comment">//没有进行URL解码的原始请求 </span></div><div class="line">    <span class="keyword">ngx_str_t</span>                         unparsed_uri;</div><div class="line"></div><div class="line">    <span class="keyword">ngx_str_t</span>                         method_name;</div><div class="line">    <span class="keyword">ngx_str_t</span>                         http_protocol;</div><div class="line"></div><div class="line">    <span class="comment">/*表示需要发送给客户端的http响应。out中保存着由headers_out中序列化后的表示http头部的TCP流。 </span></div><div class="line">     * 在调用ngx_http_output_filter方法后，out中还会保存着待发送的http包体，它是实现异步发送http响应的关键。</div><div class="line">     */ </div><div class="line">    <span class="keyword">ngx_chain_t</span>                      *out;</div><div class="line">    <span class="comment">/*当前请求既有可能是用户发来的请求，也可能是派生出的子请求。 </span></div><div class="line">     * 而main标识一系列相关的派生子请求的原始请求。 </div><div class="line">     * 一般可通过main和当前请求的地址是否相等来判断当前请求是否为用户发来的原始请求。</div><div class="line">     */ </div><div class="line">    <span class="keyword">ngx_http_request_t</span>               *main;</div><div class="line">    <span class="comment">//当前请求的父请求（不一定是原始请求）</span></div><div class="line">    <span class="keyword">ngx_http_request_t</span>               *parent;</div><div class="line">    <span class="comment">//与subrequest子请求相关的功能</span></div><div class="line">    <span class="keyword">ngx_http_postponed_request_t</span>     *postponed;</div><div class="line">    <span class="keyword">ngx_http_post_subrequest_t</span>       *post_subrequest;</div><div class="line">    <span class="comment">//所有的子请求都是通过这个单链表链接起来的 </span></div><div class="line">    <span class="keyword">ngx_http_posted_request_t</span>        *posted_requests;</div><div class="line"></div><div class="line">    <span class="comment">/*全局的ngx_http_phase_engine_t结构体中定义了一个ngx_http_phase_handler_t回调方法组成的数组。 </span></div><div class="line">     * 而phase_handler成员则与该数组配合使用。表示请求下次应当执行phase_handler作为序列号指定的数组中的回调方法</div><div class="line">     */ </div><div class="line">    <span class="keyword">ngx_int_t</span>                         phase_handler;</div><div class="line">    <span class="comment">//表示NGX_HTTP_CONTENT_PHASE阶段提供给http模块处理请求的一种方式，它指向http模块实现的请求处理方法 </span></div><div class="line">    ngx_http_handler_pt               content_handler;</div><div class="line">    <span class="comment">//在NGX_HTTP_ACCESS_PHASE节点需要判断请求是否具有访问权限时，通过access_code来传递http模块的handler回调方法的返回值，如果为0表示具备权限。否则不具备。 </span></div><div class="line">    <span class="keyword">ngx_uint_t</span>                        access_code;</div><div class="line"></div><div class="line">    <span class="keyword">ngx_http_variable_value_t</span>        *variables;</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> (NGX_PCRE)</span></div><div class="line">    <span class="keyword">ngx_uint_t</span>                        ncaptures;</div><div class="line">    <span class="keyword">int</span>                              *captures;</div><div class="line">    u_char                           *captures_data;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line">    <span class="keyword">size_t</span>                            limit_rate;</div><div class="line">    <span class="keyword">size_t</span>                            limit_rate_after;</div><div class="line"></div><div class="line">    <span class="comment">/* used to learn the Apache compatible response length without a header */</span></div><div class="line">    <span class="keyword">size_t</span>                            header_size;</div><div class="line"></div><div class="line">    <span class="keyword">off_t</span>                             request_length;</div><div class="line"></div><div class="line">    <span class="keyword">ngx_uint_t</span>                        err_status;</div><div class="line"></div><div class="line">    <span class="keyword">ngx_http_connection_t</span>            *http_connection;</div><div class="line">    <span class="keyword">ngx_http_v2_stream_t</span>             *stream;</div><div class="line"></div><div class="line">    ngx_http_log_handler_pt           log_handler;</div><div class="line"></div><div class="line">    <span class="comment">//在这个请求中如果打开了某些资源，并需要在请求结束时释放，那么需要把定义的释放资源的方法添加到这个成员 </span></div><div class="line">    <span class="keyword">ngx_http_cleanup_t</span>               *cleanup;</div><div class="line">    <span class="comment">//引用计数，每当派生出子请求时，原始请求的count成员都会加一 </span></div><div class="line">    <span class="keyword">unsigned</span>                          count:<span class="number">16</span>;</div><div class="line">    <span class="keyword">unsigned</span>                          subrequests:<span class="number">8</span>;</div><div class="line">    <span class="comment">//阻塞标志位，目前仅由aio使用 </span></div><div class="line">    <span class="keyword">unsigned</span>                          blocked:<span class="number">8</span>;</div><div class="line"></div><div class="line">    <span class="comment">//标志位：为1表示当前请求正在使用异步IO  </span></div><div class="line">    <span class="keyword">unsigned</span>                          aio:<span class="number">1</span>;</div><div class="line"></div><div class="line">    <span class="keyword">unsigned</span>                          http_state:<span class="number">4</span>;</div><div class="line"></div><div class="line">    <span class="comment">/* URI with "/." and on Win32 with "//" */</span></div><div class="line">    <span class="keyword">unsigned</span>                          complex_uri:<span class="number">1</span>;</div><div class="line"></div><div class="line">    <span class="comment">/* URI with "%" */</span></div><div class="line">    <span class="keyword">unsigned</span>                          quoted_uri:<span class="number">1</span>;</div><div class="line"></div><div class="line">    <span class="comment">/* URI with "+" */</span></div><div class="line">    <span class="keyword">unsigned</span>                          plus_in_uri:<span class="number">1</span>;</div><div class="line"></div><div class="line">    <span class="comment">/* URI with " " */</span></div><div class="line">    <span class="keyword">unsigned</span>                          space_in_uri:<span class="number">1</span>;</div><div class="line"></div><div class="line">    <span class="keyword">unsigned</span>                          invalid_header:<span class="number">1</span>;</div><div class="line"></div><div class="line">    <span class="keyword">unsigned</span>                          add_uri_to_alias:<span class="number">1</span>;</div><div class="line">    <span class="keyword">unsigned</span>                          valid_location:<span class="number">1</span>;</div><div class="line">    <span class="keyword">unsigned</span>                          valid_unparsed_uri:<span class="number">1</span>;</div><div class="line">    <span class="comment">//标志位：为1时表示URL发生过rewrite重写</span></div><div class="line">    <span class="keyword">unsigned</span>                          uri_changed:<span class="number">1</span>;</div><div class="line">    <span class="comment">//表示使用rewrite重写URL的次数</span></div><div class="line">    <span class="keyword">unsigned</span>                          uri_changes:<span class="number">4</span>;</div><div class="line"></div><div class="line">    <span class="keyword">unsigned</span>                          request_body_in_single_buf:<span class="number">1</span>;</div><div class="line">    <span class="keyword">unsigned</span>                          request_body_in_file_only:<span class="number">1</span>;</div><div class="line">    <span class="keyword">unsigned</span>                          request_body_in_persistent_file:<span class="number">1</span>;</div><div class="line">    <span class="keyword">unsigned</span>                          request_body_in_clean_file:<span class="number">1</span>;</div><div class="line">    <span class="keyword">unsigned</span>                          request_body_file_group_access:<span class="number">1</span>;</div><div class="line">    <span class="keyword">unsigned</span>                          request_body_file_log_level:<span class="number">3</span>;</div><div class="line">    <span class="keyword">unsigned</span>                          request_body_no_buffering:<span class="number">1</span>;</div><div class="line"></div><div class="line">    <span class="keyword">unsigned</span>                          subrequest_in_memory:<span class="number">1</span>;</div><div class="line">    <span class="keyword">unsigned</span>                          waited:<span class="number">1</span>;</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> (NGX_HTTP_CACHE)</span></div><div class="line">    <span class="keyword">unsigned</span>                          cached:<span class="number">1</span>;</div><div class="line">    <span class="keyword">unsigned</span>                          cache_updater:<span class="number">1</span>;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> (NGX_HTTP_GZIP)</span></div><div class="line">    <span class="keyword">unsigned</span>                          gzip_tested:<span class="number">1</span>;</div><div class="line">    <span class="keyword">unsigned</span>                          gzip_ok:<span class="number">1</span>;</div><div class="line">    <span class="keyword">unsigned</span>                          gzip_vary:<span class="number">1</span>;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line">    <span class="keyword">unsigned</span>                          proxy:<span class="number">1</span>;</div><div class="line">    <span class="keyword">unsigned</span>                          bypass_cache:<span class="number">1</span>;</div><div class="line">    <span class="keyword">unsigned</span>                          no_cache:<span class="number">1</span>;</div><div class="line"></div><div class="line">    <span class="comment">/*</span></div><div class="line">     * instead of using the request context data in</div><div class="line">     * ngx_http_limit_conn_module and ngx_http_limit_req_module</div><div class="line">     * we use the single bits in the request structure</div><div class="line">     */</div><div class="line">    <span class="keyword">unsigned</span>                          limit_conn_set:<span class="number">1</span>;</div><div class="line">    <span class="keyword">unsigned</span>                          limit_req_set:<span class="number">1</span>;</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></div><div class="line">    <span class="keyword">unsigned</span>                          cacheable:<span class="number">1</span>;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line">    <span class="keyword">unsigned</span>                          pipeline:<span class="number">1</span>;</div><div class="line">    <span class="keyword">unsigned</span>                          chunked:<span class="number">1</span>;</div><div class="line">    <span class="keyword">unsigned</span>                          header_only:<span class="number">1</span>;</div><div class="line">    <span class="comment">//标志位，为1表示当前请求时keepalive请求</span></div><div class="line">    <span class="keyword">unsigned</span>                          keepalive:<span class="number">1</span>;</div><div class="line">    <span class="comment">//延迟关闭标志位</span></div><div class="line">    <span class="keyword">unsigned</span>                          lingering_close:<span class="number">1</span>;</div><div class="line">    <span class="keyword">unsigned</span>                          discard_body:<span class="number">1</span>;</div><div class="line">    <span class="keyword">unsigned</span>                          reading_body:<span class="number">1</span>;</div><div class="line">    <span class="comment">//标志位：为1表示请求的当前状态是在做内部跳转</span></div><div class="line">    <span class="keyword">unsigned</span>                          internal:<span class="number">1</span>;</div><div class="line">    <span class="keyword">unsigned</span>                          error_page:<span class="number">1</span>;</div><div class="line">    <span class="keyword">unsigned</span>                          filter_finalize:<span class="number">1</span>;</div><div class="line">    <span class="keyword">unsigned</span>                          post_action:<span class="number">1</span>;</div><div class="line">    <span class="keyword">unsigned</span>                          request_complete:<span class="number">1</span>;</div><div class="line">    <span class="keyword">unsigned</span>                          request_output:<span class="number">1</span>;</div><div class="line">    <span class="comment">//标志位：为1表示发生给客户端的http响应头已经发送 </span></div><div class="line">    <span class="keyword">unsigned</span>                          header_sent:<span class="number">1</span>;</div><div class="line">    <span class="keyword">unsigned</span>                          expect_tested:<span class="number">1</span>;</div><div class="line">    <span class="keyword">unsigned</span>                          root_tested:<span class="number">1</span>;</div><div class="line">    <span class="keyword">unsigned</span>                          done:<span class="number">1</span>;</div><div class="line">    <span class="keyword">unsigned</span>                          logged:<span class="number">1</span>;</div><div class="line"></div><div class="line">    <span class="comment">//标志位，表示缓冲中是否有待发送内容</span></div><div class="line">    <span class="keyword">unsigned</span>                          buffered:<span class="number">4</span>;</div><div class="line"></div><div class="line">    <span class="keyword">unsigned</span>                          main_filter_need_in_memory:<span class="number">1</span>;</div><div class="line">    <span class="keyword">unsigned</span>                          filter_need_in_memory:<span class="number">1</span>;</div><div class="line">    <span class="keyword">unsigned</span>                          filter_need_temporary:<span class="number">1</span>;</div><div class="line">    <span class="keyword">unsigned</span>                          allow_ranges:<span class="number">1</span>;</div><div class="line">    <span class="keyword">unsigned</span>                          subrequest_ranges:<span class="number">1</span>;</div><div class="line">    <span class="keyword">unsigned</span>                          single_range:<span class="number">1</span>;</div><div class="line">    <span class="keyword">unsigned</span>                          disable_not_modified:<span class="number">1</span>;</div><div class="line">    <span class="keyword">unsigned</span>                          stat_reading:<span class="number">1</span>;</div><div class="line">    <span class="keyword">unsigned</span>                          stat_writing:<span class="number">1</span>;</div><div class="line">    <span class="keyword">unsigned</span>                          stat_processing:<span class="number">1</span>;</div><div class="line"></div><div class="line">    <span class="keyword">unsigned</span>                          health_check:<span class="number">1</span>;</div><div class="line"></div><div class="line">    <span class="comment">/* used to parse HTTP headers */</span></div><div class="line"></div><div class="line">     <span class="comment">//状态机解析http时使用state来表示当前的解析状态，需要检查是否构成完整的http请求行  </span></div><div class="line">    <span class="keyword">ngx_uint_t</span>                        state;</div><div class="line"></div><div class="line">    <span class="keyword">ngx_uint_t</span>                        header_hash;</div><div class="line">    <span class="keyword">ngx_uint_t</span>                        lowcase_index;</div><div class="line">    u_char                            lowcase_header[NGX_HTTP_LC_HEADER_LEN];</div><div class="line"></div><div class="line">    u_char                           *header_name_start;</div><div class="line">    u_char                           *header_name_end;</div><div class="line">    u_char                           *header_start;</div><div class="line">    u_char                           *header_end;</div><div class="line"></div><div class="line">    <span class="comment">/*</span></div><div class="line">     * a memory that can be reused after parsing a request line</div><div class="line">     * via ngx_http_ephemeral_t</div><div class="line">     */</div><div class="line"></div><div class="line">    u_char                           *uri_start;</div><div class="line">    u_char                           *uri_end;</div><div class="line">    u_char                           *uri_ext;</div><div class="line">    u_char                           *args_start;</div><div class="line">    u_char                           *request_start;</div><div class="line">    u_char                           *request_end;</div><div class="line">    u_char                           *method_end;</div><div class="line">    u_char                           *schema_start;</div><div class="line">    u_char                           *schema_end;</div><div class="line">    u_char                           *host_start;</div><div class="line">    u_char                           *host_end;</div><div class="line">    u_char                           *port_start;</div><div class="line">    u_char                           *port_end;</div><div class="line"></div><div class="line">    <span class="keyword">unsigned</span>                          http_minor:<span class="number">16</span>;</div><div class="line">    <span class="keyword">unsigned</span>                          http_major:<span class="number">16</span>;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://book.51cto.com/art/201312/420132.htm" target="_blank" rel="external">http://book.51cto.com/art/201312/420132.htm</a><br><a href="http://blog.csdn.net/xiaoliangsky/article/details/39831035?utm_source=tuicool&amp;utm_medium=referral" target="_blank" rel="external">http://blog.csdn.net/xiaoliangsky/article/details/39831035?utm_source=tuicool&amp;utm_medium=referral</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Nginx 连接相关重要数据结构————ngx_connection_s  。&lt;br&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://github.com/Sword2G/sword2g.github.io/categories/Linux/"/>
    
    
      <category term="Nginx" scheme="https://github.com/Sword2G/sword2g.github.io/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>Nginx 基础数据结构(三)</title>
    <link href="https://github.com/Sword2G/sword2g.github.io/2016/09/17/nginx-datastructure-ngx_array_t/"/>
    <id>https://github.com/Sword2G/sword2g.github.io/2016/09/17/nginx-datastructure-ngx_array_t/</id>
    <published>2016-09-17T15:41:12.000Z</published>
    <updated>2017-03-25T16:04:25.337Z</updated>
    
    <content type="html"><![CDATA[<p>Nginx模块基础数据结构————ngx_array_t。<br><a id="more"></a></p>
<h1 id="ngx-array-t"><a href="#ngx-array-t" class="headerlink" title="ngx_array_t"></a>ngx_array_t</h1><p>ngx_array_t是nginx内部使用的数组结构。nginx的数组结构在存储上与C语言内置的数组一样占用块连续的内存。除此之外，它可以在数组容量达到上限时动态扩容数组，很像c++ STL中的vector容器。</p>
<h2 id="ngx-array-t定义"><a href="#ngx-array-t定义" class="headerlink" title="ngx_array_t定义"></a>ngx_array_t定义</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> ngx_array_s  <span class="keyword">ngx_array_t</span>;    </div><div class="line"><span class="keyword">struct</span> ngx_array_s &#123;  </div><div class="line">    <span class="keyword">void</span>        *elts;  <span class="comment">//存储数据的起始地址  </span></div><div class="line">    <span class="keyword">ngx_uint_t</span>   nelts; <span class="comment">//数组实际元素个数</span></div><div class="line">    <span class="keyword">size_t</span>       size;  <span class="comment">//单个元素的大小（字节）  </span></div><div class="line">    <span class="comment">/*</span></div><div class="line">    当nelts增长到达nalloc 时，如果再往此数组中存储元素，则会引发数组的扩容。数组的容量将会扩展到原有容量的2倍大小。实际上是分配新的一块内存，新的一块内存的大小是原有内存大小的2倍。原有的数据会被拷贝到新的一块内存中。</div><div class="line">    */</div><div class="line">    <span class="keyword">ngx_uint_t</span>   nalloc; <span class="comment">//数组容量，即数组预先分配的内存大小  </span></div><div class="line">    <span class="keyword">ngx_pool_t</span>  *pool;  <span class="comment">//该数组用来分配内存的内存池。  </span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h2 id="ngx-array-t-api"><a href="#ngx-array-t-api" class="headerlink" title="ngx_array_t api"></a>ngx_array_t api</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">ngx_array_t</span> *ngx_array_create(<span class="keyword">ngx_pool_t</span> *p, <span class="keyword">ngx_uint_t</span> n, <span class="keyword">size_t</span> size);</div><div class="line"><span class="comment">/*</span></div><div class="line">创建一个新的数组对象，并返回这个对象。</div><div class="line"></div><div class="line">p:	数组分配内存使用的内存池；</div><div class="line">n:	数组的初始容量大小，即在不扩容的情况下最多可以容纳的元素个数。</div><div class="line">size:	单个元素的大小，单位是字节。</div><div class="line">*/</div><div class="line"></div><div class="line"><span class="comment">//销毁该数组对象，并释放其分配的内存回内存池。</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">ngx_array_destroy</span><span class="params">(<span class="keyword">ngx_array_t</span> *a)</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> *<span class="title">ngx_array_push</span><span class="params">(<span class="keyword">ngx_array_t</span> *a)</span></span>;</div><div class="line"><span class="comment">/*</span></div><div class="line">在数组a上新追加一个元素，并返回指向新元素的指针。需要把返回的指针使用类型转换，转换为具体的类型，然后再给新元素本身或者是各字段（如果数组的元素是复杂类型）赋值。</div><div class="line">*/</div><div class="line"></div><div class="line"><span class="comment">// 在数组a上追加n个元素，并返回指向这些追加元素的首个元素的位置的指针。</span></div><div class="line"><span class="function"><span class="keyword">void</span> *<span class="title">ngx_array_push_n</span><span class="params">(<span class="keyword">ngx_array_t</span> *a, <span class="keyword">ngx_uint_t</span> n)</span></span>;</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> ngx_inline ngx_int_t <span class="title">ngx_array_init</span><span class="params">(<span class="keyword">ngx_array_t</span> *<span class="built_in">array</span>, <span class="keyword">ngx_pool_t</span> *pool, <span class="keyword">ngx_uint_t</span> n, <span class="keyword">size_t</span> size)</span></span>;</div><div class="line"><span class="comment">/*</span></div><div class="line">如果一个数组对象是被分配在堆上的，那么当调用ngx_array_destroy销毁以后，如果想再次使用，就可以调用此函数。</div><div class="line">如果一个数组对象是被分配在栈上的，那么就需要调用此函数，进行初始化的工作以后，才可以使用。</div><div class="line">*/</div></pre></td></tr></table></figure>
<p><strong><br>注意事项: 由于使用ngx_palloc分配内存，数组在扩容时，旧的内存不会被释放，会造成内存的浪费。因此，最好能提前规划好数组的容量，在创建或者初始化的时候一次搞定，避免多次扩容，造成内存浪费。
</strong></p>
<h2 id="ngx-array-t-与-ngx-pool-t-示意图"><a href="#ngx-array-t-与-ngx-pool-t-示意图" class="headerlink" title="ngx_array_t 与 ngx_pool_t 示意图"></a>ngx_array_t 与 ngx_pool_t 示意图</h2><p><img src="http://7xum8m.com1.z0.glb.clouddn.com/hexo-ngx-structure-ngx_array_t.jpg" alt=""></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://tengine.taobao.org/book/chapter_02.html#ngx-array-t-100" target="_blank" rel="external">http://tengine.taobao.org/book/chapter_02.html#ngx-array-t-100</a><br><a href="http://blog.csdn.net/livelylittlefish/article/details/6599056" target="_blank" rel="external">http://blog.csdn.net/livelylittlefish/article/details/6599056</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Nginx模块基础数据结构————ngx_array_t。&lt;br&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://github.com/Sword2G/sword2g.github.io/categories/Linux/"/>
    
    
      <category term="Nginx" scheme="https://github.com/Sword2G/sword2g.github.io/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>Nginx 模块开发————Hello XX</title>
    <link href="https://github.com/Sword2G/sword2g.github.io/2016/09/17/nginx-module-dev/"/>
    <id>https://github.com/Sword2G/sword2g.github.io/2016/09/17/nginx-module-dev/</id>
    <published>2016-09-17T15:41:12.000Z</published>
    <updated>2017-05-08T10:08:54.255Z</updated>
    
    <content type="html"><![CDATA[<p>编写一个 nginx handler 模块实现 hello XX。<br><a id="more"></a></p>
<p>nginx handler 编写步骤如下：</p>
<ul>
<li><p>编写模块基本结构，包括模块的配置结构模块上下文结构，模块的定义等。</p>
</li>
<li><p>实现handler的挂载函数，根据模块的需求选择正确的挂载方式。</p>
</li>
<li><p>编写handler处理函数，模块的功能主要通过这个函数来完成。</p>
</li>
</ul>
<h1 id="模块配置结构"><a href="#模块配置结构" class="headerlink" title="模块配置结构"></a>模块配置结构</h1><p>每个模块都会提供一些配置指令，以便于用户可以通过配置来控制该模块的行为。<br>用于存放模块配置信息的结构，命名习惯是ngx<em>http</em><em>module name</em>_(main|srv|loc)_conf_t,如这里的hello模块的配置信息结构定义如下<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">ngx_str_t</span> hello_string;</div><div class="line">&#125;<span class="keyword">ngx_http_hello_loc_conf_t</span>;</div></pre></td></tr></table></figure></p>
<h1 id="模块配置指令（commands-数组）"><a href="#模块配置指令（commands-数组）" class="headerlink" title="模块配置指令（commands 数组）"></a>模块配置指令（commands 数组）</h1><p>commands 数组用于模块配置指令的定义。数组中的每一个元素都是ngx_command_t类型，数组的结尾用ngx_null_command结束。Nginx在解析配置文件的时候，会通过遍历每一个模块的commands数组来解析遇到的指令，当遇到 ngx_null_command 时，会停止当前模块指令的解析。</p>
<h2 id="ngx-command-t-定义"><a href="#ngx-command-t-定义" class="headerlink" title="ngx_command_t 定义"></a>ngx_command_t 定义</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> ngx_command_s <span class="keyword">ngx_command_t</span>;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> ngx_command_s &#123;</div><div class="line">	<span class="comment">// 配置指令的名称</span></div><div class="line">    <span class="keyword">ngx_str_t</span>             name;</div><div class="line">    <span class="comment">// 配置的类型(详细介绍如下)</span></div><div class="line">    <span class="keyword">ngx_uint_t</span>            type;</div><div class="line">    <span class="comment">// 出现name 指令时会调用set方法来处理配置参数(详细介绍如下)</span></div><div class="line">    <span class="keyword">char</span>               *(*<span class="built_in">set</span>)(<span class="keyword">ngx_conf_t</span> *cf, <span class="keyword">ngx_command_t</span> *cmd, <span class="keyword">void</span> *conf);</div><div class="line">    </div><div class="line">    <span class="keyword">ngx_uint_t</span>            conf;</div><div class="line"></div><div class="line">    <span class="keyword">ngx_uint_t</span>            offset;</div><div class="line"> </div><div class="line">    <span class="keyword">void</span>                 *post;</div><div class="line">    <span class="comment">/*</span></div><div class="line">    该字段存储一个指针。可以指向任何一个在读取配置过程中需要的数据，以便于进行配置读取的处理。大多数时候，都不需要，所以简单地设为0即可。</div><div class="line">    */</div><div class="line">&#125;;</div><div class="line"></div><div class="line">##<span class="meta"># type参数</span></div><div class="line"></div><div class="line">该配置的类型，其实更准确一点说，是该配置指令属性的集合。nginx提供了很多预定义的属性值（一些宏定义），通过逻辑或运算符可组合在一起，形成对这个配置指令的详细的说明。下面列出可在这里使用的预定义属性值及说明。</div><div class="line">NGX_CONF_NOARGS：配置指令不接受任何参数。</div><div class="line">NGX_CONF_TAKE1：配置指令接受<span class="number">1</span>个参数。</div><div class="line">NGX_CONF_TAKE2：配置指令接受<span class="number">2</span>个参数。</div><div class="line">NGX_CONF_TAKE3：配置指令接受<span class="number">3</span>个参数。</div><div class="line">NGX_CONF_TAKE4：配置指令接受<span class="number">4</span>个参数。</div><div class="line">NGX_CONF_TAKE5：配置指令接受<span class="number">5</span>个参数。</div><div class="line">NGX_CONF_TAKE6：配置指令接受<span class="number">6</span>个参数。</div><div class="line">NGX_CONF_TAKE7：配置指令接受<span class="number">7</span>个参数。</div><div class="line"></div><div class="line">可以组合多个属性，比如一个指令即可以不填参数，也可以接受<span class="number">1</span>个或者<span class="number">2</span>个参数。那么就是NGX_CONF_NOARGS|NGX_CONF_TAKE1|NGX_CONF_TAKE2。如果写上面三个属性在一起，你觉得麻烦，那么没有关系，nginx提供了一些定义，使用起来更简洁。</div><div class="line"></div><div class="line">NGX_CONF_TAKE12：配置指令接受<span class="number">1</span>个或者<span class="number">2</span>个参数。</div><div class="line">NGX_CONF_TAKE13：配置指令接受<span class="number">1</span>个或者<span class="number">3</span>个参数。</div><div class="line">NGX_CONF_TAKE23：配置指令接受<span class="number">2</span>个或者<span class="number">3</span>个参数。</div><div class="line">NGX_CONF_TAKE123：配置指令接受<span class="number">1</span>个或者<span class="number">2</span>个或者<span class="number">3</span>参数。</div><div class="line">NGX_CONF_TAKE1234：配置指令接受<span class="number">1</span>个或者<span class="number">2</span>个或者<span class="number">3</span>个或者<span class="number">4</span>个参数。</div><div class="line">NGX_CONF_1MORE：配置指令接受至少一个参数。</div><div class="line">NGX_CONF_2MORE：配置指令接受至少两个参数。</div><div class="line">NGX_CONF_MULTI: 配置指令可以接受多个参数，即个数不定。</div><div class="line">NGX_CONF_BLOCK：配置指令可以接受的值是一个配置信息块。也就是一对大括号括起来的内容。里面可以再包括很多的配置指令。比如常见的server指令就是这个属性的。</div><div class="line"></div><div class="line">NGX_CONF_FLAG：配置指令可以接受的值是”on”或者”off”，最终会被转成<span class="keyword">bool</span>值。</div><div class="line"></div><div class="line">NGX_CONF_ANY：配置指令可以接受的任意的参数值。一个或者多个，或者”on”或者”off”，或者是配置块。</div><div class="line"></div><div class="line">最后要说明的是，无论如何，nginx的配置指令的参数个数不可以超过NGX_CONF_MAX_ARGS个。目前这个值被定义为<span class="number">8</span>，也就是不能超过<span class="number">8</span>个参数值。</div><div class="line"></div><div class="line">下面介绍一组说明配置指令可以出现的位置的属性。</div><div class="line">NGX_DIRECT_CONF：可以出现在配置文件中最外层。例如已经提供的配置指令daemon，master_process等。</div><div class="line">NGX_MAIN_CONF: http、mail、events、error_log等。</div><div class="line">NGX_ANY_CONF: 该配置指令可以出现在任意配置级别上。</div><div class="line"></div><div class="line">对于我们编写的大多数模块而言，都是在处理http相关的事情，也就是所谓的都是NGX_HTTP_MODULE，对于这样类型的模块，其配置可能出现的位置也是分为直接出现在http里面，以及其他位置。</div><div class="line"></div><div class="line">NGX_HTTP_MAIN_CONF: 可以直接出现在http配置指令里。</div><div class="line">NGX_HTTP_SRV_CONF: 可以出现在http里面的server配置指令里。</div><div class="line">NGX_HTTP_LOC_CONF: 可以出现在http server块里面的location配置指令里。</div><div class="line">NGX_HTTP_UPS_CONF: 可以出现在http里面的upstream配置指令里。</div><div class="line">NGX_HTTP_SIF_CONF: 可以出现在http里面的server配置指令里的<span class="keyword">if</span>语句所在的block中。</div><div class="line">NGX_HTTP_LMT_CONF: 可以出现在http里面的limit_except指令的block中。</div><div class="line">NGX_HTTP_LIF_CONF: 可以出现在http server块里面的location配置指令里的<span class="keyword">if</span>语句所在的block中。</div><div class="line"></div><div class="line"></div><div class="line">##<span class="meta"># set 参数 </span></div><div class="line"></div><div class="line"><span class="keyword">char</span> *(*<span class="built_in">set</span>)(<span class="keyword">ngx_conf_t</span> *cf, <span class="keyword">ngx_command_t</span> *cmd, <span class="keyword">void</span> *conf);</div><div class="line"></div><div class="line">函数处理成功时，返回NGX_OK，否则返回NGX_CONF_ERROR或者是一个自定义的错误信息的字符串。</div><div class="line">cf: 该参数里面保存从配置文件读取到的原始字符串以及相关的一些信息。特别注意的是这个参数的args字段是一个<span class="keyword">ngx_str_t</span>类型的数组，该数组的首个元素是这个配置指令本身，第二个元素是指令的第一个参数，第三个元素是第二个参数，依次类推。</div><div class="line">cmd: 这个配置指令对应的<span class="keyword">ngx_command_t</span>结构。</div><div class="line">conf: 就是定义的存储这个配置值的结构体，比如在上面展示的那个<span class="keyword">ngx_http_hello_loc_conf_t</span>。当解析这个hello_string变量的时候，传入的conf就指向一个<span class="keyword">ngx_http_hello_loc_conf_t</span>类型的变量。</div><div class="line"></div><div class="line">预定义的<span class="built_in">set</span>：</div><div class="line">ngx_conf_set_flag_slot： 读取NGX_CONF_FLAG类型的参数。</div><div class="line">ngx_conf_set_str_slot:读取字符串类型的参数。</div><div class="line">ngx_conf_set_str_array_slot: 读取字符串数组类型的参数。</div><div class="line">ngx_conf_set_keyval_slot： 读取键值对类型的参数。</div><div class="line">ngx_conf_set_num_slot: 读取整数类型(有符号整数<span class="keyword">ngx_int_t</span>)的参数。</div><div class="line">ngx_conf_set_size_slot:读取<span class="keyword">size_t</span>类型的参数，也就是无符号数。</div><div class="line">ngx_conf_set_off_slot: 读取<span class="keyword">off_t</span>类型的参数。</div><div class="line">ngx_conf_set_msec_slot: 读取毫秒值类型的参数。</div><div class="line">ngx_conf_set_sec_slot: 读取秒值类型的参数。</div><div class="line">ngx_conf_set_bufs_slot： 读取的参数值是<span class="number">2</span>个，一个是buf的个数，一个是buf的大小。例如： output_buffers <span class="number">1</span> <span class="number">128</span>k;</div><div class="line">ngx_conf_set_enum_slot: 读取枚举类型的参数，将其转换成整数<span class="keyword">ngx_uint_t</span>类型。</div><div class="line">ngx_conf_set_bitmask_slot: 读取参数的值，并将这些参数的值以bit位的形式存储。例如：HttpDavModule模块的dav_methods指令。</div></pre></td></tr></table></figure>
<h3 id="conf-参数"><a href="#conf-参数" class="headerlink" title="conf 参数"></a>conf 参数</h3><p>该字段指定当前配置项存储的内存位置。实际上是使用哪个内存池的问题。因为http模块对所有http模块所要保存的配置信息，划分了main, server和location三个地方进行存储，每个地方都有一个内存池用来分配存储这些信息的内存。这里可能的值为 NGX_HTTP_MAIN_CONF_OFFSET、NGX_HTTP_SRV_CONF_OFFSET或NGX_HTTP_LOC_CONF_OFFSET。当然也可以直接置为0，就是NGX_HTTP_MAIN_CONF_OFFSET。</p>
<h3 id="offset-参数"><a href="#offset-参数" class="headerlink" title="offset 参数"></a>offset 参数</h3><p>指定该配置项值的精确存放位置，一般指定为某一个结构体变量的字段偏移。因为对于配置信息的存储，一般我们都是定义个结构体来存储的。那么比如我们定义了一个结构体A，该项配置的值需要存储到该结构体的b字段。那么在这里就可以填写为offsetof(A, b)。对于有些配置项，它的值不需要保存或者是需要保存到更为复杂的结构中时，这里可以设置为0。</p>
<h2 id="hello-commands-数组定义"><a href="#hello-commands-数组定义" class="headerlink" title="hello commands 数组定义"></a>hello commands 数组定义</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">ngx_command_t</span> ngx_http_hello_commands[] = &#123;  </div><div class="line">    &#123;  </div><div class="line">        ngx_string(<span class="string">"hello_string"</span>),  </div><div class="line">        NGX_HTTP_MAIN_CONF | NGX_HTTP_SRV_CONF | NGX_HTTP_LOC_CONF | NGX_HTTP_LMT_CONF | NGX_CONF_NOARGS,  </div><div class="line">        ngx_http_hello,        <span class="comment">// 出现hello配置项时，调用ngx_http_hello解析  </span></div><div class="line">        NGX_HTTP_LOC_CONF_OFFSET,  </div><div class="line">        <span class="comment">// ngx_http_hello_loc_conf_t 为模块配置信息结构</span></div><div class="line">        <span class="number">0</span>;</div><div class="line">        <span class="comment">//offsetof(ngx_http_hello_loc_conf_t, hello_string), </span></div><div class="line">        <span class="literal">NULL</span>,  </div><div class="line">    &#125;,  </div><div class="line">    ngx_null_command            <span class="comment">// 以一个空的ngx_command_t作为结尾  </span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h2 id="hello-set-函数定义"><a href="#hello-set-函数定义" class="headerlink" title="hello set 函数定义"></a>hello set 函数定义</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">char</span>* <span class="title">ngx_http_hello</span><span class="params">(<span class="keyword">ngx_conf_t</span> *cf, <span class="keyword">ngx_command_t</span> *cmd, <span class="keyword">void</span> *conf)</span>  </span></div><div class="line">&#123;  </div><div class="line">    <span class="keyword">ngx_http_core_loc_conf_t</span> *clcf;  </div><div class="line">    </div><div class="line">    <span class="comment">// 找到hello配置项所属的配置块  </span></div><div class="line">    clcf = ngx_http_conf_get_module_loc_conf(cf, ngx_http_core_module);  </div><div class="line">    </div><div class="line">    <span class="comment">// 设置处理请求的方法，HTTP框架在处理用户请求进行到NGX_HTTP_CONTENT_PHASE阶段时  </span></div><div class="line">    <span class="comment">// 如果主机域名、URI和hello模块所在配置块名称相同，就会调用函数ngx_http_hello_handler  </span></div><div class="line">    clcf-&gt;handler = ngx_http_hello_handler;</div><div class="line">    <span class="comment">//读取字符串类型参数  </span></div><div class="line">    ngx_conf_set_str_slot(cf, cmd, conf);</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> NGX_CONF_OK;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="模块上下文结构"><a href="#模块上下文结构" class="headerlink" title="模块上下文结构"></a>模块上下文结构</h1><p>模块上下文是一个ngx_http_module_t类型的静态变量。这个变量实际上是提供一组回调函数指针，这些函数有在创建存储配置信息的对象的函数，也有在创建前和创建后会调用的函数。这些函数都将被nginx在合适的时间进行调用。</p>
<h2 id="ngx-http-module-t-定义"><a href="#ngx-http-module-t-定义" class="headerlink" title="ngx_http_module_t 定义"></a>ngx_http_module_t 定义</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</div><div class="line">	<span class="comment">// 在创建和读取该模块的配置信息之前被调用</span></div><div class="line">    <span class="keyword">ngx_int_t</span>   (*preconfiguration)(<span class="keyword">ngx_conf_t</span> *cf);</div><div class="line">    <span class="comment">// 在创建和读取该模块的配置信息之后被调用</span></div><div class="line">    <span class="keyword">ngx_int_t</span>   (*postconfiguration)(<span class="keyword">ngx_conf_t</span> *cf);</div><div class="line">    <span class="comment">// 调用该函数创建本模块位于http block的配置信息存储结构。该函数成功的时候，返回创建的配置对象。失败的话，返回NULL</span></div><div class="line">    <span class="keyword">void</span>       *(*create_main_conf)(<span class="keyword">ngx_conf_t</span> *cf);</div><div class="line"></div><div class="line">    <span class="keyword">char</span>       *(*init_main_conf)(<span class="keyword">ngx_conf_t</span> *cf, <span class="keyword">void</span> *conf);</div><div class="line">    <span class="comment">/*</span></div><div class="line">    调用该函数初始化本模块位于http block的配置信息存储结构。该函数成功的时候，返回NGX_CONF_OK。失败的话，返回NGX_CONF_ERROR或错误字符串。</div><div class="line">    */</div><div class="line"></div><div class="line">    <span class="keyword">void</span>       *(*create_srv_conf)(<span class="keyword">ngx_conf_t</span> *cf);</div><div class="line">    <span class="comment">/*</span></div><div class="line">    调用该函数创建本模块位于http server block的配置信息存储结构，每个server block会创建一个。该函数成功的时候，返回创建的配置对象。失败的话，返回NULL。</div><div class="line">    */</div><div class="line"></div><div class="line">    <span class="keyword">char</span>       *(*merge_srv_conf)(<span class="keyword">ngx_conf_t</span> *cf, <span class="keyword">void</span> *prev, <span class="keyword">void</span> *conf);</div><div class="line">    <span class="comment">/*</span></div><div class="line">    因为有些配置指令既可以出现在http block，也可以出现在http server block中。那么遇到这种情况，每个server都会有自己存储结构来存储该server的配置，但是在这种情况下http block中的配置与server block中的配置信息发生冲突的时候，就需要调用此函数进行合并，该函数并非必须提供，当预计到绝对不会发生需要合并的情况的时候，就无需提供。当然为了安全起见还是建议提供。该函数执行成功的时候，返回NGX_CONF_OK。失败的话，返回NGX_CONF_ERROR或错误字符串。</div><div class="line">    */</div><div class="line"></div><div class="line">    <span class="keyword">void</span>       *(*create_loc_conf)(<span class="keyword">ngx_conf_t</span> *cf);</div><div class="line">    <span class="comment">/*</span></div><div class="line">    调用该函数创建本模块位于location block的配置信息存储结构。每个在配置中指明的location创建一个。该函数执行成功，返回创建的配置对象。失败的话，返回NULL。</div><div class="line">    */</div><div class="line"></div><div class="line">    <span class="comment">// 与 merge_srv_conf 类似。</span></div><div class="line">    <span class="keyword">char</span>       *(*merge_loc_conf)(<span class="keyword">ngx_conf_t</span> *cf, <span class="keyword">void</span> *prev, <span class="keyword">void</span> *conf);</div><div class="line">&#125; <span class="keyword">ngx_http_module_t</span>;</div></pre></td></tr></table></figure>
<h2 id="hello-上下文结构定义"><a href="#hello-上下文结构定义" class="headerlink" title="hello 上下文结构定义"></a>hello 上下文结构定义</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">ngx_http_module_t</span> ngx_http_hello_module_ctx = &#123;</div><div class="line">    <span class="literal">NULL</span>,                          <span class="comment">/* preconfiguration */</span></div><div class="line">    <span class="literal">NULL</span>,           <span class="comment">/* postconfiguration */</span></div><div class="line"></div><div class="line">    <span class="literal">NULL</span>,                          <span class="comment">/* create main configuration */</span></div><div class="line">    <span class="literal">NULL</span>,                          <span class="comment">/* init main configuration */</span></div><div class="line"></div><div class="line">    <span class="literal">NULL</span>,                          <span class="comment">/* create server configuration */</span></div><div class="line">    <span class="literal">NULL</span>,                          <span class="comment">/* merge server configuration */</span></div><div class="line"></div><div class="line">    ngx_http_hello_create_loc_conf, <span class="comment">/* create location configuration */</span></div><div class="line">    ngx_http_hello_merge_loc_conf                        <span class="comment">/* merge location configuration */</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h1 id="模块的定义"><a href="#模块的定义" class="headerlink" title="模块的定义"></a>模块的定义</h1><p>每一个模块都需要定义一个ngx_module_t类型的变量来说明这个模块相关信息，比如定义的配置信息、模块的上下文信息，都是通过这个结构来告诉nginx系统的，也就是加载模块的上层代码，都需要通过定义的这个结构，来获取这些信息。</p>
<h2 id="ngx-module-t-定义"><a href="#ngx-module-t-定义" class="headerlink" title="ngx_module_t 定义"></a>ngx_module_t 定义</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> ngx_module_s &#123;  </div><div class="line">    <span class="keyword">ngx_uint_t</span>            ctx_index;    <span class="comment">/* 当前模块在同类模块中的序号 */</span>  </div><div class="line">    <span class="keyword">ngx_uint_t</span>            index;        <span class="comment">/* 当前模块在ngx_modules数组中的序号 */</span>  </div><div class="line">   </div><div class="line">    <span class="keyword">ngx_uint_t</span>            spare0;       <span class="comment">/* 保留 */</span>  </div><div class="line">    <span class="keyword">ngx_uint_t</span>            spare1;       <span class="comment">/* 保留 */</span>  </div><div class="line">    <span class="keyword">ngx_uint_t</span>            spare2;       <span class="comment">/* 保留 */</span>  </div><div class="line">    <span class="keyword">ngx_uint_t</span>            spare3;       <span class="comment">/* 保留 */</span>  </div><div class="line">   </div><div class="line">    <span class="keyword">ngx_uint_t</span>            version;      <span class="comment">/* 模块版本，目前为1 */</span>  </div><div class="line">   </div><div class="line">    <span class="keyword">void</span>                 *ctx;          <span class="comment">/* 指向特定类型模块的公共接口 */</span>  </div><div class="line">    <span class="keyword">ngx_command_t</span>        *commands;     <span class="comment">/* 用于处理配置文件nginx.conf中的配置项 */</span>  </div><div class="line">    <span class="keyword">ngx_uint_t</span>            type;         <span class="comment">/* 当前模块类型 */</span>  </div><div class="line">   </div><div class="line">    <span class="comment">/* 以下7个函数指针表示7个执行点，这些执行点将在Nginx启动和退出过程中被调用 </span></div><div class="line">     * 如果不需要则设置为NULL </div><div class="line">     */  </div><div class="line">    <span class="keyword">ngx_int_t</span>           (*init_master)(<span class="keyword">ngx_log_t</span> *<span class="built_in">log</span>);     <span class="comment">/* 从未被调用，设为NULL */</span>  </div><div class="line">   </div><div class="line">    <span class="keyword">ngx_int_t</span>           (*init_module)(<span class="keyword">ngx_cycle_t</span> *cycle); <span class="comment">/* 启动worker子进程前调用 */</span>  </div><div class="line">   </div><div class="line">    <span class="keyword">ngx_int_t</span>           (*init_process)(<span class="keyword">ngx_cycle_t</span> *cycle);<span class="comment">/* 启动worker子进程后调用 */</span>  </div><div class="line">    <span class="keyword">ngx_int_t</span>           (*init_thread)(<span class="keyword">ngx_cycle_t</span> *cycle); <span class="comment">/* 从未被调用，设为NULL */</span>  </div><div class="line">    <span class="keyword">void</span>                (*exit_thread)(<span class="keyword">ngx_cycle_t</span> *cycle); <span class="comment">/* 从未被调用，设为NULL */</span>  </div><div class="line">    <span class="keyword">void</span>                (*exit_process)(<span class="keyword">ngx_cycle_t</span> *cycle);<span class="comment">/* worker子进程推出前调用 */</span>  </div><div class="line">   </div><div class="line">    <span class="keyword">void</span>                (*exit_master)(<span class="keyword">ngx_cycle_t</span> *cycle); <span class="comment">/* master进程退出前调用 */</span>  </div><div class="line">   </div><div class="line">    <span class="comment">/* 以下全为保留字段 */</span>  </div><div class="line">    <span class="keyword">uintptr_t</span>             spare_hook0;  </div><div class="line">    <span class="keyword">uintptr_t</span>             spare_hook1;  </div><div class="line">    <span class="keyword">uintptr_t</span>             spare_hook2;  </div><div class="line">    <span class="keyword">uintptr_t</span>             spare_hook3;  </div><div class="line">    <span class="keyword">uintptr_t</span>             spare_hook4;  </div><div class="line">    <span class="keyword">uintptr_t</span>             spare_hook5;  </div><div class="line">    <span class="keyword">uintptr_t</span>             spare_hook6;  </div><div class="line">    <span class="keyword">uintptr_t</span>             spare_hook7;  </div><div class="line">&#125;;  </div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> NGX_NUMBER_MAJOR  3</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> NGX_NUMBER_MINOR  1</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> NGX_MODULE_V1          0, 0, 0, 0,                              \</span></div><div class="line">    NGX_DSO_ABI_COMPATIBILITY, NGX_NUMBER_MAJOR, NGX_NUMBER_MINOR</div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> NGX_MODULE_V1_PADDING  0, 0, 0, 0, 0, 0, 0, 0</span></div></pre></td></tr></table></figure>
<h2 id="helloworld-模块定义"><a href="#helloworld-模块定义" class="headerlink" title="helloworld 模块定义"></a>helloworld 模块定义</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">ngx_module_t</span> ngx_http_hello_module = &#123;</div><div class="line">    NGX_MODULE_V1,</div><div class="line">    &amp;ngx_http_hello_module_ctx,    <span class="comment">/* module context */</span></div><div class="line">    ngx_http_hello_commands,       <span class="comment">/* module directives */</span></div><div class="line">    NGX_HTTP_MODULE,               <span class="comment">/* module type */</span></div><div class="line">    <span class="literal">NULL</span>,                          <span class="comment">/* init master */</span></div><div class="line">    <span class="literal">NULL</span>,                          <span class="comment">/* init module */</span></div><div class="line">    <span class="literal">NULL</span>,                          <span class="comment">/* init process */</span></div><div class="line">    <span class="literal">NULL</span>,                          <span class="comment">/* init thread */</span></div><div class="line">    <span class="literal">NULL</span>,                          <span class="comment">/* exit thread */</span></div><div class="line">    <span class="literal">NULL</span>,                          <span class="comment">/* exit process */</span></div><div class="line">    <span class="literal">NULL</span>,                          <span class="comment">/* exit master */</span></div><div class="line">    NGX_MODULE_V1_PADDING</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h1 id="handler-的定义"><a href="#handler-的定义" class="headerlink" title="handler 的定义"></a>handler 的定义</h1><p>handler模块必须提供一个真正的处理函数，这个函数负责对来自客户端请求的真正处理。这个函数的处理，既可以选择自己直接生成内容，也可以选择拒绝处理，由后续的handler去进行处理，或者是选择丢给后续的filter进行处理。来看一下这个函数的原型申明。</p>
<h2 id="handler-原型"><a href="#handler-原型" class="headerlink" title="handler 原型"></a>handler 原型</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">ngx_int_t</span> <span class="params">(*ngx_http_handler_pt)</span><span class="params">(<span class="keyword">ngx_http_request_t</span> *r)</span></span>;</div><div class="line"></div><div class="line">r是http请求,里面包含请求所有的信息。 该函数处理成功返回NGX_OK，处理发生错误返回NGX_ERROR，拒绝处理（留给后续的handler进行处理）返回NGX_DECLINE。 返回NGX_OK也就代表给客户端的响应已经生成好了，否则返回NGX_ERROR就发生错误了。</div></pre></td></tr></table></figure>
<h1 id="handler-挂载"><a href="#handler-挂载" class="headerlink" title="handler 挂载"></a>handler 挂载</h1><p>hello模块的handler挂在在set函数中完成了挂载。</p>
<h2 id="hello-模块-handler-定义"><a href="#hello-模块-handler-定义" class="headerlink" title="hello 模块 handler 定义"></a>hello 模块 handler 定义</h2><figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line">static ngx_int_t ngx_http_hello_handler(ngx_http_request_t* r) &#123;</div><div class="line">    ngx_int_t rc;</div><div class="line">    ngx_buf_t* b;</div><div class="line">    <span class="comment">//构造发送时的ngx_chain_t结构体</span></div><div class="line">    ngx_chain_t out[<span class="number">2</span>];</div><div class="line"></div><div class="line">    ngx_http_hello_world_loc_conf_t* hlcf;</div><div class="line">    hlcf = ngx_http_get_module_loc_conf(r, ngx_http_hello_world_module);</div><div class="line"></div><div class="line">    <span class="comment">/* allocate a buffer for your response body */</span></div><div class="line">    <span class="function"><span class="title">b</span> = ngx_pcalloc(r-&gt;</span>pool, sizeof(ngx_buf_t));</div><div class="line">    <span class="keyword">if</span> (b == NULL) &#123;</div><div class="line">            return NGX_HTTP_INTERNAL_SERVER_ERROR;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    out[<span class="number">0</span>].buf = b;</div><div class="line">    out[<span class="number">0</span>].next = &amp;out[<span class="number">1</span>];</div><div class="line"></div><div class="line">    <span class="function"><span class="title">b</span>-&gt;</span>pos = (u_char*)<span class="string">"hello, "</span>;</div><div class="line">    <span class="comment">//设置last指针</span></div><div class="line">    <span class="function"><span class="title">b</span>-&gt;</span><span class="function"><span class="title">last</span> = b-&gt;</span>pos + sizeof(<span class="string">"hello, "</span>) - <span class="number">1</span>;</div><div class="line">    <span class="comment">/* this buffer is in memory */</span></div><div class="line">    <span class="function"><span class="title">b</span>-&gt;</span>memory = <span class="number">1</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="title">b</span> = ngx_pcalloc(r-&gt;</span>pool, sizeof(ngx_buf_t));</div><div class="line">    <span class="keyword">if</span> (b == NULL) &#123;</div><div class="line">            return NGX_HTTP_INTERNAL_SERVER_ERROR;</div><div class="line">    &#125;</div><div class="line">    out[<span class="number">1</span>].buf = b;</div><div class="line">    out[<span class="number">1</span>].next = NULL;</div><div class="line"></div><div class="line">    <span class="comment">//获得hello指定的参数值</span></div><div class="line">    <span class="function"><span class="title">b</span>-&gt;</span><span class="function"><span class="title">pos</span> = hlcf-&gt;</span>hello_string.<span class="keyword">data</span>;</div><div class="line">    <span class="function"><span class="title">b</span>-&gt;</span><span class="function"><span class="title">last</span> = hlcf-&gt;</span><span class="function"><span class="title">hello_string</span>.<span class="keyword">data</span> + (hlcf-&gt;</span>hello_string.len);</div><div class="line">    <span class="function"><span class="title">b</span>-&gt;</span>memory = <span class="number">1</span>;</div><div class="line">    <span class="comment">//声明这是最后一块缓冲区</span></div><div class="line">    <span class="function"><span class="title">b</span>-&gt;</span>last_buf = <span class="number">1</span>;</div><div class="line"></div><div class="line">    <span class="comment">//设置响应体头部</span></div><div class="line">    <span class="function"><span class="title">r</span>-&gt;</span>headers_out.status = NGX_HTTP_OK;</div><div class="line">    <span class="comment">//设置Content-Type</span></div><div class="line">    <span class="function"><span class="title">ngx_str_set</span>(&amp;r-&gt;</span>headers_out.content_type, <span class="string">"text/html"</span>);</div><div class="line">    <span class="comment">//响应包是有包体内容的，所以需要设置Content-Length长度</span></div><div class="line">    <span class="function"><span class="title">r</span>-&gt;</span><span class="function"><span class="title">headers_out</span>.content_length_n =  sizeof("hello, ") + hlcf-&gt;</span>hello_string.len - <span class="number">1</span>;</div><div class="line">    <span class="comment">//发送http头部</span></div><div class="line">    rc = ngx_http_send_header(r);</div><div class="line">    <span class="function"><span class="title">if</span> (rc == NGX_ERROR || rc &gt; NGX_OK || r-&gt;</span>header_only) &#123;</div><div class="line">        return rc;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 向用户发送响应包  </span></div><div class="line">    return ngx_http_output_filter(r, &amp;out[<span class="number">0</span>]);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="模块编译使用"><a href="#模块编译使用" class="headerlink" title="模块编译使用"></a>模块编译使用</h1><h2 id="config文件"><a href="#config文件" class="headerlink" title="config文件"></a>config文件</h2><p>对于开发一个模块，我们是需要把这个模块的C代码组织到一个目录里，同时需要编写一个config文件。这个config文件的内容就是告诉nginx的编译脚本，该如何进行编译。<br><figure class="highlight ini"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="attr">ngx_addon_name</span>=ngx_http_hello_module</div><div class="line"><span class="attr">HTTP_MODULES</span>=<span class="string">"$HTTP_MODULES ngx_http_hello_module"</span></div><div class="line"><span class="attr">NGX_ADDON_SRCS</span>=<span class="string">"$NGX_ADDON_SRCS $ngx_addon_dir/ngx_http_hello_module.c"</span></div></pre></td></tr></table></figure></p>
<p>其实文件很简单，几乎不需要做什么解释。大家一看都懂了。唯一需要说明的是，如果这个模块的实现有多个源文件，那么都在NGX_ADDON_SRCS这个变量里，依次写进去就可以。</p>
<h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>对于模块的编译，nginx并不像apache一样，提供了单独的编译工具，可以在没有apache源代码的情况下来单独编译一个模块的代码。nginx必须去到nginx的源代码目录里，通过configure指令的参数，来进行编译。下面看一下hello module的configure指令：<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">.<span class="regexp">/configure –prefix=/u</span>sr<span class="regexp">/local/</span>nginx –add-module=<span class="regexp">/your/m</span>odule<span class="regexp">/path/</span>ngx_http_hello_world_module</div><div class="line">make</div></pre></td></tr></table></figure></p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>nginx 配置如下：<br><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">location</span> <span class="title">/hello</span> &#123;</div><div class="line">                hello_string world;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>访问 <a href="http://127.0.0.1/hello的时候，就可以看到页面显示&quot;hello" target="_blank" rel="external">http://127.0.0.1/hello的时候，就可以看到页面显示&quot;hello</a>, world”。</p>
<h1 id="完整的-helloXX-模块代码"><a href="#完整的-helloXX-模块代码" class="headerlink" title="完整的 helloXX 模块代码"></a>完整的 helloXX 模块代码</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div></pre></td><td class="code"><pre><div class="line">include &lt;ngx_config.h&gt;</div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ngx_core.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ngx_http.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">char</span>* <span class="title">ngx_http_hello</span><span class="params">(<span class="keyword">ngx_conf_t</span> *cf, <span class="keyword">ngx_command_t</span> *cmd, <span class="keyword">void</span> *conf)</span></span>;</div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">ngx_http_hello_create_loc_conf</span><span class="params">(<span class="keyword">ngx_conf_t</span>* cf)</span></span>;</div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">char</span>* <span class="title">ngx_http_hello_merge_loc_conf</span><span class="params">(<span class="keyword">ngx_conf_t</span>* cf, <span class="keyword">void</span>* parent, <span class="keyword">void</span>* child)</span></span>;</div><div class="line"><span class="function"><span class="keyword">static</span> ngx_int_t <span class="title">ngx_http_hello_handler</span><span class="params">(<span class="keyword">ngx_http_request_t</span>* r)</span></span>;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">ngx_str_t</span> hello_string;</div><div class="line">&#125;<span class="keyword">ngx_http_hello_loc_conf_t</span>;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">ngx_command_t</span> ngx_http_hello_commands[] = &#123;  </div><div class="line">    &#123;  </div><div class="line">        ngx_string(<span class="string">"hello_string"</span>),  </div><div class="line">        NGX_HTTP_MAIN_CONF | NGX_HTTP_SRV_CONF | NGX_HTTP_LOC_CONF | NGX_HTTP_LMT_CONF | NGX_CONF_NOARGS,  </div><div class="line">        ngx_http_hello,        <span class="comment">// 出现hello配置项时，调用ngx_http_hello解析  </span></div><div class="line">        NGX_HTTP_LOC_CONF_OFFSET,  </div><div class="line">        <span class="comment">// ngx_http_hello_loc_conf_t 为模块配置信息结构</span></div><div class="line">        <span class="number">0</span>;</div><div class="line">        <span class="comment">//offsetof(ngx_http_hello_loc_conf_t, hello_string), </span></div><div class="line">        <span class="literal">NULL</span>,  </div><div class="line">    &#125;,  </div><div class="line">    ngx_null_command            <span class="comment">// 以一个空的ngx_command_t作为结尾  </span></div><div class="line">&#125;;  </div><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">char</span>* <span class="title">ngx_http_hello</span><span class="params">(<span class="keyword">ngx_conf_t</span> *cf, <span class="keyword">ngx_command_t</span> *cmd, <span class="keyword">void</span> *conf)</span>  </span></div><div class="line">&#123;  </div><div class="line">    <span class="keyword">ngx_http_core_loc_conf_t</span> *clcf;  </div><div class="line">    </div><div class="line">    <span class="comment">// 找到hello配置项所属的配置块  </span></div><div class="line">    clcf = ngx_http_conf_get_module_loc_conf(cf, ngx_http_core_module);  </div><div class="line">    </div><div class="line">    <span class="comment">// 设置处理请求的方法，HTTP框架在处理用户请求进行到NGX_HTTP_CONTENT_PHASE阶段时  </span></div><div class="line">    <span class="comment">// 如果主机域名、URI和hello模块所在配置块名称相同，就会调用函数ngx_http_hello_handler  </span></div><div class="line">    clcf-&gt;handler = ngx_http_hello_handler;</div><div class="line">    <span class="comment">//读取字符串类型参数  </span></div><div class="line">    ngx_conf_set_str_slot(cf, cmd, conf);</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> NGX_CONF_OK;  </div><div class="line">&#125; </div><div class="line"></div><div class="line"><span class="keyword">ngx_module_t</span> ngx_http_hello_module = &#123;</div><div class="line">    NGX_MODULE_V1,</div><div class="line">    &amp;ngx_http_hello_module_ctx,    <span class="comment">/* module context */</span></div><div class="line">    ngx_http_hello_commands,       <span class="comment">/* module directives */</span></div><div class="line">    NGX_HTTP_MODULE,               <span class="comment">/* module type */</span></div><div class="line">    <span class="literal">NULL</span>,                          <span class="comment">/* init master */</span></div><div class="line">    <span class="literal">NULL</span>,                          <span class="comment">/* init module */</span></div><div class="line">    <span class="literal">NULL</span>,                          <span class="comment">/* init process */</span></div><div class="line">    <span class="literal">NULL</span>,                          <span class="comment">/* init thread */</span></div><div class="line">    <span class="literal">NULL</span>,                          <span class="comment">/* exit thread */</span></div><div class="line">    <span class="literal">NULL</span>,                          <span class="comment">/* exit process */</span></div><div class="line">    <span class="literal">NULL</span>,                          <span class="comment">/* exit master */</span></div><div class="line">    NGX_MODULE_V1_PADDING</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">ngx_http_module_t</span> ngx_http_hello_module_ctx = &#123;</div><div class="line">    <span class="literal">NULL</span>,                          <span class="comment">/* preconfiguration */</span></div><div class="line">    <span class="literal">NULL</span>,           <span class="comment">/* postconfiguration */</span></div><div class="line"></div><div class="line">    <span class="literal">NULL</span>,                          <span class="comment">/* create main configuration */</span></div><div class="line">    <span class="literal">NULL</span>,                          <span class="comment">/* init main configuration */</span></div><div class="line"></div><div class="line">    <span class="literal">NULL</span>,                          <span class="comment">/* create server configuration */</span></div><div class="line">    <span class="literal">NULL</span>,                          <span class="comment">/* merge server configuration */</span></div><div class="line"></div><div class="line">    ngx_http_hello_create_loc_conf, <span class="comment">/* create location configuration */</span></div><div class="line">    ngx_http_hello_merge_loc_conf                        <span class="comment">/* merge location configuration */</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> ngx_int_t <span class="title">ngx_http_hello_handler</span><span class="params">(<span class="keyword">ngx_http_request_t</span>* r)</span> </span>&#123;</div><div class="line">    <span class="keyword">ngx_int_t</span> rc;</div><div class="line">    <span class="keyword">ngx_buf_t</span>* b;</div><div class="line">    <span class="comment">//构造发送时的ngx_chain_t结构体</span></div><div class="line">    <span class="keyword">ngx_chain_t</span> out[<span class="number">2</span>];</div><div class="line"></div><div class="line">    <span class="keyword">ngx_http_hello_world_loc_conf_t</span>* hlcf;</div><div class="line">    hlcf = ngx_http_get_module_loc_conf(r, ngx_http_hello_world_module);</div><div class="line"></div><div class="line">    <span class="comment">/* allocate a buffer for your response body */</span></div><div class="line">    b = ngx_pcalloc(r-&gt;pool, <span class="keyword">sizeof</span>(<span class="keyword">ngx_buf_t</span>));</div><div class="line">    <span class="keyword">if</span> (b == <span class="literal">NULL</span>) &#123;</div><div class="line">            <span class="keyword">return</span> NGX_HTTP_INTERNAL_SERVER_ERROR;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    out[<span class="number">0</span>].buf = b;</div><div class="line">    out[<span class="number">0</span>].next = &amp;out[<span class="number">1</span>];</div><div class="line"></div><div class="line">    b-&gt;pos = (u_char*)<span class="string">"hello, "</span>;</div><div class="line">    <span class="comment">//设置last指针</span></div><div class="line">    b-&gt;last = b-&gt;pos + <span class="keyword">sizeof</span>(<span class="string">"hello, "</span>) - <span class="number">1</span>;</div><div class="line">    <span class="comment">/* this buffer is in memory */</span></div><div class="line">    b-&gt;memory = <span class="number">1</span>;</div><div class="line"></div><div class="line">    b = ngx_pcalloc(r-&gt;pool, <span class="keyword">sizeof</span>(<span class="keyword">ngx_buf_t</span>));</div><div class="line">    <span class="keyword">if</span> (b == <span class="literal">NULL</span>) &#123;</div><div class="line">            <span class="keyword">return</span> NGX_HTTP_INTERNAL_SERVER_ERROR;</div><div class="line">    &#125;</div><div class="line">    out[<span class="number">1</span>].buf = b;</div><div class="line">    out[<span class="number">1</span>].next = <span class="literal">NULL</span>;</div><div class="line"></div><div class="line">    <span class="comment">//获得hello指定的参数值</span></div><div class="line">    b-&gt;pos = hlcf-&gt;hello_string.data;</div><div class="line">    b-&gt;last = hlcf-&gt;hello_string.data + (hlcf-&gt;hello_string.len);</div><div class="line">    b-&gt;memory = <span class="number">1</span>;</div><div class="line">    <span class="comment">//声明这是最后一块缓冲区</span></div><div class="line">    b-&gt;last_buf = <span class="number">1</span>;</div><div class="line"></div><div class="line">    <span class="comment">//设置响应体头部</span></div><div class="line">    r-&gt;headers_out.status = NGX_HTTP_OK;</div><div class="line">    <span class="comment">//设置Content-Type</span></div><div class="line">    ngx_str_set(&amp;r-&gt;headers_out.content_type, <span class="string">"text/html"</span>);</div><div class="line">    <span class="comment">//响应包是有包体内容的，所以需要设置Content-Length长度</span></div><div class="line">    r-&gt;headers_out.content_length_n =  <span class="keyword">sizeof</span>(<span class="string">"hello, "</span>) + hlcf-&gt;hello_string.len - <span class="number">1</span>;</div><div class="line">    <span class="comment">//发送http头部</span></div><div class="line">    rc = ngx_http_send_header(r);</div><div class="line">    <span class="keyword">if</span> (rc == NGX_ERROR || rc &gt; NGX_OK || r-&gt;header_only) &#123;</div><div class="line">        <span class="keyword">return</span> rc;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 向用户发送响应包  </span></div><div class="line">    <span class="keyword">return</span> ngx_http_output_filter(r, &amp;out[<span class="number">0</span>]);</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">ngx_http_hello_create_loc_conf</span><span class="params">(<span class="keyword">ngx_conf_t</span>* cf)</span> </span>&#123;</div><div class="line">    <span class="keyword">ngx_http_hello_world_loc_conf_t</span>* conf;</div><div class="line"></div><div class="line">    conf = ngx_pcalloc(cf-&gt;pool, <span class="keyword">sizeof</span>(<span class="keyword">ngx_http_hello_world_loc_conf_t</span>));</div><div class="line">    <span class="keyword">if</span> (conf == <span class="literal">NULL</span>) &#123;</div><div class="line">        <span class="keyword">return</span> NGX_CONF_ERROR;</div><div class="line">    &#125;</div><div class="line">    conf-&gt;hello_string.len = <span class="number">0</span>;</div><div class="line">    conf-&gt;hello_string.data = <span class="literal">NULL</span>;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> conf;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">char</span>* <span class="title">ngx_http_hello_merge_loc_conf</span><span class="params">(<span class="keyword">ngx_conf_t</span>* cf, <span class="keyword">void</span>* parent, <span class="keyword">void</span>* child)</span> </span>&#123;</div><div class="line">    <span class="keyword">ngx_http_hello_world_loc_conf_t</span>* prev = parent;</div><div class="line">    <span class="keyword">ngx_http_hello_world_loc_conf_t</span>* conf = child;</div><div class="line">    ngx_conf_merge_str_value(conf-&gt;hello_string, prev-&gt;hello_string, <span class="string">"Nginx"</span>);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> NGX_CONF_OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://tengine.taobao.org/book/chapter_03.html" target="_blank" rel="external">http://tengine.taobao.org/book/chapter_03.html</a><br><a href="http://blog.csdn.net/nestler/article/details/31825335" target="_blank" rel="external">http://blog.csdn.net/nestler/article/details/31825335</a><br><a href="http://blog.csdn.net/poechant/article/details/7627828" target="_blank" rel="external">http://blog.csdn.net/poechant/article/details/7627828</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;编写一个 nginx handler 模块实现 hello XX。&lt;br&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://github.com/Sword2G/sword2g.github.io/categories/Linux/"/>
    
    
      <category term="Nginx" scheme="https://github.com/Sword2G/sword2g.github.io/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>Nginx 基础数据结构(二)</title>
    <link href="https://github.com/Sword2G/sword2g.github.io/2016/09/16/nginx-datastructure-ngx_chain_t-ngx_buf_t/"/>
    <id>https://github.com/Sword2G/sword2g.github.io/2016/09/16/nginx-datastructure-ngx_chain_t-ngx_buf_t/</id>
    <published>2016-09-16T07:45:25.000Z</published>
    <updated>2017-03-25T16:04:33.413Z</updated>
    
    <content type="html"><![CDATA[<p>Nginx模块基础数据结构————ngx_chain_t、ngx_buf_t。<br><a id="more"></a></p>
<h1 id="ngx-chain-t"><a href="#ngx-chain-t" class="headerlink" title="ngx_chain_t"></a>ngx_chain_t</h1><p>nginx中很多的数据都需要通过ngx_chain_t结构进行保存。 如 nginx 的filter模块在处理从别的filter模块或者是handler模块传递过来的数据（实际上就是需要发送给客户端的http response）。这个传递过来的数据是以一个链表的形式(ngx_chain_t)。而且数据可能被分多次传递过来。也就是多次调用filter的处理函数，以不同的ngx_chain_t。ngx_chain_t 是 ngx_chain_t的节点。</p>
<h2 id="ngx-chain-t定义"><a href="#ngx-chain-t定义" class="headerlink" title="ngx_chain_t定义"></a>ngx_chain_t定义</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> ngx_chain_s       <span class="keyword">ngx_chain_t</span>;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> ngx_chain_s &#123;</div><div class="line">	<span class="comment">// buf指向当前的ngx_buf_t缓冲区(实际的数据)</span></div><div class="line">    <span class="keyword">ngx_buf_t</span>    *buf;</div><div class="line">    <span class="comment">// next指向这个链表的下个节点</span></div><div class="line">    <span class="keyword">ngx_chain_t</span>  *next;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h2 id="ngx-chain-t-api"><a href="#ngx-chain-t-api" class="headerlink" title="ngx_chain_t api"></a>ngx_chain_t api</h2><figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//该函数创建一个ngx_chain_t的对象，并返回指向对象的指针，失败返回NULL。</span></div><div class="line">ngx_chain_t *ngx_alloc_chain_link(ngx_pool_t *pool);</div><div class="line"></div><div class="line"><span class="comment">//该宏释放一个ngx_chain_t类型的对象。如果要释放整个chain，则迭代此链表，对每个节点使用此宏即可。</span></div><div class="line">#define ngx_free_chain(pool, cl)                                             \</div><div class="line">    <span class="function"><span class="title">cl</span>-&gt;</span><span class="function"><span class="title">next</span> = pool-&gt;</span>chain;                                                  \</div><div class="line"><span class="function"><span class="title">pool</span>-&gt;</span>chain = cl</div></pre></td></tr></table></figure>
<p><strong><br>注意: 对ngx_chaint_t类型的释放，并不是真的释放了内存，而仅仅是把这个对象挂在了这个pool对象的一个叫做chain的字段对应的chain上，以供下次从这个pool上分配ngx_chain_t类型对象的时候，快速的从这个pool-&gt;chain上取下链首元素就返回了，当然，如果这个链是空的，才会真的在这个pool上使用ngx_palloc函数进行分配。
</strong></p>
<h1 id="ngx-buf-t"><a href="#ngx-buf-t" class="headerlink" title="ngx_buf_t"></a>ngx_buf_t</h1><p>ngx_buf_t就是这个ngx_chain_t链表的每个节点的实际数据。该结构实际上是一种抽象的数据结构，它代表某种具体的数据。这个数据可能是指向内存中的某个缓冲区，也可能指向一个文件的某一部分，也可能是一些纯元数据（元数据的作用在于指示这个链表的读取者对读取的数据进行不同的处理）。</p>
<h2 id="ngx-buf-t定义"><a href="#ngx-buf-t定义" class="headerlink" title="ngx_buf_t定义"></a>ngx_buf_t定义</h2><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line">typedef struct ngx_buf_s         ngx_buf_t<span class="comment">;</span></div><div class="line">    </div><div class="line">struct ngx_buf_s &#123;</div><div class="line">    <span class="comment">/*当前读取buffer位置*/</span></div><div class="line">    u_char          *pos<span class="comment">; </span></div><div class="line">    <span class="comment">/*实际占用buffer的最后位置*/</span></div><div class="line">    u_char          *last<span class="comment">;</span></div><div class="line">    <span class="comment">/*当前读取文件位置*/</span></div><div class="line">    off_t            file_pos<span class="comment">;</span></div><div class="line">    <span class="comment">/*文件最后位置*/</span></div><div class="line">    off_t            file_last<span class="comment">;</span></div><div class="line">    </div><div class="line">    <span class="comment">/*buffer开始位置*/</span></div><div class="line">    u_char          *start<span class="comment">;</span></div><div class="line">    <span class="comment">/*buffer结束位置*/</span>  </div><div class="line">    u_char          *end<span class="comment">;</span></div><div class="line">    <span class="comment">/*内存标记,实际上是一个void*类型的指针，使用者可以关联任意的对象上去，只要对使用者有意义。*/</span></div><div class="line">    ngx_buf_tag_t    tag<span class="comment">;</span></div><div class="line">    <span class="comment">/*当buf所包含的内容在文件中时，file字段指向对应的文件对象*/</span></div><div class="line">    ngx_file_t      *file<span class="comment">;</span></div><div class="line">    <span class="comment">/*</span></div><div class="line">    当这个buf完整copy了另外一个buf的所有字段的时候，那么这两个buf指向的实际上是同一块内存，或者是同一个文件的同一部分，此时这两个buf的shadow字段都是指向对方的。那么对于这样的两个buf，在释放的时候，就需要使用者特别小心，具体是由哪里释放，要提前考虑好，如果造成资源的多次释放，可能会造成程序崩溃！</div><div class="line">    */</div><div class="line">    ngx_buf_t       *<span class="keyword">shadow;</span></div><div class="line">    </div><div class="line">    <span class="comment">/*1表示内存可以修改,表示该buf所包含的内容是在一个用户创建的内存块中，并且可以被在filter处理的过程中进行变更，而不会造成问题*/</span></div><div class="line">    unsigned         temporary:<span class="number">1</span><span class="comment">;</span></div><div class="line">    <span class="comment">/*1表示该buf所包含的内容是在内存中，但是这些内容却不能被进行处理的filter进行变更*/</span></div><div class="line">    unsigned         memory:<span class="number">1</span><span class="comment">;</span></div><div class="line"></div><div class="line">    <span class="comment">/*1表示操作内容通过mmap()函数映射不可修改*/</span></div><div class="line">    unsigned         mmap:<span class="number">1</span><span class="comment">;</span></div><div class="line">    <span class="comment">/*1表示内存可以回收*/</span></div><div class="line">    unsigned         recycled:<span class="number">1</span><span class="comment">;</span></div><div class="line">    <span class="comment">/*1表示操作内容在文件中*/</span></div><div class="line">    unsigned         in_file:<span class="number">1</span><span class="comment">;</span></div><div class="line">    <span class="comment">/*1表示立即将内容发送出去*/</span></div><div class="line">    unsigned         flush:<span class="number">1</span><span class="comment">;</span></div><div class="line">    <span class="comment">/*1表示立即将内容同步发送出去*/</span></div><div class="line">    unsigned         <span class="keyword">sync:1;</span></div><div class="line">    <span class="comment">/*标记chain是否为最后一块buf*/</span></div><div class="line">    unsigned         last_buf:<span class="number">1</span><span class="comment">;</span></div><div class="line">    <span class="comment">/*标记chain中是否为最后一个chain，最后一块buf并不表示是最后一个chain，但最后一个chain一定是最后一块buf*/</span></div><div class="line">    unsigned         last_in_chain:<span class="number">1</span><span class="comment">;</span></div><div class="line">    <span class="comment">/* 标志位，在创建一个buf的shadow的时候，通常将新创建的一个buf的last_shadow置为1 */</span></div><div class="line">    unsigned         last_shadow:<span class="number">1</span><span class="comment">;</span></div><div class="line">    <span class="comment">/* 标志位，表示当前缓冲区是否属于临时文件,由于受到内存使用的限制，有时候一些buf的内容需要被写到磁盘上的临时文件中去 */</span></div><div class="line">    unsigned         temp_file:<span class="number">1</span><span class="comment">;</span></div><div class="line"></div><div class="line">    <span class="comment">/* STUB */</span> int   num<span class="comment">;</span></div><div class="line">&#125;<span class="comment">;</span></div></pre></td></tr></table></figure>
<h2 id="ngx-buf-t-api"><a href="#ngx-buf-t-api" class="headerlink" title="ngx_buf_t api"></a>ngx_buf_t api</h2><figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">ngx_buf_t *ngx_create_temp_buf(ngx_pool_t *pool, size_t size);</div><div class="line"><span class="comment">/*</span></div><div class="line">该函数创建一个ngx_but_t类型的对象，并返回指向这个对象的指针，创建失败返回NULL，temporary字段为1。</div><div class="line">对于创建的这个对象，它的start和end指向新分配内存开始和结束的地方。pos和last都指向这块新分配内存的开始处，这样，后续的操作可以在这块新分配的内存上存入数据。</div><div class="line">pool:	分配该buf和buf使用的内存所使用的pool。</div><div class="line">size:	该buf使用的内存的大小。</div><div class="line">为了配合对ngx_buf_t的使用，nginx定义了以下的宏方便操作。</div><div class="line">*/</div><div class="line"></div><div class="line">#<span class="function"><span class="title">define</span> ngx_buf_in_memory(b)        (b-&gt;</span><span class="function"><span class="title">temporary</span> || b-&gt;</span><span class="function"><span class="title">memory</span> || b-&gt;</span>mmap)</div><div class="line"><span class="comment">/*</span></div><div class="line">返回这个buf里面的内容是否在内存里。</div><div class="line">*/</div><div class="line">#<span class="function"><span class="title">define</span> ngx_buf_in_memory_only(b)   (ngx_buf_in_memory(b) &amp;&amp; !b-&gt;</span>in_file)</div><div class="line"><span class="comment">/*</span></div><div class="line">返回这个buf里面的内容是否仅仅在内存里，并且没有在文件里。</div><div class="line">*/</div><div class="line">#define ngx_buf_special(b)                                                   \</div><div class="line">    ((<span class="function"><span class="title">b</span>-&gt;</span><span class="function"><span class="title">flush</span> || b-&gt;</span><span class="function"><span class="title">last_buf</span> || b-&gt;</span>sync)                                    \</div><div class="line">     &amp;&amp; !<span class="function"><span class="title">ngx_buf_in_memory</span>(b) &amp;&amp; !b-&gt;</span>in_file)</div><div class="line"><span class="comment">/*</span></div><div class="line">返回该buf是否是一个特殊的buf，只含有特殊的标志和没有包含真正的数据。</div><div class="line">*/</div><div class="line">#define ngx_buf_sync_only(b)                                                 \</div><div class="line">    (<span class="function"><span class="title">b</span>-&gt;</span>sync                                                                 \</div><div class="line">     &amp;&amp; !<span class="function"><span class="title">ngx_buf_in_memory</span>(b) &amp;&amp; !b-&gt;</span><span class="function"><span class="title">in_file</span> &amp;&amp; !b-&gt;</span><span class="function"><span class="title">flush</span> &amp;&amp; !b-&gt;</span>last_buf)</div><div class="line"><span class="comment">/*</span></div><div class="line">返回该buf是否是一个只包含sync标志而不包含真正数据的特殊buf。</div><div class="line">*/</div><div class="line">#define ngx_buf_size(b)                                                      \</div><div class="line">    (<span class="function"><span class="title">ngx_buf_in_memory</span>(b) ? (off_t) (b-&gt;</span><span class="function"><span class="title">last</span> - b-&gt;</span>pos):                      \</div><div class="line">                            (<span class="function"><span class="title">b</span>-&gt;</span><span class="function"><span class="title">file_last</span> - b-&gt;</span>file_pos))</div><div class="line"><span class="comment">/*</span></div><div class="line">返回该buf所含数据的大小，不管这个数据是在文件里还是在内存里。</div><div class="line">*/</div></pre></td></tr></table></figure>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://tengine.taobao.org/book/chapter_02.html#ngx-chain-t-100" target="_blank" rel="external">http://tengine.taobao.org/book/chapter_02.html#ngx-chain-t-100</a><br><a href="http://www.cnblogs.com/ourroad/p/4838794.html" target="_blank" rel="external">http://www.cnblogs.com/ourroad/p/4838794.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Nginx模块基础数据结构————ngx_chain_t、ngx_buf_t。&lt;br&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://github.com/Sword2G/sword2g.github.io/categories/Linux/"/>
    
    
      <category term="Nginx" scheme="https://github.com/Sword2G/sword2g.github.io/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>Nginx 基础数据结构(一)</title>
    <link href="https://github.com/Sword2G/sword2g.github.io/2016/09/15/nginx-datastructure-ngx_str_t-ngx_pool_t/"/>
    <id>https://github.com/Sword2G/sword2g.github.io/2016/09/15/nginx-datastructure-ngx_str_t-ngx_pool_t/</id>
    <published>2016-09-15T07:45:25.000Z</published>
    <updated>2017-03-25T15:39:30.796Z</updated>
    
    <content type="html"><![CDATA[<p>Nginx模块基础数据结构————ngx_str_t、ngx_pool_t。<br><a id="more"></a></p>
<h1 id="ngx-str-t"><a href="#ngx-str-t" class="headerlink" title="ngx_str_t"></a>ngx_str_t</h1><h2 id="ngx-str-t定义"><a href="#ngx-str-t定义" class="headerlink" title="ngx_str_t定义"></a>ngx_str_t定义</h2><p>ngx_str_t是nginx中的字符串结构，其定义如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;  </div><div class="line">    <span class="keyword">size_t</span>      len;  </div><div class="line">    u_char     *data;  </div><div class="line">&#125; <span class="keyword">ngx_str_t</span>;</div></pre></td></tr></table></figure></p>
<p>data指向字符串数据的第一个字符，字符串的结束用长度来表示，而不是由’\0’来表示结束。<br>这种字符串结构设计有两个好处：</p>
<ol>
<li>减少计算字符串长度的次数</li>
<li>nginx可以重复引用一段字符串内存,而不用去copy一份自己的字符串(因为如果要以’\0’结束，而不能更改原字符串，所以势必要copy一段字符串)</li>
</ol>
<h2 id="ngx-str-t-api"><a href="#ngx-str-t-api" class="headerlink" title="ngx_str_t api"></a>ngx_str_t api</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 通过一个以’\0’结尾的普通常量字符串str构造一个nginx的字符串,能用于赋值时初始化</span></div><div class="line">#define ngx_string(<span class="keyword">str</span>)     &#123; <span class="keyword">sizeof</span>(<span class="keyword">str</span>) - <span class="number">1</span>, (u_char *) <span class="keyword">str</span> &#125;</div><div class="line"></div><div class="line"><span class="comment">// 初始化字符串为空字符串，符串的长度为0，data为NULL,能用于赋值时初始化</span></div><div class="line">#define ngx_null_string     &#123; <span class="number">0</span>, NULL &#125;</div><div class="line"></div><div class="line"><span class="comment">// 用于设置字符串str为常量字符串text</span></div><div class="line">#define ngx_str_set(<span class="keyword">str</span>, text)                                               \</div><div class="line">    (<span class="keyword">str</span>)-&gt;len = <span class="keyword">sizeof</span>(text) - <span class="number">1</span>; (<span class="keyword">str</span>)-&gt;data = (u_char *) text</div><div class="line"></div><div class="line"><span class="comment">// 用于设置字符串str为空串，长度为0，data为NULL</span></div><div class="line">#define ngx_str_null(<span class="keyword">str</span>)   (<span class="keyword">str</span>)-&gt;len = <span class="number">0</span>; (<span class="keyword">str</span>)-&gt;data = NULL</div><div class="line"></div><div class="line">void ngx_strlow(u_char *dst, u_char *src, size_t n);</div><div class="line">将src的前n个字符转换成小写存放在dst字符串当中，调用者需要保证dst指向的空间大于等于n，且指向的空间必须可写</div><div class="line"></div><div class="line"><span class="comment">// 区分大小写的字符串比较，只比较前n个字符</span></div><div class="line">ngx_strncmp(s1, s2, n)</div><div class="line"></div><div class="line"><span class="comment">// 区分大小写的不带长度的字符串比较</span></div><div class="line">ngx_int_t ngx_strcasecmp(u_char *s1, u_char *s2);</div><div class="line"></div><div class="line"><span class="comment">//不区分大小写的不带长度的字符串比较</span></div><div class="line">ngx_int_t ngx_strncasecmp(u_char *s1, u_char *s2, size_t n);</div></pre></td></tr></table></figure>
<h1 id="ngx-pool-t"><a href="#ngx-pool-t" class="headerlink" title="ngx_pool_t"></a>ngx_pool_t</h1><p>ngx_pool_t是一个非常重要的数据结构，它提供了一种机制，帮助管理一系列的资源（如内存，文件等），使得对这些资源的使用和释放统一进行，免除了使用过程中考虑到对各种各样资源的什么时候释放，是否遗漏了释放的担心。</p>
<p>例如对于内存的管理，如果我们需要使用内存，那么总是从一个ngx_pool_t的对象中获取内存，在最终的某个时刻，我们销毁这个ngx_pool_t对象，所有这些内存都被释放了。这样我们就不必要对对这些内存进行malloc和free的操作，不用担心是否某块被malloc出来的内存没有被释放。因为当ngx_pool_t对象被销毁的时候，所有从这个对象中分配出来的内存都会被统一释放掉。</p>
<p>再比如我们要使用一系列的文件，但是我们打开以后，最终需要都关闭，那么我们就把这些文件统一登记到一个ngx_pool_t对象中，当这个ngx_pool_t对象被销毁的时候，所有这些文件都将会被关闭。</p>
<p>也就是说，所有当我们使用一个ngx_pool_t对象来管理多个资源时，被管理的对象是一起释放的。</p>
<h2 id="ngx-pool-t定义"><a href="#ngx-pool-t定义" class="headerlink" title="ngx_pool_t定义"></a>ngx_pool_t定义</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> ngx_pool_s      <span class="keyword">ngx_pool_t</span>;  </div><div class="line">  </div><div class="line"><span class="comment">//该结构维护整个内存池的头部信息  </span></div><div class="line"><span class="keyword">struct</span> ngx_pool_s &#123;     </div><div class="line">	<span class="keyword">ngx_pool_data_t</span>       d;       <span class="comment">//数据块     </span></div><div class="line">	<span class="keyword">size_t</span>                max;     <span class="comment">//内存池数据块的最大值    </span></div><div class="line">	<span class="keyword">ngx_pool_t</span>           *current; <span class="comment">//指向当前内存池   </span></div><div class="line">	<span class="keyword">ngx_chain_t</span>          *chain;   <span class="comment">//该指针挂接一个ngx_chain_t结构       </span></div><div class="line">	<span class="keyword">ngx_pool_large_t</span>     *large;   <span class="comment">//分配大块内存用，即超过max的内存请求     </span></div><div class="line">	<span class="keyword">ngx_pool_cleanup_t</span>   *cleanup; <span class="comment">//释放内存池的callback     </span></div><div class="line">	<span class="keyword">ngx_log_t</span>            *<span class="built_in">log</span>;     <span class="comment">//日志信息  </span></div><div class="line">&#125;; </div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// ngx_pool_data_t 内存池数据块结构</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</div><div class="line">	<span class="comment">//是一个unsigned char 类型的指针，保存的是/当前内存池分配到末位地址，即下一次分配从此处开始。</span></div><div class="line">    u_char               *last;        </div><div class="line">    <span class="comment">//内存池结束位置；</span></div><div class="line">    u_char               *end;</div><div class="line">    <span class="comment">//内存池里面有很多块内存，这些内存块就是通过该指针连成链表的，next指向下一块内存。</span></div><div class="line">    <span class="keyword">ngx_pool_t</span>           *next;</div><div class="line">    <span class="comment">//内存池分配失败次数</span></div><div class="line">    <span class="keyword">ngx_uint_t</span>           failed;</div><div class="line"> &#125; <span class="keyword">ngx_pool_data_t</span>;</div><div class="line"></div><div class="line"><span class="comment">// ngx_chain_t 缓冲区链表</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> ngx_chain_s       <span class="keyword">ngx_chain_t</span>;</div><div class="line"><span class="keyword">struct</span> ngx_chain_s &#123;</div><div class="line">	<span class="comment">//buf指向当前的ngx_buf_t缓冲区,ngx_buf_t为节点</span></div><div class="line">    <span class="keyword">ngx_buf_t</span>    *buf;  </div><div class="line">    <span class="comment">//next指向下一个ngx_chain_t，如果这是最后一个ngx_chain_t，则next为NULL      </span></div><div class="line">    <span class="keyword">ngx_chain_t</span>  *next;       </div><div class="line"> &#125;;</div><div class="line"></div><div class="line"><span class="comment">//ngx_pool_large_t 大内存结构</span></div><div class="line"><span class="keyword">struct</span> ngx_pool_large_s &#123;  </div><div class="line">	<span class="comment">//下一个大块内存 </span></div><div class="line">    <span class="keyword">ngx_pool_large_t</span>     *next;  </div><div class="line">    <span class="comment">//指向分配的大块内存 </span></div><div class="line">    <span class="keyword">void</span>                 *alloc; </div><div class="line">&#125;;  </div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> ngx_pool_cleanup_s  <span class="keyword">ngx_pool_cleanup_t</span>;</div><div class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*ngx_pool_cleanup_pt)</span><span class="params">(<span class="keyword">void</span> *data)</span></span>;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> ngx_pool_cleanup_s &#123;</div><div class="line">	<span class="comment">//函数指针，指向一个可以释放data所对应资源的函数。该函数只有一个参数，就是data</span></div><div class="line">    ngx_pool_cleanup_pt   handler;</div><div class="line">    <span class="comment">//该节点所对应的资源</span></div><div class="line">    <span class="keyword">void</span>                 *data;</div><div class="line">    <span class="comment">//该链表中下一个元素</span></div><div class="line">    <span class="keyword">ngx_pool_cleanup_t</span>   *next;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h2 id="ngx-pool-t-组织结构"><a href="#ngx-pool-t-组织结构" class="headerlink" title="ngx_pool_t 组织结构"></a>ngx_pool_t 组织结构</h2><p><img src="http://7xum8m.com1.z0.glb.clouddn.com/hexo-ngx-structure-ngx_pool_t.jpg" alt="ngx_pool_t"></p>
<h2 id="ngx-pool-t-api"><a href="#ngx-pool-t-api" class="headerlink" title="ngx_pool_t api"></a>ngx_pool_t api</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">ngx_pool_t</span> *ngx_create_pool(<span class="keyword">size_t</span> size, <span class="keyword">ngx_log_t</span> *<span class="built_in">log</span>)</div><div class="line"><span class="comment">/*</span></div><div class="line">创建一个初始节点大小为size的pool，log为后续在该pool上进行操作时输出日志的对象。 需要说明的是size的选择，size的大小必须小于等于NGX_MAX_ALLOC_FROM_POOL，且必须大于sizeof(ngx_pool_t)。</div><div class="line"></div><div class="line">选择大于NGX_MAX_ALLOC_FROM_POOL的值会造成浪费，因为大于该限制的空间不会被用到（只是说在第一个由ngx_pool_t对象管理的内存块上的内存，后续的分配如果第一个内存块上的空闲部分已用完，会再分配的）。</div><div class="line"></div><div class="line">选择小于sizeof(ngx_pool_t)的值会造成程序崩溃。由于初始大小的内存块中要用一部分来存储ngx_pool_t这个信息本身。</div><div class="line"></div><div class="line">当一个ngx_pool_t对象被创建以后，该对象的max字段被赋值为size-sizeof(ngx_pool_t)和NGX_MAX_ALLOC_FROM_POOL这两者中比较小的。后续的从这个pool中分配的内存块，在第一块内存使用完成以后，如果要继续分配的话，就需要继续从操作系统申请内存。当内存的大小小于等于max字段的时候，则分配新的内存块，链接在d这个字段（实际上是d.next字段）管理的一条链表上。当要分配的内存块是比max大的，那么从系统中申请的内存是被挂接在large字段管理的一条链表上</div><div class="line">*/</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> *<span class="title">ngx_palloc</span><span class="params">(<span class="keyword">ngx_pool_t</span> *pool, <span class="keyword">size_t</span> size)</span></span></div><div class="line"><span class="comment">/*</span></div><div class="line">从这个pool中分配一块为size大小的内存,分配的内存的起始地址按照NGX_ALIGNMENT进行对齐。对齐操作会提高系统处理的速度，但会造成少量内存的浪费。</div><div class="line">*/</div><div class="line"></div><div class="line"><span class="keyword">void</span> *<span class="title">ngx_pnalloc</span><span class="params">(<span class="keyword">ngx_pool_t</span> *pool, <span class="keyword">size_t</span> size)</span></div><div class="line"><span class="comment">/*</span></div><div class="line">从这个pool中分配一块为size大小的内存,不对齐</div><div class="line">*/</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">void</span> *<span class="title">ngx_pcalloc</span><span class="params">(<span class="keyword">ngx_pool_t</span> *pool, <span class="keyword">size_t</span> size)</span></div><div class="line"><span class="comment">/*</span></div><div class="line">该函数也是分配size大小的内存，并且对分配的内存块进行了清零。内部实际上是转调用ngx_palloc实现的</div><div class="line">*/</div><div class="line"></div><div class="line"><span class="keyword">void</span> *<span class="title">ngx_pmemalign</span><span class="params">(<span class="keyword">ngx_pool_t</span> *pool, <span class="keyword">size_t</span> size, <span class="keyword">size_t</span> alignment)</span></div><div class="line"><span class="comment">/*</span></div><div class="line">按照指定对齐大小alignment来申请一块大小为size的内存。此处获取的内存不管大小都将被置于大内存块链中管理</div><div class="line">*/</div><div class="line"></div><div class="line">ngx_int_t <span class="title">ngx_pfree</span><span class="params">(<span class="keyword">ngx_pool_t</span> *pool, <span class="keyword">void</span> *p)</span></div><div class="line"><span class="comment">/*</span></div><div class="line">对于被置于大块内存链，也就是被large字段管理的一列内存中的某块进行释放。该函数的实现是顺序遍历large管理的大块内存链表。所以效率比较低下。如果在这个链表中找到了这块内存，则释放，并返回NGX_OK。否则返回NGX_DECLINED。由于这个操作效率比较低下，除非必要，也就是说这块内存非常大，确应及时释放，否则一般不需要调用</div><div class="line">*/</div><div class="line"></div><div class="line">ngx_pool_cleanup_t *<span class="title">ngx_pool_cleanup_add</span><span class="params">(<span class="keyword">ngx_pool_t</span> *p, <span class="keyword">size_t</span> size)</span></div><div class="line"><span class="comment">/*</span></div><div class="line">ngx_pool_t中的cleanup字段管理着一个特殊的链表，该链表的每一项都记录着一个特殊的需要释放的资源。对于这个链表中每个节点所包含的资源如何去释放，是自说明的。这也就提供了非常大的灵活性。</div><div class="line">*/</div><div class="line"></div><div class="line">oid <span class="title">ngx_destroy_pool</span><span class="params">(<span class="keyword">ngx_pool_t</span> *pool)</span>;</div><div class="line"><span class="comment">/*</span></div><div class="line">释放pool中持有的所有内存，以及依次调用cleanup字段所管理的链表中每个元素的handler字段所指向的函数，来释放掉所有该pool管理的资源。并且把pool指向的ngx_pool_t也释放掉了，完全不可用了。</div><div class="line">*/</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">ngx_reset_pool</span><span class="params">(<span class="keyword">ngx_pool_t</span> *pool)</span></span>;</div><div class="line"><span class="comment">/*</span></div><div class="line">释放pool中所有大块内存链表上的内存，小块内存链上的内存块都修改为可用。但是不会去处理cleanup链表上的项目。</div><div class="line">*/</div></pre></td></tr></table></figure>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://blog.csdn.net/chen19870707/article/details/41015613" target="_blank" rel="external">http://blog.csdn.net/chen19870707/article/details/41015613</a><br><a href="http://blog.csdn.net/daniel_ustc/article/details/11645293" target="_blank" rel="external">http://blog.csdn.net/daniel_ustc/article/details/11645293</a><br><a href="http://tengine.taobao.org/book/chapter_02.html" target="_blank" rel="external">http://tengine.taobao.org/book/chapter_02.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Nginx模块基础数据结构————ngx_str_t、ngx_pool_t。&lt;br&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://github.com/Sword2G/sword2g.github.io/categories/Linux/"/>
    
    
      <category term="Nginx" scheme="https://github.com/Sword2G/sword2g.github.io/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>Nginx 的高并发性</title>
    <link href="https://github.com/Sword2G/sword2g.github.io/2016/09/10/nginx-concurrency/"/>
    <id>https://github.com/Sword2G/sword2g.github.io/2016/09/10/nginx-concurrency/</id>
    <published>2016-09-10T04:31:19.000Z</published>
    <updated>2017-05-08T10:09:45.894Z</updated>
    
    <content type="html"><![CDATA[<p>Nginx的高并发性取决于它的进程模型和事件模型，最主要的原因是 Nginx worker 进程异步非阻塞的处理方式。<br><a id="more"></a></p>
<h1 id="Nginx-进程模型"><a href="#Nginx-进程模型" class="headerlink" title="Nginx 进程模型"></a>Nginx 进程模型</h1><p>Nginx默认的工作方式是多进程，启动后会有一个master进程和多个worker进程。<br><img src="http://7xum8m.com1.z0.glb.clouddn.com/hexo-nginx-processers.png" alt="Nginx进程模型"></p>
<h2 id="master-进程"><a href="#master-进程" class="headerlink" title="master 进程"></a>master 进程</h2><p>master 进程充当整个进程组与用户的交互接口，主要充当管理者，用来管理worker进程（接收来自外界的信号，向各worker进程发送信号，监控 worker 进程的运行状态，当 worker 进程异常退出后，会自动重新启动新的 worker 进程）。它不需要处理网络事件，不负责业务的执行，只会通过管理 worker 进程来实现重启服务、平滑升级、更换日志文件、配置文件实时生效等功能。要想对 nginx 进行管理，只要和 master 进程通信就可以了，master进程会接收来自外界发来的信号，再根据信号做不同的事情。比如 kill -HUP pid，则是告诉 nginx，从容地重启 n ginx，我们一般用这个信号来重启 nginx，或重新加载配置，因为是从容地重启，因此服务是不中断的。master进程在接收到HUP信号后，首先会先重新加载配置文件，然后再启动新的 worker 进程，并向所有老的 worker 进程发送信号，告诉他们可以光荣退休了。新的 worker 在启动后，就开始接收新的请求，而老的 worker 在收到来自 master 的信号后，就不再接收新的请求，并且在当前进程中的所有未处理完的请求处理完成后，再退出。</p>
<h2 id="worker-进程"><a href="#worker-进程" class="headerlink" title="worker 进程"></a>worker 进程</h2><p>worker 进程主要用来处理各个基本的网络事件。<strong>每个 worker 进程里面只有一个主线程</strong>。多个 worker 进程之间是对等的，他们同等竞争来自客户端的请求，各进程互相之间是独立的。一个请求，只可能在一个 worker进程中处理，一个 worker 进程，不可能处理其它进程的请求。当一个 worker 进程在获得处理请求的机会后，就开始读取请求，解析请求，处理请求，产生数据后，再返回给客户端，最后才断开连接，这样一个完整的请求就是这样的了。我们可以看到，一个请求，完全由一个worker进程来处理，不涉及其他 worker 进程。worker 进程的个数是可以设置的，一般我们会设置与机器 cpu 核数一致。</p>
<h1 id="Nginx-事件模型"><a href="#Nginx-事件模型" class="headerlink" title="Nginx 事件模型"></a>Nginx 事件模型</h1><p>worker 进程只有一个主线程，并不代表它只可以并发的处理一个请求。原因在与 Nginx 的 worker 进程采用<strong>异步非阻塞</strong>的方式来处理请求，也就是说，nginx 是可以同时处理成千上万个请求的。一个 worker 进程可以同时处理的请求数只受限于内存大小。<a href="http://ilingling.cc/2016/05/13/I-O-Models/" target="_blank" rel="external">关于IO模型</a></p>
<h1 id="Nginx-高并发性"><a href="#Nginx-高并发性" class="headerlink" title="Nginx 高并发性"></a>Nginx 高并发性</h1><p>不同与 Apache 的每个请求占用一个工作线程，当并发数上到几千时，就同时有几千的线程在处理请求，而线程带来的内存占用非常大，线程的上下文切换也会带来很大的 cpu 开销，自然性能就上不去。Nginx 的高并发性取决于 Nginx 的进程模型和事件模型。<br><strong><br>1.Nginx 采用多进程<br>2.Nginx 采用异步非阻塞方式处理请求
</strong></p>
<h2 id="多进程"><a href="#多进程" class="headerlink" title="多进程"></a>多进程</h2><p>多进程的好处：首先，对于每个 worker 进程来说，独立的进程，不需要加锁，所以省掉了锁带来的开销，同时在编程以及问题查找时，也会方便很多。其次，采用独立的进程，可以让互相之间不会影响，一个进程退出后，其它进程还在工作，服务不会中断，master 进程则很快启动新的 worker 进程。当然，worker 进程的异常退出，肯定是程序有 bug 了，异常退出，会导致当前 worker 上的所有请求失败，不过不会影响到所有请求，所以降低了风险。</p>
<h2 id="异步非阻塞方式"><a href="#异步非阻塞方式" class="headerlink" title="异步非阻塞方式"></a>异步非阻塞方式</h2><p>Nginx 的 worker 进程采用<strong>异步非阻塞</strong>的方式来处理请求。对 Nginx 来说，每进来一个 request，就会有一个 worker 进程去处理。但不是一次性对这个 request 进行全程的处理，而是处理到这个 request 需要等待的地方，比如向上游（后端）服务器转发 request，并等待请求返回。而这时，处理这个 request 的 worker 不会这么傻等着而是在发送完请求后，注册一个事件：“如果 upstream 返回了，告诉我一声，我再接着干”（异步）。这时候他就又有能力区处理其他的 request（非阻塞，不会等待网络 IO 就绪，worker 进程<strong>不会进入睡眠状态</strong>），而不是阻塞。如果再有 request 进来，它就可以很快再按这种方式处理。而一旦上游服务器返回了，就会触发注册的事件，worker 就回来对这个 request 继续进行处理。可以看到，虽然一个 worker 同一时刻只能处理一个 request ，但是，对于一个 worker 所承担的所有 request ， worker 是轮流进行处理的，不断的对可进一步处理的 request 进行切换， 而且切换也是因为异步事件未准备好，而主动让出的，这里的切换是没有任何代价，可以理解为循环处理多个准备好的事件。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://tengine.taobao.org/book/chapter_02.html" target="_blank" rel="external">http://tengine.taobao.org/book/chapter_02.html</a><br><a href="https://www.zhihu.com/question/22062795/answer/20197329" target="_blank" rel="external">https://www.zhihu.com/question/22062795/answer/20197329</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Nginx的高并发性取决于它的进程模型和事件模型，最主要的原因是 Nginx worker 进程异步非阻塞的处理方式。&lt;br&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://github.com/Sword2G/sword2g.github.io/categories/Linux/"/>
    
    
      <category term="Nginx" scheme="https://github.com/Sword2G/sword2g.github.io/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>Nginx安装Modsecurity</title>
    <link href="https://github.com/Sword2G/sword2g.github.io/2016/09/01/how-to-install-modsecurity-on-Nginx/"/>
    <id>https://github.com/Sword2G/sword2g.github.io/2016/09/01/how-to-install-modsecurity-on-Nginx/</id>
    <published>2016-09-01T09:03:09.000Z</published>
    <updated>2017-03-10T09:17:03.191Z</updated>
    
    <content type="html"><![CDATA[<p>Nginxz增加modsecurity，实现WAF。<br><a id="more"></a></p>
<h2 id="系统"><a href="#系统" class="headerlink" title="系统"></a>系统</h2><p>OS : Ubuntu 14.04 LTS<br>Nginx : nginx-1.9.9  nginx.org/download/nginx-1.9.9.tar.gz<br>Mosecurity : Mosecurity2.9.1 git@github.com:SpiderLabs/ModSecurity.git</p>
<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><h3 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h3><figure class="highlight q"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-<span class="built_in">get</span> install  build-essential libpcre3 libpcre3-<span class="built_in">dev</span> libssl-<span class="built_in">dev</span> libtool autoconf apache2-prefork-<span class="built_in">dev</span> libxml2-<span class="built_in">dev</span> libcurl4-openssl-<span class="built_in">dev</span></div></pre></td></tr></table></figure>
<h3 id="下载modsecurity、nginx"><a href="#下载modsecurity、nginx" class="headerlink" title="下载modsecurity、nginx"></a>下载modsecurity、nginx</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">cd <span class="regexp">/usr/</span>src</div><div class="line">sudo git clone git:<span class="regexp">//gi</span>thub.com<span class="regexp">/SpiderLabs/</span>ModSecurity.git</div><div class="line"></div><div class="line">wget nginx.org<span class="regexp">/download/</span>nginx-<span class="number">1.9</span>.<span class="number">9</span>.tar.gz</div></pre></td></tr></table></figure>
<h3 id="编译Modsecurity"><a href="#编译Modsecurity" class="headerlink" title="编译Modsecurity"></a>编译Modsecurity</h3><figure class="highlight gauss"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">cd Modsecurity</div><div class="line">./autogen.sh</div><div class="line">./configure --<span class="keyword">enable</span>-standalone-module --<span class="keyword">disable</span>-mlogc</div><div class="line"><span class="built_in">make</span></div></pre></td></tr></table></figure>
<h3 id="编译-Nginx"><a href="#编译-Nginx" class="headerlink" title="编译 Nginx"></a>编译 Nginx</h3><figure class="highlight haml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">cd /usr/src</div><div class="line">tar xzvf nginx-1.9.9.tar.gz</div><div class="line"> </div><div class="line">编译nginx(加入 Modsecurity ),安装</div><div class="line">./configure \</div><div class="line">  -<span class="ruby">-user=www-data \</span></div><div class="line">  -<span class="ruby">-group=www-data \</span></div><div class="line">  -<span class="ruby">-with-pcre-jit \</span></div><div class="line">  -<span class="ruby">-with-debug \</span></div><div class="line">  -<span class="ruby">-with-ipv6 \</span></div><div class="line">  -<span class="ruby">-with-http_ssl_module \</span></div><div class="line">  -<span class="ruby">-add-<span class="class"><span class="keyword">module</span>=/<span class="title">usr</span>/<span class="title">src</span>/<span class="title">ModSecurity</span>/<span class="title">nginx</span>/<span class="title">modsecurity</span></span></span></div><div class="line"></div><div class="line"> make </div><div class="line"> make install</div></pre></td></tr></table></figure>
<p>编译 nginx 的其他参数可以参考<a href="https://www.nginx.com/resources/wiki/start/topics/tutorials/installoptions/" target="_blank" rel="external">这里</a></p>
<p>安装结果如下<br><img src="http://7xum8m.com1.z0.glb.clouddn.com/nginx_modsecurity_install.png" alt=""></p>
<h3 id="配置-nginx"><a href="#配置-nginx" class="headerlink" title="配置 nginx"></a>配置 nginx</h3><p>修改/usr/local/nginx/conf/nginx.conf 的<br><code>user nobody;</code>为’user www-data;’</p>
<p>创建 /usr/local/nginx/sbin/nginx 软连接，从而可以直接使用nginx命令<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ln -s <span class="regexp">/usr/</span>local<span class="regexp">/nginx/</span>sbin<span class="regexp">/nginx /</span>bin<span class="regexp">/nginx</span></div></pre></td></tr></table></figure></p>
<p>启动 nginx，查看/usr/local/nginx/log/error.log,若出现类似一下信息说明 Modsecurity 安装成功<br><img src="http://7xum8m.com1.z0.glb.clouddn.com/nginx_modsecurity_Modsecurity_successful.png" alt=""></p>
<h3 id="配置-Modsecurity"><a href="#配置-Modsecurity" class="headerlink" title="配置 Modsecurity"></a>配置 Modsecurity</h3><p>复制 /usr/src/ModSecurity/modsecurity.conf-recommended 到 /usr/local/nginx/conf/modsecurity.conf,复制cp /usr/src/ModSecurity/unicode.mapping 到 /usr/local/nginx/conf/,modsecurity.conf需要引用 unicode.mapping</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cp <span class="regexp">/usr/</span>src<span class="regexp">/ModSecurity/</span>modsecurity.conf-recommended <span class="regexp">/usr/</span>local<span class="regexp">/nginx/</span>conf/modsecurity.conf</div><div class="line">cp <span class="regexp">/usr/</span>src<span class="regexp">/ModSecurity/</span>unicode.mapping <span class="regexp">/usr/</span>local<span class="regexp">/nginx/</span>conf/</div></pre></td></tr></table></figure>
<p>修改 Modsecurity.conf，将SecRuleEngine设置为 on</p>
<h3 id="下载-OWASP-Core-Rule-Set-CRS"><a href="#下载-OWASP-Core-Rule-Set-CRS" class="headerlink" title="下载 OWASP Core Rule Set (CRS)"></a>下载 OWASP Core Rule Set (CRS)</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cd <span class="regexp">/usr/</span>local<span class="regexp">/nginx/</span>conf</div><div class="line">git clone https:<span class="regexp">//gi</span>thub.com<span class="regexp">/SpiderLabs/</span>owasp-modsecurity-crs.git</div></pre></td></tr></table></figure>
<h4 id="2-x-版本-CRS"><a href="#2-x-版本-CRS" class="headerlink" title="2.x 版本 CRS"></a>2.x 版本 CRS</h4><p>在 owasp-modsecurity-crs 下有很多存放规则的文件夹，例如base_rules、experimental_rules、optional_rules、slr_rules将需要启用的规则用Include指令添加到 modsecurity.conf尾部,如</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">Include</span> owasp-modsecurity-crs/modsecurity_crs_10_setup.<span class="keyword">conf</span></div><div class="line"><span class="keyword">Include</span> owasp-modsecurity-crs/base_rules/modsecurity_crs_41_sql_injection_attacks.<span class="keyword">conf</span></div><div class="line"><span class="keyword">Include</span> owasp-modsecurity-crs/base_rules/modsecurity_crs_41_xss_attacks.<span class="keyword">conf</span></div><div class="line"><span class="keyword">Include</span> owasp-modsecurity-crs/base_rules/modsecurity_crs_40_generic_attacks.<span class="keyword">conf</span></div><div class="line"><span class="keyword">Include</span> owasp-modsecurity-crs/experimental_rules/modsecurity_crs_11_dos_protection.<span class="keyword">conf</span></div><div class="line"><span class="keyword">Include</span> owasp-modsecurity-crs/experimental_rules/modsecurity_crs_11_brute_force.<span class="keyword">conf</span></div><div class="line"><span class="keyword">Include</span> owasp-modsecurity-crs/optional_rules/modsecurity_crs_16_session_hijacking.<span class="keyword">conf</span></div></pre></td></tr></table></figure>
<h4 id="3-x版本CRS"><a href="#3-x版本CRS" class="headerlink" title="3.x版本CRS"></a>3.x版本CRS</h4><p>修改 crs-setup.conf.example 为 crs-setup.conf.<br>修改 rules/REQUEST-900-EXCLUSION-RULES-BEFORE-CRS.conf.example 为 rules/REQUEST-900-EXCLUSION-RULES-BEFORE-CRS.conf<br>修改 rules/RESPONSE-999-EXCLUSION-RULES-AFTER-CRS.conf.example 为 rules/RESPONSE-999-EXCLUSION-RULES-AFTER-CRS.conf<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">cd owasp-modsecurity-crs</div><div class="line">mv crs-setup<span class="selector-class">.conf</span><span class="selector-class">.example</span> crs-setup<span class="selector-class">.conf</span></div><div class="line"></div><div class="line">mv rules/REQUEST-<span class="number">900</span>-EXCLUSION-RULES-BEFORE-CRS<span class="selector-class">.conf</span><span class="selector-class">.example</span> rules/REQUEST-<span class="number">900</span>-EXCLUSION-RULES-BEFORE-CRS<span class="selector-class">.conf</span></div><div class="line">mv rules/RESPONSE-<span class="number">999</span>-EXCLUSION-RULES-AFTER-CRS<span class="selector-class">.conf</span><span class="selector-class">.example</span> rules/RESPONSE-<span class="number">999</span>-EXCLUSION-RULES-AFTER-CRS.conf</div></pre></td></tr></table></figure></p>
<p>在 /usr/local/nginx/conf 下新建 modsec_includes.conf,内容为需要启用的规则<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">include</span> modsecurity.<span class="keyword">conf</span></div><div class="line"><span class="keyword">include</span> owasp-modsecurity-crs/crs-setup.<span class="keyword">conf</span></div><div class="line"><span class="keyword">include</span> owasp-modsecurity-crs/rules/REQUEST-900-EXCLUSION-RULES-BEFORE-CRS.<span class="keyword">conf</span></div><div class="line"><span class="keyword">include</span> owasp-modsecurity-crs/rules/REQUEST-901-INITIALIZATION.<span class="keyword">conf</span></div><div class="line"><span class="keyword">include</span> owasp-modsecurity-crs/rules/REQUEST-905-COMMON-EXCEPTIONS.<span class="keyword">conf</span></div><div class="line"><span class="keyword">include</span> owasp-modsecurity-crs/rules/REQUEST-910-IP-REPUTATION.<span class="keyword">conf</span></div><div class="line"><span class="keyword">include</span> owasp-modsecurity-crs/rules/REQUEST-911-METHOD-ENFORCEMENT.<span class="keyword">conf</span></div><div class="line"><span class="keyword">include</span> owasp-modsecurity-crs/rules/REQUEST-912-DOS-PROTECTION.<span class="keyword">conf</span></div><div class="line"><span class="keyword">include</span> owasp-modsecurity-crs/rules/REQUEST-913-SCANNER-DETECTION.<span class="keyword">conf</span></div><div class="line"><span class="keyword">include</span> owasp-modsecurity-crs/rules/REQUEST-920-PROTOCOL-ENFORCEMENT.<span class="keyword">conf</span></div><div class="line"><span class="keyword">include</span> owasp-modsecurity-crs/rules/REQUEST-921-PROTOCOL-ATTACK.<span class="keyword">conf</span></div><div class="line"><span class="keyword">include</span> owasp-modsecurity-crs/rules/REQUEST-930-APPLICATION-ATTACK-LFI.<span class="keyword">conf</span></div><div class="line"><span class="keyword">include</span> owasp-modsecurity-crs/rules/REQUEST-931-APPLICATION-ATTACK-RFI.<span class="keyword">conf</span></div><div class="line"><span class="keyword">include</span> owasp-modsecurity-crs/rules/REQUEST-932-APPLICATION-ATTACK-RCE.<span class="keyword">conf</span></div><div class="line"><span class="keyword">include</span> owasp-modsecurity-crs/rules/REQUEST-933-APPLICATION-ATTACK-PHP.<span class="keyword">conf</span></div><div class="line"><span class="keyword">include</span> owasp-modsecurity-crs/rules/REQUEST-941-APPLICATION-ATTACK-XSS.<span class="keyword">conf</span></div><div class="line"><span class="keyword">include</span> owasp-modsecurity-crs/rules/REQUEST-942-APPLICATION-ATTACK-SQLI.<span class="keyword">conf</span></div><div class="line"><span class="keyword">include</span> owasp-modsecurity-crs/rules/REQUEST-943-APPLICATION-ATTACK-SESSION-FIXATION.<span class="keyword">conf</span></div><div class="line"><span class="keyword">include</span> owasp-modsecurity-crs/rules/REQUEST-949-BLOCKING-EVALUATION.<span class="keyword">conf</span></div><div class="line"><span class="keyword">include</span> owasp-modsecurity-crs/rules/RESPONSE-950-DATA-LEAKAGES.<span class="keyword">conf</span></div><div class="line"><span class="keyword">include</span> owasp-modsecurity-crs/rules/RESPONSE-951-DATA-LEAKAGES-SQL.<span class="keyword">conf</span></div><div class="line"><span class="keyword">include</span> owasp-modsecurity-crs/rules/RESPONSE-952-DATA-LEAKAGES-JAVA.<span class="keyword">conf</span></div><div class="line"><span class="keyword">include</span> owasp-modsecurity-crs/rules/RESPONSE-953-DATA-LEAKAGES-PHP.<span class="keyword">conf</span></div><div class="line"><span class="keyword">include</span> owasp-modsecurity-crs/rules/RESPONSE-954-DATA-LEAKAGES-<span class="keyword">IIS</span>.<span class="keyword">conf</span></div><div class="line"><span class="keyword">include</span> owasp-modsecurity-crs/rules/RESPONSE-959-BLOCKING-EVALUATION.<span class="keyword">conf</span></div><div class="line"><span class="keyword">include</span> owasp-modsecurity-crs/rules/RESPONSE-980-CORRELATION.<span class="keyword">conf</span></div><div class="line"><span class="keyword">include</span> owasp-modsecurity-crs/rules/RESPONSE-999-EXCLUSION-RULES-AFTER-CRS.<span class="keyword">conf</span></div></pre></td></tr></table></figure></p>
<h3 id="启用-modsecurity"><a href="#启用-modsecurity" class="headerlink" title="启用 modsecurity"></a>启用 modsecurity</h3><p>修改 /usr/local/nginx/conf/nginx.conf ，在需要启用 Modsecurity 的 location 开启 Modsecurity</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="section">server</span> &#123;</div><div class="line">  <span class="attribute">listen</span>       <span class="number">80</span>;</div><div class="line">  <span class="attribute">server_name</span>  example.com;</div><div class="line"></div><div class="line">  <span class="attribute">location</span> / &#123;</div><div class="line"></div><div class="line">    <span class="attribute">ModSecurityEnabled</span> <span class="literal">on</span>;</div><div class="line">    <span class="comment"># 2.x版本CRS</span></div><div class="line">    <span class="attribute">ModSecurityConfig</span> modsecurity.conf;</div><div class="line">    <span class="comment"># 3.x版本CRS</span></div><div class="line">    <span class="comment"># ModSecurityConfig modsec_includes.conf;</span></div><div class="line"></div><div class="line">    <span class="attribute">root</span>   html;</div><div class="line">    <span class="attribute">index</span>  index.html index.htm;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="测试-Nginx-with-Modsecurity"><a href="#测试-Nginx-with-Modsecurity" class="headerlink" title="测试 Nginx(with Modsecurity)"></a>测试 Nginx(with Modsecurity)</h3><p>构造攻击payload测试<br><a href="http://192.168.204.131/?param=%22%3Cscript%3Ealert(1);%3C/script%3E%22" target="_blank" rel="external">http://192.168.204.131/?param=%22%3Cscript%3Ealert(1);%3C/script%3E%22</a><br>查看拦截日志如下<br><img src="http://7xum8m.com1.z0.glb.clouddn.com/nginx_modsecurity_result.png" alt=""></p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://github.com/SpiderLabs/ModSecurity/wiki">https://github.com/SpiderLabs/ModSecurity/wiki</a><br><a href="https://www.howtoforge.com/tutorial/install-nginx-with-mod_security-on-ubuntu-15-04/" target="_blank" rel="external">https://www.howtoforge.com/tutorial/install-nginx-with-mod_security-on-ubuntu-15-04/</a><br><a href="https://blog.stickleback.dk/nginx-modsec-on-ubuntu-14-04-lts/" target="_blank" rel="external">https://blog.stickleback.dk/nginx-modsec-on-ubuntu-14-04-lts/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Nginxz增加modsecurity，实现WAF。&lt;br&gt;
    
    </summary>
    
      <category term="WAF" scheme="https://github.com/Sword2G/sword2g.github.io/categories/WAF/"/>
    
    
      <category term="Modsecurity, Nginx" scheme="https://github.com/Sword2G/sword2g.github.io/tags/Modsecurity-Nginx/"/>
    
  </entry>
  
  <entry>
    <title>SEnginx 反向代理搭建测试</title>
    <link href="https://github.com/Sword2G/sword2g.github.io/2016/08/26/SEnginx-Reverse-Proxy/"/>
    <id>https://github.com/Sword2G/sword2g.github.io/2016/08/26/SEnginx-Reverse-Proxy/</id>
    <published>2016-08-26T14:43:34.000Z</published>
    <updated>2016-12-28T14:58:11.135Z</updated>
    
    <content type="html"><![CDATA[<p>代理服务器是一个作为客户端与目标服务器之间的中介服务器，主要完成客户端与目标服务器之间请求和响应的转发工作。它分为正向代理和反向代理。<br><a id="more"></a></p>
<h1 id="正向代理"><a href="#正向代理" class="headerlink" title="正向代理"></a>正向代理</h1><p>正向服务器可以理解为客户端的代理人。客户端为了能从目标服务器取得内容，首先向代理服务器发送一个请求，并且指定目标服务器，之后代理服务器向目标服务器转交请求，获得请求的内容并转交返回给客户端。它向内部网络提供访问外部网络资源的途径，作为客户代理。</p>
<p><img src="http://7xum8m.com1.z0.glb.clouddn.com/nginx_%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86.jpg" alt="正向代理"></p>
<h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><h3 id="加快客户端的请求应答"><a href="#加快客户端的请求应答" class="headerlink" title="加快客户端的请求应答"></a>加快客户端的请求应答</h3><p>代理服务器可以缓存某些资源（如页面），当客户端需要再次请求该资源的时候，代理服务器可以将其缓存的该资源直接返回给客户端而不用再次转发请求，重新从目标服务器取得资源。</p>
<h3 id="减少出口的流量，节约带宽"><a href="#减少出口的流量，节约带宽" class="headerlink" title="减少出口的流量，节约带宽"></a>减少出口的流量，节约带宽</h3><p>由于缓存的机制，出口减少的很多请求流量，节约了带宽。</p>
<h3 id="访问受限资源"><a href="#访问受限资源" class="headerlink" title="访问受限资源"></a>访问受限资源</h3><p>客户端可能无法直接访问目标服务器资源，由代理服务器代替客户端取得资源后再将资源转发给客户端。</p>
<h3 id="隐藏客户端身份"><a href="#隐藏客户端身份" class="headerlink" title="隐藏客户端身份"></a>隐藏客户端身份</h3><p>真正的请求资源的是代理服务器，所以目标服务器并不知道真实的客户身份</p>
<h1 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h1><p>反向代理可以理解为服务器端的代理人。反向代理对客户端是透明的，客户端并不知道反向代理的存在。客户端向目标服务器发送请求的时候实际上是由反向代理服务器首先收到请求，反向代理服务器可以根据相应的策略，将客户端的请求转发给真正的目标服务器。它向外部网络提供访问内部网络资源的途径，作为服务器代理。</p>
<p><img src="http://7xum8m.com1.z0.glb.clouddn.com/nginx_%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8.jpg" alt="反向代理"></p>
<h2 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h2><h3 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h3><p>由于客户端的请求首先需要经过代理服务器，代理服务器在对客户端的请求进行合法化的检查之后再将请求转发给真正的目标服务器，保证了目标服务器的安全。</p>
<h3 id="缓解目标服务器压力"><a href="#缓解目标服务器压力" class="headerlink" title="缓解目标服务器压力"></a>缓解目标服务器压力</h3><p>代理服务器可以缓存某些资源，减少对真是目标服务器的请求。</p>
<h3 id="实现负载均衡"><a href="#实现负载均衡" class="headerlink" title="实现负载均衡"></a>实现负载均衡</h3><p>根据某些策略将客户端请求转发到服务器集群中的不同服务器，平衡集群中各个服务器的负载压力。</p>
<h1 id="SEnginx-Security-Enhanced-NGINX"><a href="#SEnginx-Security-Enhanced-NGINX" class="headerlink" title="SEnginx (Security Enhanced NGINX)"></a><a href="http://www.senginx.org/cn/index.php/%E9%A6%96%E9%A1%B5" target="_blank" rel="external">SEnginx (Security Enhanced NGINX)</a></h1><blockquote>
<p>SEnginx（Security Enhanced NGINX）是著名的 HTTP 和 反向代理 服务器nginx的一个变种版本，主要是在原版nginx的基础上增加了多种Web安全功能，并增强了应用交付等方面的原有功能。SEnginx继承了nginx的全部原始特性，全面兼容标准nginx的配置，此外也吸收了一些源自tengine等优秀nginx变种的高级特性以及一些常用的第三方nginx模块。</p>
</blockquote>
<h2 id="SEnginx-主要功能"><a href="#SEnginx-主要功能" class="headerlink" title="SEnginx 主要功能"></a>SEnginx 主要功能</h2><h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><p>SEnginx 中集成了 nginx_tcp_proxy_module，为用户提供 tcp 的反向代理和负载均衡功能。<br>负载均衡功能在 upstream 上下文中进行配置。负载均衡的算法支持 fastest 算法（响应速度快的服务器应该有能力处理更多请求） 和 fair 算法（“闲者优先”，主要判断依据是各个 backend 上的链接数和和失败数）。</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">upstream <span class="keyword">backend </span>&#123;</div><div class="line">    	fastest<span class="comment">;</span></div><div class="line">    	<span class="comment"># fair;</span></div><div class="line">        server <span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">8087</span> <span class="comment">;</span></div><div class="line">    	server <span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">8085</span> <span class="comment">;</span></div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="会话保持"><a href="#会话保持" class="headerlink" title="会话保持"></a>会话保持</h3><p>在使用负载均衡功能的网站会要求属于同一会话的请求必须交付给相同的服务器，由 persistence 模块实现。</p>
<p>persistence有三种标识会话的方式：</p>
<ul>
<li><p>插入HTTP cookie来标识会话<br>persistence 模块在其响应中设置”Set-Cookie”头，浏览器发送下一次请求时带上这个 cookie<br>persistence 模块根据 cookie 判断应该转发给那个服务器</p>
</li>
<li><p>监听现有会话的cookie来标识会话<br>persistence 模块再添加包含 server信息的特定 cookie；在服务器设置的cookie存在时persistence功能才会有效。</p>
</li>
<li><p>基于session功能来标识会话<br>persistence 模块会基于 session 中记录的信息进行会话保持。在这种情况下，persistence 的超时时间和session的超时时间相同</p>
</li>
</ul>
<h3 id="缓存类型设置"><a href="#缓存类型设置" class="headerlink" title="缓存类型设置"></a>缓存类型设置</h3><p>可以针对针应答类型进行缓存，而不仅仅是请求的类型。</p>
<h3 id="服务器健康检查"><a href="#服务器健康检查" class="headerlink" title="服务器健康检查"></a><a href="http://tengine.taobao.org/document_cn/http_upstream_check_cn.html" target="_blank" rel="external">服务器健康检查</a></h3><p>代理服务器定时周期性的向后端服务器发送健康检查数据包，代理可以通过后端服务器给出的响应判断后端服务器 down 还是 up。</p>
<h3 id="访问行为识别"><a href="#访问行为识别" class="headerlink" title="访问行为识别"></a>访问行为识别</h3><p>可以设置某个目录下的资源为敏感资源，在一定的时间内，如果客户端对敏感资源的访问 percent 都达到某个阈值，就可以初步判断该访问为机器人或是恶意攻击，根据相应的策略可以对客户端进行限速或进行机器人挑战（判断是否是机器人）。</p>
<h3 id="基于条件的限速功能"><a href="#基于条件的限速功能" class="headerlink" title="基于条件的限速功能"></a>基于条件的限速功能</h3><p>本功能基于tengine的limit_req模块，该模块针对原始nginx的limit_req功能在IP白名单、多条件限速以及forbid_action等方面进行了增强，SEnginx在此基础上增加了condition参数，只有条件为真时才执行限速动作，这样limit_req模块和机器人缓解模块以及访问行为识别模块配合使用，可以实现更加严格且多样化的限速策略</p>
<h3 id="Robot-Mitigation（机器人缓解）"><a href="#Robot-Mitigation（机器人缓解）" class="headerlink" title="Robot Mitigation（机器人缓解）"></a>Robot Mitigation（机器人缓解）</h3><p>Robot Mitigation 模块采用了一种基于“挑战”的验证方法，即向客户端发送特定的、浏览器能解析的应答（特定的js 脚本或swf flash 文件），如果客户端是真实的浏览器，则会重新触发请求，并带有一个特定的Cookie值，Robot Mitigation 模块会依据此 Cookie 的信息来判断是否是机器人。</p>
<h3 id="黑白名单"><a href="#黑白名单" class="headerlink" title="黑白名单"></a>黑白名单</h3><p>当某个源IP地址在1秒内发生指定的攻击次数时，将此IP地址加入到IP黑名单中，并阻断此IP一段时间。</p>
<h3 id="带DNS反查的User-Agent白名单"><a href="#带DNS反查的User-Agent白名单" class="headerlink" title="带DNS反查的User-Agent白名单"></a>带DNS反查的User-Agent白名单</h3><p>DNS反查，根据请求的源IP地址，查询DNS服务器获取域名，如果域名和用户定义的正则pattern匹配，则此白名单才命中。此机制是为了防止User-Agent伪造为知名机器人。</p>
<h3 id="Cookie-防篡改"><a href="#Cookie-防篡改" class="headerlink" title="Cookie 防篡改"></a>Cookie 防篡改</h3><p>Cookie Poisoning 模块能监控服务器发出的 Set-Cookie 头以及设置的 cookie 值，如果 cookie 的值在客户端被修改，则此模块会检测出修改，并执行动作。</p>
<h3 id="网页防篡改"><a href="#网页防篡改" class="headerlink" title="网页防篡改"></a>网页防篡改</h3><p>在请求到达 SEnginx 的时候核查文件水印（由原始文件生成的 hash 文件）是否有变化，从而达到防篡改的目的。防篡改模块可以和 nginx 配合以达到在篡改发生时，可以将请求重定向到备份的目录，恢复网页内容的功能。</p>
<h3 id="安全会话机制"><a href="#安全会话机制" class="headerlink" title="安全会话机制"></a>安全会话机制</h3><p>Session会在客户端的浏览器设置一个 Cookie 用于记录会话信息</p>
<h1 id="SEnginx-配置示例"><a href="#SEnginx-配置示例" class="headerlink" title="SEnginx 配置示例"></a>SEnginx 配置示例</h1><h2 id="实现环境"><a href="#实现环境" class="headerlink" title="实现环境"></a>实现环境</h2><p>由于实验环境的限制，我们将 SEnginx (作为反向代理)和 apache2 (作为服务器)部署同一台计算机上。SEnginx 监听 http 80 端口，而 web 服务器分别以不同的端口号(8085 和 8087)部署在同一个 apache2 服务器上，代表两个不同的 web 服务器，当用户访问 localhost 时，SEnginx 作为反向代理将请求均衡地转发给 apache 2 不同端口的 Web 应用程序进行处理。架构如下图所示：</p>
<p><img src="http://7xum8m.com1.z0.glb.clouddn.com/nginx_%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E6%9E%B6%E6%9E%84.jpg" alt="SEnginx 反向代理架构"></p>
<h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><figure class="highlight vala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div><div class="line">241</div><div class="line">242</div><div class="line">243</div><div class="line">244</div><div class="line">245</div><div class="line">246</div><div class="line">247</div><div class="line">248</div><div class="line">249</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#运行的用户</span></div><div class="line"><span class="meta">#user  nobody;</span></div><div class="line"><span class="meta"># worker 工作进程的个数，master进程是接收并分配请求给worker处理，通常和cpu数量相同</span></div><div class="line">worker_processes  <span class="number">1</span>;</div><div class="line"><span class="meta"># 错误日志及日志级别[debug, info, notice, warn, error, crit],默认 error</span></div><div class="line">error_log  logs/error.log  notice;</div><div class="line"><span class="meta"># pid 文件</span></div><div class="line">pid        logs/nginx.pid;</div><div class="line"></div><div class="line"></div><div class="line">events &#123;</div><div class="line"><span class="meta"># IO 复用模型 2.6 以上内核支持，Linux 默认 IO 模型</span></div><div class="line"><span class="meta">#    use   epoll;</span></div><div class="line"><span class="meta">#   单个 worker process 上的最大并发数</span></div><div class="line">    worker_connections  <span class="number">1024</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta"># http 服务相关参数</span></div><div class="line">http &#123;</div><div class="line"><span class="meta">#   设定mime类型,类型由mime.type文件定义</span></div><div class="line">    include       mime.types;</div><div class="line">    default_type  application/octet-stream;</div><div class="line"></div><div class="line"><span class="meta">#   服务器日志格式，以下为默认格式</span></div><div class="line">    #log_format  main  <span class="string">'$remote_addr - $remote_user [$time_local] "$request" '</span></div><div class="line">    #                  <span class="string">'$status $body_bytes_sent "$http_referer" '</span></div><div class="line">    #                  <span class="string">'"$http_user_agent" "$http_x_forwarded_for"'</span>;</div><div class="line"></div><div class="line"><span class="meta">#   开启高效文件传输模式，sendfile指令指定nginx是否调用sendfile函数来输出文件，  </span></div><div class="line"><span class="meta">#   减少用户空间到内核空间的上下文切换。</span></div><div class="line"><span class="meta">#	对于普通应用设为on，如果用来进行下载等应用磁盘IO重负载应用，可设置为off，</span></div><div class="line"><span class="meta">#	以平衡磁盘与网络I/O处理速度，降低系统的负载。</span></div><div class="line">    sendfile        on;</div><div class="line"></div><div class="line"><span class="meta">#   与 tcp_nodelay 互斥  </span></div><div class="line"><span class="meta">#   开启 Nagle 算法，等到数据包最大时，一次性的传输出去，这样有助于解决网络堵塞</span></div><div class="line">    tcp_nopush     on;</div><div class="line"></div><div class="line"><span class="meta">#   连接超时时间</span></div><div class="line"><span class="meta">#   keepalive_timeout  0;</span></div><div class="line">    keepalive_timeout  <span class="number">65</span>;</div><div class="line"></div><div class="line"><span class="meta">#   开启gzip压缩</span></div><div class="line">    gzip  on;</div><div class="line"><span class="meta">#   session 最大 size</span></div><div class="line">    session_max_size <span class="number">1024</span>;</div><div class="line"></div><div class="line"><span class="meta">#   SEnginx blacklist 开启</span></div><div class="line">    ip_blacklist on;</div><div class="line"><span class="meta">#   blacklist 大小</span></div><div class="line">    ip_blacklist_size <span class="number">10240</span>;</div><div class="line"><span class="meta">#   blacklis 超时时间</span></div><div class="line">    ip_blacklist_timeout <span class="number">60</span>;</div><div class="line">	</div><div class="line"><span class="meta">#   global User-Agent whitelist </span></div><div class="line">    whitelist_ua $ua_wl_dns &#123;</div><div class="line">    	caseless;</div><div class="line">    	<span class="string">"baiduspider"</span> <span class="string">".*\.baidu\.com"</span>;</div><div class="line">    	<span class="string">"googlebot"</span> <span class="string">".*\.google\.com"</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"><span class="meta">#   statistics 内存 size，注意统计信息放在内存中，一旦 server 关机，数据清零</span></div><div class="line">    statistics_zone <span class="number">10</span>m;</div><div class="line"></div><div class="line"><span class="meta">#   负载均衡的服务器列表	</span></div><div class="line">    upstream backend &#123;</div><div class="line"><span class="meta">#       Http 会话保持，支持 insert_cookie， monitor_cookie， session_based   </span></div><div class="line">    	persistence insert_cookie cookie_name=senginxforward timeout=<span class="number">30</span>;</div><div class="line"></div><div class="line"><span class="meta">#	    负载均衡算法，支持 fastest 和 fair;</span></div><div class="line">    	fastest;</div><div class="line"><span class="meta">#       服务器主机，可以用域名（域名支持动态解析）或 ip</span></div><div class="line">        server <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8087</span> ;</div><div class="line">    	server <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8085</span> ;</div><div class="line"><span class="meta">#       后端服务器健康度检查    	</span></div><div class="line">	    check interval=<span class="number">1000</span> rise=<span class="number">2</span> fall=<span class="number">5</span> timeout=<span class="number">1000</span> type=tcp;</div><div class="line"><span class="meta">#       配置一个连接发送的请求数，其默认值为 1        </span></div><div class="line"><span class="meta">#       check_keepalive_requests 100;</span></div><div class="line"><span class="meta">#       配置http健康检查包发送的请求内容，为了减少传输数据量，采用"HEAD"方法</span></div><div class="line"><span class="meta">#       当采用长连接进行健康检查时，需在该指令中添加keep-alive请求头，</span></div><div class="line"><span class="meta">#       如："HEAD / HTTP/1.1\r\nConnection: keep-alive\r\n\r\n"</span></div><div class="line">        check_http_send <span class="string">"HEAD / HTTP/1.1\r\nConnection: keep-alive\r\n\r\n"</span>;</div><div class="line"><span class="meta">#       指定 HTTP 回复的健康状态，默认认为 2XX 和 3XX 状态是健康的</span></div><div class="line">        check_http_expect_alive http_2xx http_3xx;	</div><div class="line"></div><div class="line">    &#125;</div><div class="line"><span class="meta">#   定义一个限速 zone 速率是 1 request per second</span></div><div class="line">    limit_req_zone $binary_remote_addr zone=cc:<span class="number">10</span>m rate=<span class="number">1</span>r/s;</div><div class="line">    limit_req_zone $binary_remote_addr zone=total:<span class="number">10</span>m rate=<span class="number">30</span>r/s;    </div><div class="line"><span class="meta">#   define a ip analysis zone，名字为abc 内存大小10M，</span></div><div class="line"><span class="meta">#   在1s采样周期内请求达到10次才计算访问行为</span></div><div class="line">    ip_behavior_zone zone=abc:<span class="number">10</span>m sample_base=<span class="number">10</span> sample_cycle=<span class="number">1</span>s;</div><div class="line"></div><div class="line"><span class="meta">#   定义一个虚拟主机 在 80 端口监听</span></div><div class="line">    server &#123;</div><div class="line">        listen       <span class="number">80</span>;</div><div class="line">        server_name  localhost;</div><div class="line">    #   日志路径    </div><div class="line">    #   access_log  logs/host.access.log  main;</div><div class="line"></div><div class="line"><span class="meta">#	define a unique server virtual server name for statistics</span></div><div class="line">	virtual_server_name www.abc.com;</div><div class="line"><span class="meta">#   开启会话，Cookie 防篡改模块依赖 session</span></div><div class="line">	session on;</div><div class="line">	</div><div class="line"><span class="meta">#   开启防篡改</span></div><div class="line"><span class="meta">#	web_defacement on;  </span></div><div class="line"><span class="meta">#   web_defacement_original /usr/local/senginx/html ;</span></div><div class="line"><span class="meta">#	指定网页文件所在的目录</span></div><div class="line"><span class="meta">#   web_defacement_original /var/www/8087 ;</span></div><div class="line"><span class="meta">#   指定hash文件</span></div><div class="line"><span class="meta">#   web_defacement_hash_data /usr/local/senginx/hash_data;</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="meta">#   turn on a ip analysis zone</span></div><div class="line">	ip_behavior zone=abc type=sensitive_url;</div><div class="line">	</div><div class="line"><span class="meta">#	statistics page </span></div><div class="line">	location /stats &#123;</div><div class="line"> 	    statistics;</div><div class="line"><span class="meta">#       设置页面访问权限</span></div><div class="line">	    allow all;</div><div class="line"><span class="meta">#       allow SOME.IP.ADD.RESS;</span></div><div class="line"><span class="meta">#       deny all;</span></div><div class="line">	&#125;</div><div class="line"></div><div class="line"><span class="meta">#	show session page </span></div><div class="line">	location /show_session &#123;</div><div class="line">	    session_show on;</div><div class="line"><span class="meta">#       设置页面访问权限</span></div><div class="line">	    allow all;</div><div class="line"><span class="meta">#       allow SOME.IP.ADD.RESS;</span></div><div class="line"><span class="meta">#       deny all;</span></div><div class="line">	&#125;</div><div class="line"><span class="meta">#   flush session</span></div><div class="line">	location /blacklist_flush &#123;</div><div class="line">        ip_blacklist_flush;</div><div class="line">   	    ip_blacklist_log on;</div><div class="line"><span class="meta">#       设置页面访问权限</span></div><div class="line">	    allow all;</div><div class="line"><span class="meta">#       allow SOME.IP.ADD.RESS;</span></div><div class="line"><span class="meta">#       deny all;</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line"><span class="meta">#   blacklist page </span></div><div class="line">    location /blacklist_show &#123;</div><div class="line">        ip_blacklist_show;</div><div class="line">   	    ip_blacklist_log on;</div><div class="line"><span class="meta">#       设置页面访问权限</span></div><div class="line">	    allow all;</div><div class="line"><span class="meta">#       allow SOME.IP.ADD.RESS;</span></div><div class="line"><span class="meta">#       deny all;  	    </span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">	location /ss/  &#123;</div><div class="line">        </div><div class="line"><span class="meta">#       if condition == 1, goto @process</span></div><div class="line">	    limit_req zone=cc burst=<span class="number">1</span> forbid_action=@process condition=$cond;   </div><div class="line">        # 限速模块backlog = <span class="number">5</span></div><div class="line">	    limit_req zone=total burst=<span class="number">5</span>;</div><div class="line"></div><div class="line"><span class="meta">#	    root /var/www/8085/ss/;</span></div><div class="line">	    root /<span class="keyword">var</span>/www/<span class="number">8087</span>; </div><div class="line"><span class="meta">#       设置为 sensitive resource</span></div><div class="line">	    ip_behavior_sensitive;</div><div class="line"><span class="meta">#       设置 $cond 条件</span></div><div class="line">        ifall ($insensitive_percent &gt;= <span class="number">0</span>) ($insensitive_percent &lt; <span class="number">30</span>) &#123;</div><div class="line">                 <span class="keyword">set</span> $cond <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">	&#125;</div><div class="line">  </div><div class="line">	location @process &#123;</div><div class="line">     	# <span class="keyword">return</span> <span class="number">403</span>;</div><div class="line">        # 机器人模块</div><div class="line">	    robot_mitigation on;</div><div class="line">	    robot_mitigation_cookie_name robotCookie;</div><div class="line">        # js or swf</div><div class="line">	    robot_mitigation_mode js;</div><div class="line">	    # times to change</div><div class="line">	    robot_mitigation_blacklist <span class="number">3</span>;</div><div class="line"></div><div class="line">	    #robot_mitigation_action directive deprecated</div><div class="line">        # robot_mitigation_action block;</div><div class="line">        #  robot_mitigation_whitelist &#123;</div><div class="line">        #       <span class="string">"Google"</span> <span class="string">"Googlebot"</span>;</div><div class="line">        # &#125;</div><div class="line"></div><div class="line"><span class="meta">#       请求转向自定义的服务器列表    </span></div><div class="line">   	    proxy_pass http:<span class="comment">//backend; </span></div><div class="line">	</div><div class="line">    &#125;     </div><div class="line"><span class="meta">#   网页篡改时 recover 目录 </span></div><div class="line">	location /recover &#123;</div><div class="line">               web_defacement off;</div><div class="line">               root /<span class="keyword">var</span>/www;</div><div class="line">    &#125;	</div><div class="line"><span class="meta">#   cookie 防篡改模块 </span></div><div class="line">    location / &#123;</div><div class="line"><span class="meta">#       开启放篡改    </span></div><div class="line">		cookie_poisoning on;</div><div class="line"><span class="meta">#		cookie 篡改时动作，支持 block, pass, remove cookie,add to blacklist</span></div><div class="line">		cookie_poisoning_action block;     </div><div class="line">		#cookie_poisoning_action remove;    <span class="comment">//remove cookie</span></div><div class="line">		#cookie_poisoning_action blacklist,<span class="number">5</span>;    <span class="comment">//block 5 times and put into blacklist	      </span></div><div class="line">		cookie_poisoning_log on;</div><div class="line"></div><div class="line"><span class="meta">#		User-Agent whitelist</span></div><div class="line">		cookie_poisoning_whitelist ua_var_name=ua_wl_dns;                        </div><div class="line"></div><div class="line"><span class="meta">#       限速模块 backlog = 5</span></div><div class="line">	    limit_req zone=total burst=<span class="number">5</span>;</div><div class="line"></div><div class="line"><span class="meta">#       请求转向自定义的服务器列表 	      </span></div><div class="line">	    proxy_pass http:<span class="comment">//backend;</span></div><div class="line"><span class="meta">#       index 页面                </span></div><div class="line">        # index index.html;</div><div class="line">        # root /usr/local/senginx/html;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">        #charset koi8-r;</div><div class="line"></div><div class="line">       # location / &#123;</div><div class="line">        #    root   html;</div><div class="line">         #   index  index.html index.htm;</div><div class="line">       # &#125;</div><div class="line"></div><div class="line">        #error_page  <span class="number">404</span>              /<span class="number">404.</span>html;</div><div class="line"></div><div class="line">        # redirect server error pages to the <span class="keyword">static</span> page /<span class="number">50</span>x.html</div><div class="line"><span class="meta">#       定义错误页面</span></div><div class="line">    error_page   <span class="number">500</span> <span class="number">502</span> <span class="number">503</span> <span class="number">504</span>  /<span class="number">50</span>x.html;</div><div class="line">    location = /<span class="number">50</span>x.html &#123;</div><div class="line">        root   html;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">	location ~ \.html$ &#123;</div><div class="line">		proxy_pass http:<span class="comment">//backend;</span></div><div class="line">		proxy_redirect off; </div><div class="line">	&#125;	</div><div class="line"></div><div class="line"><span class="meta">#   定义健康检查 status page	</span></div><div class="line">	location /status &#123;</div><div class="line">        check_status;</div><div class="line">        access_log   off;</div><div class="line">	    allow all;</div><div class="line"><span class="meta">#       allow SOME.IP.ADD.RESS;</span></div><div class="line"><span class="meta">#       deny all;</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="http://www.cnblogs.com/edisonchou/p/4126742.html" target="_blank" rel="external">http://www.cnblogs.com/edisonchou/p/4126742.html</a><br><a href="http://www.cnblogs.com/xiaogangqq123/archive/2011/03/02/1969006.html" target="_blank" rel="external">http://www.cnblogs.com/xiaogangqq123/archive/2011/03/02/1969006.html</a><br><a href="http://www.senginx.org/cn/index.php/%E9%A6%96%E9%A1%B5" target="_blank" rel="external">http://www.senginx.org/cn/index.php/%E9%A6%96%E9%A1%B5</a><br>（完）</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;代理服务器是一个作为客户端与目标服务器之间的中介服务器，主要完成客户端与目标服务器之间请求和响应的转发工作。它分为正向代理和反向代理。&lt;br&gt;
    
    </summary>
    
      <category term="Server" scheme="https://github.com/Sword2G/sword2g.github.io/categories/Server/"/>
    
    
      <category term="Nginx" scheme="https://github.com/Sword2G/sword2g.github.io/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>GDB-Note</title>
    <link href="https://github.com/Sword2G/sword2g.github.io/2016/08/20/GDB-Note/"/>
    <id>https://github.com/Sword2G/sword2g.github.io/2016/08/20/GDB-Note/</id>
    <published>2016-08-20T14:32:45.000Z</published>
    <updated>2016-12-28T14:43:48.537Z</updated>
    
    <content type="html"><![CDATA[<p>GDB 是 UNIX 及 UNIX-like 下的调试工具。<br><a id="more"></a></p>
<h1 id="编译加入调试信息"><a href="#编译加入调试信息" class="headerlink" title="编译加入调试信息"></a>编译加入调试信息</h1><ul>
<li>gcc -g 参数</li>
<li>gcc -g hello.c -o hello</li>
</ul>
<h1 id="启动gdb"><a href="#启动gdb" class="headerlink" title="启动gdb"></a>启动gdb</h1><ul>
<li><p>调试程序<br>gdb program_name</p>
</li>
<li><p>调试程序和 core 文件<br>gdb program_name core</p>
</li>
<li><p>指定程序的 pid ，gdb 可以自动attach上去<br>gdb program_name pid</p>
</li>
</ul>
<h1 id="显示源代码"><a href="#显示源代码" class="headerlink" title="显示源代码"></a>显示源代码</h1><ul>
<li><p>显示 lineno/function_name 周围源代码<br>list [lineno/function_name]</p>
</li>
<li><p>list<br>显示当前行后面的源程序。</p>
</li>
<li><p>list -<br>显示当前行前面的源程序。</p>
</li>
</ul>
<h1 id="断点"><a href="#断点" class="headerlink" title="断点"></a>断点</h1><h2 id="设置断点"><a href="#设置断点" class="headerlink" title="设置断点"></a>设置断点</h2><ul>
<li><p>设置断点<br>b function_name<br>b lineno if n == 9</p>
</li>
<li><p>修改断点的条件为 expression<br>condition &lt;断点号&gt; </p>
</li>
</ul>
<h2 id="显示断点"><a href="#显示断点" class="headerlink" title="显示断点"></a>显示断点</h2><p>info b</p>
<h2 id="en-dis-able-断点"><a href="#en-dis-able-断点" class="headerlink" title="en(dis)able 断点"></a>en(dis)able 断点</h2><ul>
<li>disable [b] [range]</li>
<li>disable [b] 1-4</li>
<li>enable [b] [range]</li>
</ul>
<h2 id="delete-断点"><a href="#delete-断点" class="headerlink" title="delete 断点"></a>delete 断点</h2><p>delete [breakpoints] [range…]</p>
<h1 id="设置观察点"><a href="#设置观察点" class="headerlink" title="设置观察点"></a>设置观察点</h1><p>观察点一般来观察某个表达式（变量也是一种表达式）的值是否有变化了，如果有变化，马上停住程序。</p>
<ul>
<li>watch 为表达式（变量）expr设置一个观察点。当表达式值有变化时，马上停住程序</li>
<li>rwatch 表达式（变量）expr被读时，停住程序</li>
<li>awatch 表达式（变量）的值被读或被写时，停住程序</li>
<li>info watchpoints 列出当前所设置了的所有观察点</li>
</ul>
<h1 id="run"><a href="#run" class="headerlink" title="run"></a>run</h1><ul>
<li><p>设置参数<br>set args [param1] [param2] [param3]</p>
</li>
<li><p>显示参数<br>show args</p>
</li>
<li><p>r(un) [param1] [param2] [param3] &gt;&gt;</p>
</li>
</ul>
<h1 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h1><ul>
<li>start 开始运行程序</li>
<li>run 运行程序，可简写为r</li>
<li>next 单步跟踪，函数调用当作一条简单语句执行，可简写为n</li>
<li>step 单步跟踪，函数调进入被调用函数体内，可简写为s</li>
<li>finish 退出函数</li>
<li>until 在一个循环体内单步跟踪时，这个命令可以运行程序直到退出循环体,可简写为u。</li>
<li>continue 继续运行程序，可简写为c</li>
</ul>
<h1 id="打印变量、字符串、表达式等的值，可简写为p"><a href="#打印变量、字符串、表达式等的值，可简写为p" class="headerlink" title="打印变量、字符串、表达式等的值，可简写为p"></a>打印变量、字符串、表达式等的值，可简写为p</h1><ul>
<li>p var 打印 var 的值</li>
<li>p cou1+cou2+cou3 打印表达式值</li>
<li>p *array@len 打印数组的前len数据<br>print接受一个表达式，GDB会根据当前的程序运行的数据来计算这个表达式，表达式可以是当前程序运行中的const常量、变量、函数等内容。</li>
</ul>
<p>但是GDB不能使用程序中定义的宏。</p>
<h1 id="设置变量"><a href="#设置变量" class="headerlink" title="设置变量"></a>设置变量</h1><ul>
<li>set var=value</li>
<li>p var=value</li>
</ul>
<h1 id="自动显示变量"><a href="#自动显示变量" class="headerlink" title="自动显示变量"></a>自动显示变量</h1><ul>
<li>dsplay expr</li>
<li>display/fmt expr</li>
<li><p>display/fmt addr<br>expr是一个表达式，fmt表示显示的格式，addr表示内存地址，当你用display设定好了一个或多个表达式后，只要你的程序被停下来，GDB会自动显示你所设置的这些表达式的值。</p>
</li>
<li><p>info display 查看display设置的自动显示的信息。</p>
</li>
<li><p>undisplay dnums…</p>
</li>
<li><p>delete display dnums…<br>删除自动显示，dnums意为所设置好了的自动显式的编号。如果要同时删除几个，编号可以用空格分隔，如果要删除一个范围内的编号，可以用减号表示（如：2-5）</p>
</li>
<li><p>disable display dnums…</p>
</li>
<li><p>enable display dnums…</p>
</li>
</ul>
<p>disable和enalbe不删除自动显示的设置，而只是让其失效和恢复。</p>
<h1 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h1><h2 id="产生信号"><a href="#产生信号" class="headerlink" title="产生信号"></a>产生信号</h2><ul>
<li>signal signalnum<br>如 signal 9<br>signal 命令和 shell 的 kill 命令不同，系统的 kill 命令发信号给被调试程序时，是由 GDB 截获的，而 signal 命令所发出一信号则是直接发给被调试程序的。</li>
</ul>
<h2 id="handle-signal"><a href="#handle-signal" class="headerlink" title="handle signal"></a>handle signal</h2><p><code>handle signal [keywords…]</code><br>keywords 列表如下:</p>
<ul>
<li><p>nostop<br>当被调试的程序收到信号时，GDB不会停住程序的运行，但会打出消息告诉你收到这种信号。</p>
</li>
<li><p>stop<br>当被调试的程序收到信号时，GDB会停住你的程序。</p>
</li>
<li><p>print<br>当被调试的程序收到信号时，GDB会显示出一条信息。</p>
</li>
<li><p>noprint<br>当被调试的程序收到信号时，GDB 不会告诉你收到信号的信息。</p>
</li>
<li><p>pass</p>
</li>
<li><p>noignore<br>当被调试的程序收到信号时，GDB不处理信号。</p>
</li>
<li><p>nopass</p>
</li>
<li><p>ignore<br>当被调试的程序收到信号时，GDB不会让被调试程序来处理这个信号。</p>
</li>
<li><p>info signals</p>
</li>
<li><p>info handle<br>查看有哪些信号在被GDB检测中。</p>
</li>
</ul>
<h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><ul>
<li><p>查看 thread 号<br>info threads</p>
</li>
<li><p>指定线程设置断点<br>break linespec thread threadno<br>break linespec thread threadno if …</p>
</li>
</ul>
<h1 id="查看栈信息"><a href="#查看栈信息" class="headerlink" title="查看栈信息"></a>查看栈信息</h1><ul>
<li><p>打印当前的函数调用栈的所有信息<br>bt</p>
</li>
<li><p>n是一个正整数，表示只打印栈顶上n层的栈信息<br>bt n</p>
</li>
<li><p>-n表一个负整数，表示只打印栈底下n层的栈信息<br>bt -n</p>
</li>
<li><p>切换当前栈<br>frame n</p>
</li>
</ul>
<h1 id="跳转"><a href="#跳转" class="headerlink" title="跳转"></a>跳转</h1><ul>
<li><p>指定下一条语句的运行点<br>jump linespec</p>
</li>
<li><p>这里的是代码行的内存地址<br>jump *address</p>
</li>
</ul>
<p><strong>注意，jump命令不会改变当前的程序栈中的内容，所以，当你从一个函数跳到另一个函数时，当函数运行完返回时进行弹栈操作时必然会发生错误，可能结果还是非常奇怪的，甚至于产生程序Core Dump。所以最好是同一个函数中进行跳转。</strong></p>
<h1 id="强制函数返回"><a href="#强制函数返回" class="headerlink" title="强制函数返回"></a>强制函数返回</h1><p>使用 return 命令取消当前函数的执行，并立即返回，如果指定了 expression，那么该表达式的值会被认作函数的返回值<code>return [expression]</code></p>
<p>如果你的调试断点在某个函数中，并还有语句没有执行完。你可以使用 return 命令强制函数忽略还没有执行的语句并返回。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://blog.csdn.net/haoel/article/details/2879" target="_blank" rel="external">http://blog.csdn.net/haoel/article/details/2879</a><br>（完）</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;GDB 是 UNIX 及 UNIX-like 下的调试工具。&lt;br&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://github.com/Sword2G/sword2g.github.io/categories/Linux/"/>
    
    
      <category term="GDB" scheme="https://github.com/Sword2G/sword2g.github.io/tags/GDB/"/>
    
  </entry>
  
  <entry>
    <title>Linux Kernel — System Calls</title>
    <link href="https://github.com/Sword2G/sword2g.github.io/2016/07/19/Linux-kernel-systemcall/"/>
    <id>https://github.com/Sword2G/sword2g.github.io/2016/07/19/Linux-kernel-systemcall/</id>
    <published>2016-07-19T14:24:26.000Z</published>
    <updated>2016-12-28T14:30:27.504Z</updated>
    
    <content type="html"><![CDATA[<p>Linux 内核中设置了一组用于实现系统功能的子程序，称为系统调用。系统调用和普通库函数调用非常相似，只是系统调用由内核提供，运行于内核态，而普通的函数调用由函数库或用户自己提供，运行于用户态。<br><a id="more"></a></p>
<h1 id="系统调用的作用"><a href="#系统调用的作用" class="headerlink" title="系统调用的作用"></a>系统调用的作用</h1><p>系统调用在用户空间进程和硬件设备之间添加了一个中间层。它的作用有两个：</p>
<ul>
<li><p>为用户空间提供一个抽象的访问硬件资源的接口，即屏蔽了具体的硬件细节。如，在读写文件时，应用程序不用去关心存储介质的类型，所使用的文件系统。</p>
</li>
<li><p>系统调用保证了系统的稳定和安全。系统调用对资源的访问必须遵循一定的规则与限制，防止应用程序非法访问没有权限的软硬件资源。</p>
</li>
</ul>
<h1 id="系统调用-API-C库"><a href="#系统调用-API-C库" class="headerlink" title="系统调用/API/C库"></a>系统调用/API/C库</h1><h2 id="系统调用与-API"><a href="#系统调用与-API" class="headerlink" title="系统调用与 API"></a>系统调用与 API</h2><p>一般情况下，应用程序通过使用在用户空间实现的 API (应用程序编程接口)来获得所需的功能，而不是直接调用系统调用，可以说， API 是系统调用的一种封装。API 可以被看做是系统调用所实现功能的一种使用途径，也就是说应用程序一般通过 API 来使用系统调用。一个 API 可以在多个不同的操作系统中实现，给应用程序提供相同的接口，但是具体的实现可能迥然不同。</p>
<h2 id="API-与-C-库"><a href="#API-与-C-库" class="headerlink" title="API 与 C 库"></a>API 与 C 库</h2><p>操作系统 API 通常都以 C 库的方式提供，C 库实现了 UNIX 系统的主要 API。C 库提供了 POSIX 的绝大部分 API，同时，内核提供的每个系统调用在 C 库中都具有相应的封装函数。系统调用与其 C 库封装函数的名称常常相同，比如，read 系统调用在 C 库中的封装函数即为 read 函数。C 库中的系统调用封装函数在最终调用到相应系统调用之前，往往不做多少额外的工作。</p>
<p>但是系统调用和 C 库函数之间并不是一一对应的关系，一个 C 库函数包含 0 到多个系统调用，从而提供比系统调用更加复杂的功能。</p>
<h2 id="C-库与系统命令"><a href="#C-库与系统命令" class="headerlink" title="C 库与系统命令"></a>C 库与系统命令</h2><p>系统命令位于 C 库的更上层，是利用 C 库实现的可执行程序，比如最为常用的 ls、cd 等命令。</p>
<p>简单的来说，系统调用是内核提供某一服务的接口，而 API(C 库) 是基于系统调用编写的功能更加完善的应用程序。从程序员的角度来看，系统调用无关紧要，只需要和 API 打交道，而从内核的角度来看，并不需要知道应用程序如何使用系统调用，只要实现该系统调用所要完成的功能即可。</p>
<h1 id="系统调用号"><a href="#系统调用号" class="headerlink" title="系统调用号"></a>系统调用号</h1><p>在 Linux 中，每个系统调用都被赋予一个系统调用号，其对应关系存储在 sys_call_table (系统调用表)中。在x86-64中，他定义于 arch/i386/kernel/syscall_64.c 文件中，这样就可以通过这个独一无二的系统调用号关联相应的系统调用。当用户空间执行一个系统调用的时候就可以指明到底是执行哪一个系统调用而不会提及系统调用的名称。</p>
<p>系统调用号一经分配就不可以表更，否则编译好的应用程序就会崩溃。即使该系统调用已删除也不能回收其对应的系统调用号，对于无效的系统调用号，其系统调用处理服务例程会被设置为 sys_ni_syscall(),它除了返回 -ENOSYS 外不做任何其他工作，它的存在就是为了”填补空缺”。</p>
<h1 id="系统调用处理函数"><a href="#系统调用处理函数" class="headerlink" title="系统调用处理函数"></a>系统调用处理函数</h1><p>系统调用运行在内核空间中，应用程序一般运行在用户空间。所以应用程序需要以某种方式通知系统，告诉内核需要切换到内核态（陷入内核），执行一个系统调用，从而让内核代表应用程序在内核空间执行系统调用，。</p>
<h2 id="系统调用与中断"><a href="#系统调用与中断" class="headerlink" title="系统调用与中断"></a>系统调用与中断</h2><p>操作系统通知内核陷入的机制是靠软中断来实现的： 通过引发一个异常促使系统切换到内核态去执行异常处理函数，而这个异常处理程序就是系统调用处理程序。在 X86 中，通过int $0X80 指令触发该异常，导致系统切换到内核态并执行 128 号中断的异常处理程序，该程序即系统调用处理程序(sys_call()，在arch/i386/kernel/entry.S 中，以汇编语言编写)。</p>
<h1 id="系统调用服务例程"><a href="#系统调用服务例程" class="headerlink" title="系统调用服务例程"></a>系统调用服务例程</h1><p>所有系统调用陷入内核的方式都是一样的，系统调用处理函数只是作为所有系统调用的入口函数，所以仅仅陷入内核是不够的，系统需要通过 system_call() 函数派发真正实现系统调用的系统调用服务例程。</p>
<h2 id="系统调用号与参数传递"><a href="#系统调用号与参数传递" class="headerlink" title="系统调用号与参数传递"></a>系统调用号与参数传递</h2><p>system_call() 函数可以读取 寄存器 eax 获得当前系统调用的系统调用号，将其乘以 4 生成偏移地址，然后以 sys_call_table 为基址，基址加上偏移地址所指向的内容即是应该执行的系统调用服务例程的地址，然后就可执行对应的系统调用服务例程了。进入 system_call() 函数前(陷入内核前)，系统调用服务例程所需的其他参数参数会被依次存放到 ebx、ecx、edx、esi 以及 edi 寄存器中，system_call() 函数执行时会首先将这些寄存器压入堆栈,从而将参数从用户空间传给内核，<br>对于系统调用服务例程，可以直接从 system_call() 函数压入的堆栈中获得参数。</p>
<p>给用户空间的返回值也是通过寄存器来传递的。在 X86 系统上，它存放在 eax 中。</p>
<h1 id="系统调用执行过程"><a href="#系统调用执行过程" class="headerlink" title="系统调用执行过程"></a>系统调用执行过程</h1><p>系统调用执行过程分为两个阶段：</p>
<ul>
<li>用户空间到内核空间的转换阶段</li>
<li>系统调用处理程序 system_call() 函数到系统调用服务例程的阶段</li>
</ul>
<p><img src="http://7xum8m.com1.z0.glb.clouddn.com/syscall_user2sys.jpg" alt="用户空间到内核空间"></p>
<p><img src="http://7xum8m.com1.z0.glb.clouddn.com/syscall_systemcall.jpg" alt="system_call函数到系统调用服务例程"></p>
<h2 id="read-系统调用"><a href="#read-系统调用" class="headerlink" title="read() 系统调用"></a>read() 系统调用</h2><p>read() 系统调用在内核中被定义成 sys_read(),系统调用都遵循这一命名规则。</p>
<p><img src="http://7xum8m.com1.z0.glb.clouddn.com/syscall_read.jpg" alt="read系统调用"></p>
<h1 id="系统调用的使用"><a href="#系统调用的使用" class="headerlink" title="系统调用的使用"></a>系统调用的使用</h1><h2 id="系统调用的调用"><a href="#系统调用的调用" class="headerlink" title="系统调用的调用"></a>系统调用的调用</h2><ul>
<li><p>通过库函数使用。通常系统调用靠 C 库支持，用户程序通过包含标准头文件并和C库链接，通过 C 库函数使用系统调用。</p>
</li>
<li><p>通过_syscalln() 宏直接使用系统调用。（include/asm-x86/Unistd_64.h中定义了一组宏）</p>
</li>
</ul>
<p><img src="http://7xum8m.com1.z0.glb.clouddn.com/syscall_the_way2use_systemcall.jpg" alt="使用系统调用的两种方式"></p>
<p>对于 _syscalln() 宏，其中的n范围从 0 到 6 ，代表传递给系统调用的参数的个数。如<br>系统调用 open() 定义为 <code>long open(const char *filename, int flags, int mode)</code>，其系统调用宏的形式为</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 系统调用号</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_open 5</span></div><div class="line"><span class="comment">// _syscalln 宏</span></div><div class="line">_syscall13(<span class="keyword">long</span>, <span class="built_in">open</span>, <span class="keyword">const</span> <span class="keyword">char</span> *, filename, <span class="keyword">int</span>, flags, <span class="keyword">int</span>, mode)</div></pre></td></tr></table></figure>
<p>每个宏都有 2 + 2 * n 个参数，第一个参数是返回值类型，第二个参数是系统调用的名称，剩下的依次为参数的类型和名称。</p>
<h2 id="系统调用的返回值"><a href="#系统调用的返回值" class="headerlink" title="系统调用的返回值"></a>系统调用的返回值</h2><p>系统调用会通过一个 long 类型的返回值表示成功或失败。通常 0 便是成功，负值表示失败。系统调用子啊失败的时候 C 库会将错误码写入全局变量 errno 中，通过调用 perror() 库函数，可以把该变量翻译成用户可以理解的错误字符串。</p>
<h1 id="系统调用上下文"><a href="#系统调用上下文" class="headerlink" title="系统调用上下文"></a>系统调用上下文</h1><p>内核在执行系统调用的时候处于进程上下文。current指针指向当前任务，即引发系统调用的那个进程。在进程上下文中，内核可以休眠并且可以被抢占。这两点都很重要。首先，能够休眠说明系统调用可以使用内核提供的绝大部分功能。休眠的能力会给内核编程带来极大便利。在进程上下文中能够被抢占，其实表明，像用户空间内的进程一样，当前的进程同样可以被其他进程抢占。因为新的进程可以使用相同的系统调用，所以必须小心，保证该系统调用是可重人的。当然，这也是在对称多处理中必须同样关心的问题。当系统调用返回的时候，控制权仍然在system_call()中，它最终会负责切换到用户空间并让用户进程继续执行下去。</p>
<h1 id="系统调用的添加"><a href="#系统调用的添加" class="headerlink" title="系统调用的添加"></a>系统调用的添加</h1><p>添加系统调用需要四个步骤：</p>
<ul>
<li>编写系统调用服务例程()声明中需要 asmlinkage 限定词，注意函数名为 sys_xxx)</li>
<li>添加系统调用号(在 include/asm-x86/Unistd_32.h 中，)</li>
<li>添加到系统调用表(entry.s 中)</li>
<li>重新编译内核并测试新添加的系统调用(系统调用必须编译进内核，不能编译成模块)</li>
</ul>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="http://blog.csdn.net/skyflying2012/article/details/10044343" target="_blank" rel="external">http://blog.csdn.net/skyflying2012/article/details/10044343</a><br><a href="https://book.douban.com/subject/4895627/" target="_blank" rel="external">https://book.douban.com/subject/4895627/</a><br>（完）</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Linux 内核中设置了一组用于实现系统功能的子程序，称为系统调用。系统调用和普通库函数调用非常相似，只是系统调用由内核提供，运行于内核态，而普通的函数调用由函数库或用户自己提供，运行于用户态。&lt;br&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://github.com/Sword2G/sword2g.github.io/categories/Linux/"/>
    
    
      <category term="Linux Kernel" scheme="https://github.com/Sword2G/sword2g.github.io/tags/Linux-Kernel/"/>
    
  </entry>
  
  <entry>
    <title>Linux Kernel — Process Management</title>
    <link href="https://github.com/Sword2G/sword2g.github.io/2016/07/15/Linux-kernel-Process-Management/"/>
    <id>https://github.com/Sword2G/sword2g.github.io/2016/07/15/Linux-kernel-Process-Management/</id>
    <published>2016-07-15T14:52:22.000Z</published>
    <updated>2016-12-27T15:08:47.107Z</updated>
    
    <content type="html"><![CDATA[<p>进程不同于存储在存储介质上的程序，它是处于执行期的程序和与之相关的资源的总称。<br><a id="more"></a></p>
<h1 id="Linux进程和线程"><a href="#Linux进程和线程" class="headerlink" title="Linux进程和线程"></a>Linux进程和线程</h1><p>Linux 并不区分进程和线程。不同于 Microsoft Windows，对 Linux 而言，线程是一种轻量级进程（lightweight processes）。实际上，Linux 进程本身也足够轻量（Linux进程的创建所花时间比其他操作系统要少很多）。</p>
<p>举例来说，假设有一个包含四个线程的进程，Linux 直接创建四个进程，这四个进程共享资源，而对于其他操作系统来说，通常会创建一个进程，并用相应的指针指向此进程中包含的四个线程。</p>
<h1 id="task-struct-与-task-list"><a href="#task-struct-与-task-list" class="headerlink" title="task_struct 与 task list"></a>task_struct 与 task list</h1><p>Linux 内核中进程的信息主要保存在 task_struct 结构中,每个进程都有一个 task_struct 结构与之对应，而一个个 task_struct 结构是通过 task list (任务队列)这个双向循环链表组织起来。也就是说从任意一个 task_struct 开始，可以很轻松的遍历系统中的所有进程。但是在一个拥有大量进程的系统中通过重复来遍历所欲进程代价是很大的，因此尽量避免这样做。</p>
<h1 id="task-struct-定义"><a href="#task-struct-定义" class="headerlink" title="task_struct 定义"></a>task_struct 定义</h1><p>task_struct 结构定义在 /include/linux/sched.h 中<br>部分字段如下</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span></span> &#123;</div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 进程状态，如TASK_RUNNING</div><div class="line">	 */</div><div class="line">	volatile long state;	<span class="comment">/* -1 unrunnable, 0 runnable, &gt;0 stopped */</span></div><div class="line">	void *stack;</div><div class="line">	atomic_t usage;</div><div class="line">	unsigned <span class="keyword">int</span> flags;	<span class="comment">/* per process flags, defined below */</span></div><div class="line">	unsigned <span class="keyword">int</span> ptrace;</div><div class="line"></div><div class="line">	<span class="keyword">int</span> lock_depth;		<span class="comment">/* BKL lock depth */</span></div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * static_prio:进程的静态优先级，由启动时分配，nice和sched_setscheduler修改</div><div class="line">	 * prio和normal_prio是动态优先级。</div><div class="line">	 * normal_prio是由调度策略和静态优先级计算出来的优先级。</div><div class="line">	 * prio是运行时的动态优先级。某些情况下内核可能会暂时提升进程的优先级。如优先级继承。</div><div class="line">	 */</div><div class="line">	<span class="keyword">int</span> prio, static_prio, normal_prio;</div><div class="line">	<span class="comment">/* 对于RR实时进程，通过此字段将它加入到RR链表 */</span></div><div class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span></span> run_list;</div><div class="line">	<span class="comment">/* 进程所属的调度器类 */</span></div><div class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">sched_class</span></span> *sched_class;</div><div class="line">	<span class="comment">/* sched_entity代表一个调度实体，一个调度实体包含一组进程。这个功能用于cgroup */</span></div><div class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sched_entity</span></span> se;</div><div class="line"></div><div class="line">	unsigned short ioprio;</div><div class="line"></div><div class="line">	<span class="comment">/* 进程的调度策略，如SCHED_NORMAL */</span></div><div class="line">	unsigned <span class="keyword">int</span> policy;</div><div class="line">	<span class="comment">/* 进程的CPU亲和性 */</span></div><div class="line">	cpumask_t cpus_allowed;</div><div class="line">	<span class="comment">/* 对于RR进程来说，此字段表示进程可使用CPU的剩余时间段 */</span></div><div class="line">	unsigned <span class="keyword">int</span> time_slice;</div><div class="line"></div><div class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span></span> tasks;</div><div class="line"></div><div class="line">	<span class="comment">/* 分别代表用户态地址空间和实际使用的地址空间 */</span></div><div class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span></span> *mm, *active_mm;</div><div class="line"></div><div class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span></span> *real_parent; <span class="comment">/* real parent process (when being debugged) */</span></div><div class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span></span> *parent;	<span class="comment">/* parent process */</span></div><div class="line">	<span class="comment">/*</span></div><div class="line">	 * children/sibling forms the list of my children plus the</div><div class="line">	 * tasks I'm ptracing.</div><div class="line">	 */</div><div class="line">	<span class="comment">/* 子进程链表头 */</span></div><div class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span></span> children;	<span class="comment">/* list of my children */</span></div><div class="line">	<span class="comment">/* 通过此字段链接到父进程的children链表 */</span></div><div class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span></span> sibling;	<span class="comment">/* linkage in my parent's children list */</span></div><div class="line">	<span class="comment">/* 线程组的领头进程结构 */</span></div><div class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span></span> *group_leader;	<span class="comment">/* threadgroup leader */</span></div><div class="line"></div><div class="line">	<span class="comment">/* PID/PID hash table linkage. */</span></div><div class="line">	<span class="comment">/* 将进程链接到全局pid_hash哈希表的结构 */</span></div><div class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pid_link</span></span> pids[PIDTYPE_MAX];</div><div class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span></span> thread_group;</div><div class="line"></div><div class="line"><span class="comment">/* CPU-specific state of this task */</span></div><div class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">thread_struct</span></span> thread;</div><div class="line"><span class="comment">/* filesystem information */</span></div><div class="line">	<span class="comment">/* 进程文件系统相关信息，如当前目录 */</span></div><div class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fs_struct</span></span> *fs;</div><div class="line"><span class="comment">/* open file information */</span></div><div class="line">	<span class="comment">/* 当前进程的文件描述符 */</span></div><div class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">files_struct</span></span> *files;</div><div class="line"><span class="comment">/* namespaces */</span></div><div class="line">	<span class="comment">/* 进程所属命名空间 */</span></div><div class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nsproxy</span></span> *nsproxy;</div><div class="line"><span class="comment">/* signal handlers */</span></div><div class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">signal_struct</span></span> *signal;</div><div class="line">	<span class="comment">/* 用于管理用户设置的信号处理程序 */</span></div><div class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sighand_struct</span></span> *sighand;</div><div class="line"></div><div class="line">	<span class="comment">/* 所有阻塞的信号，是一个位掩码 */</span></div><div class="line">	sigset_t blocked, real_blocked;</div><div class="line">	sigset_t saved_sigmask;		<span class="comment">/* To be restored with TIF_RESTORE_SIGMASK */</span></div><div class="line">	<span class="comment">/* 已经触发、有待处理的信号链表 */</span></div><div class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sigpending</span></span> pending;</div><div class="line"></div><div class="line">	<span class="comment">/* 用户态信号处理栈地址及长度 */</span></div><div class="line">	unsigned long sas_ss_sp;</div><div class="line">	<span class="comment">//进程id</span></div><div class="line">	pid_t pid;</div><div class="line">	...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="task-struct-的分配"><a href="#task-struct-的分配" class="headerlink" title="task_struct 的分配"></a>task_struct 的分配</h1><p>进程是动态的实体，生命周期不固定，因此内核必须能够处理很多进程，并把 task_struct 存放在动态内存中，而不是放在内核内存区。Linux 是通过 slab 分配器给 task_struct 分配内存的，这样能够达到对象复用和和缓存着色 (cache coloring)的作用。</p>
<p>实际上，对于每个进程来说，Linux 通过把两个不同的数据结构紧凑的存放在一个单独为进程分配的内存区，一个是与 task_struct 相关的 thread_info 结构，另一个是内核态的进程堆栈，通常这块内存区占两个页框（8KB = 8192 Byte 或者4KB = 4096 Byte）。2.6 以前的内核直接将 task_struct 存放在内核栈的尾端，但现在只在内核栈的尾端存放一个较小的 thread_info 结构，该结构中有一个指向通过 slab 分配的 task_struct 结构的指针。</p>
<p>进程内核堆栈和 thread_info 的布局如下<br><img src="http://7xum8m.com1.z0.glb.clouddn.com/process_pthread_info.jpg" alt=""></p>
<p>thread_info 结构定义在 include/asm-x86（Thread_info32.h 后者Thread_in64.h）中<br>部分代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> thread_info &#123;</div><div class="line">	<span class="comment">/* 指向对应的task_struct结构 */</span></div><div class="line">	<span class="keyword">struct</span> task_struct	*task;		<span class="comment">/* main task structure */</span></div><div class="line">	<span class="comment">/* 执行域，一般用于64位机器上运行32位程序 */</span></div><div class="line">	<span class="keyword">struct</span> exec_domain	*exec_domain;	<span class="comment">/* execution domain */</span></div><div class="line">	<span class="comment">/* 进程标志，如TIF_SIGPENDING */</span></div><div class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		flags;		<span class="comment">/* low level flags */</span></div><div class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		status;		<span class="comment">/* thread-synchronous flags */</span></div><div class="line">	<span class="comment">/* 当前运行在哪个CPU上 */</span></div><div class="line">	__u32			cpu;		<span class="comment">/* current CPU */</span></div><div class="line">	<span class="comment">/* 抢占计数 */</span></div><div class="line">	<span class="keyword">int</span>			preempt_count;	<span class="comment">/* 0 =&gt; preemptable, &lt;0 =&gt; BUG */</span></div><div class="line">	...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="task-struct-的存放"><a href="#task-struct-的存放" class="headerlink" title="task_struct 的存放"></a>task_struct 的存放</h1><p>内核通过唯一的进程标识符pid来标识每个进程。pid字段存放在 task_struct 结构中的 pid 字段。通常可以通过current宏（该宏等价于current_thread_info()-&gt;task）来快速获得正在运行进程的 thread_info 结构，然后获得对应的 task_struct 结构指针，内核对进程的所有操作都是通过对 task_struct 结构操作来完成的。</p>
<h2 id="进程的状态"><a href="#进程的状态" class="headerlink" title="进程的状态"></a>进程的状态</h2><h3 id="TASK-RUNNING"><a href="#TASK-RUNNING" class="headerlink" title="TASK_RUNNING"></a>TASK_RUNNING</h3><p>可运行状态。进程是可运行状态，或正在运行。 对应 ps 中的 R 状态。</p>
<h3 id="TASK-INTERRUPTIBLE"><a href="#TASK-INTERRUPTIBLE" class="headerlink" title="TASK_INTERRUPTIBLE"></a>TASK_INTERRUPTIBLE</h3><p>可中断睡眠状态。可以响应异步信号，处于这个状态的进程因为等待某某事件的发生（比如等待 socket 连接、等待信号量），而被挂起，处于睡眠(阻塞)状态。这些进程的 task_struct 结构被放入对应事件的等待队列中。当这些事件发生时（由外部中断触发、或由其他进程触发），对应的等待队列中的一个或多个进程将被唤醒。 对应 ps 中的 S 状态。</p>
<h3 id="TASK-UNINTERRUPTIBLE"><a href="#TASK-UNINTERRUPTIBLE" class="headerlink" title="TASK_UNINTERRUPTIBLE"></a>TASK_UNINTERRUPTIBLE</h3><p>不可中断睡眠状态。与 TASK_INTERRUPTIBLE 状态类似，进程处于睡眠状态，但是此刻进程是不可中断的。不可中断，指的并不是 CPU 不响应外部硬件的中断，而是指进程不响应异步信号。<br>绝大多数情况下，进程处在睡眠状态时，总是应该能够响应异步信号的。处于这种状态下的进程 kill -9 发送 SIGKILL 信号是无法杀死该进程的。<br>ps 命令看到的进程几乎不会出现 TASK_UNINTERRUPTIBLE 状态，TASK_UNINTERRUPTIBLE 状态总是非常短暂的，通过 ps命令基本上不可能捕捉到，对应 ps 中的 D 状态。</p>
<h3 id="TASK-UNINTERRUPTIBLE-1"><a href="#TASK-UNINTERRUPTIBLE-1" class="headerlink" title="TASK_UNINTERRUPTIBLE"></a>TASK_UNINTERRUPTIBLE</h3><p>状态存在的意义就在于，内核的某些处理流程是不能被打断的。如果响应异步信号，程序的执行流程中就会被插入一段用于处理异步信号的流程（信号处理函数，这个插入的流程可能只存在于内核态，也可能延伸到用户态），于是原有的流程就被中断了。<br>在进程对某些硬件进行操作时（比如进程调用 read 系统调用对某个设备文件进行读操作，而 read 系统调用最终执行到对应设备驱动的代码，并与对应的物理设备进行交互），可能需要使用 TASK_UNINTERRUPTIBLE 状态对进程进行保护，以避免进程与设备交互的过程被打断，造成设备陷入不可控的状态。</p>
<h3 id="TASK-TRACED"><a href="#TASK-TRACED" class="headerlink" title="TASK_TRACED"></a>TASK_TRACED</h3><p>被跟踪状态。当进程正在被跟踪时，它处于 TASK_TRACED 这个特殊的状态。“正在被跟踪”指的是进程暂停下来，等待跟踪它的进程对它进行操作。比如在 gdb 中对被跟踪的进程下一个断点，进程在断点处停下来的时候就处于 TASK_TRACED 状态。而在其他时候，被跟踪的进程还是处于前面提到的那些状态。对应 ps 中的 T 状态。</p>
<h3 id="TASK-STOPPED"><a href="#TASK-STOPPED" class="headerlink" title="TASK_STOPPED"></a>TASK_STOPPED</h3><p>停止状态。向进程发送一个 SIGSTOP 信号，它就会因响应该信号而进入 TASK_STOPPED 状态（除非该进程本身处于 TASK_UNINTERRUPTIBLE 状态而不响应信号）对应 ps 中的 T 状态。</p>
<blockquote>
<p>TASK_STOPPED 和 TASK_TRACED 状态很类似，都是表示进程暂停下来。<br>而 TASK_TRACED 状态相当于在 TASK_STOPPED 之上多了一层保护，处于 TASK_TRACED 状态的进程不能响应 SIGCONT 信号而被唤醒。只能等到调试进程通过 ptrace 系统调用执行 PTRACE_CONT、PTRACE_DETACH 等操作（通过 ptrace 系统调用的参数指定操作），或调试进程退出，被调试的进程才能恢复 TASK_RUNNING 状态。</p>
</blockquote>
<h3 id="EXIT-ZOMBIE"><a href="#EXIT-ZOMBIE" class="headerlink" title="EXIT_ZOMBIE"></a>EXIT_ZOMBIE</h3><p>僵死状态。进程已经退出，等待父进程调用 wait 类函数，获取其 task_struct 中保存的退出状态，释放相应的 task_struct 结构（现在已经是空壳尸体，只有很少的字段有意义，用于保存进程的退出码和一些统计信息）。</p>
<h2 id="进程状态转换"><a href="#进程状态转换" class="headerlink" title="进程状态转换"></a>进程状态转换</h2><p><img src="http://7xum8m.com1.z0.glb.clouddn.com/process_status_switch.jpg" alt="进程状态转换"></p>
<h2 id="进程的家族"><a href="#进程的家族" class="headerlink" title="进程的家族"></a>进程的家族</h2><p>task_struct 中的 parent 指针指向其父进程的 task_struct，children 指针指向其子进程链表，sibling 指针指向其兄弟进程的进程链表</p>
<h1 id="进程的创建"><a href="#进程的创建" class="headerlink" title="进程的创建"></a>进程的创建</h1><h2 id="fork-and-exec"><a href="#fork-and-exec" class="headerlink" title="fork and exec"></a>fork and exec</h2><p>Linux 创建进程分为两步：</p>
<ul>
<li>fork() 拷贝当前进程映像</li>
<li>exec() 读取可执行文件并将其载入地址空间运行</li>
</ul>
<h2 id="copy-on-write"><a href="#copy-on-write" class="headerlink" title="copy-on-write"></a>copy-on-write</h2><p>传统的 fork() 直接将父进程的所有资源拷贝到子进程，但是很多时候这个操作是没有意义的，子进程可能马上就通过exec()执行新的程序那么前面进行的拷贝就毫无意义。copy-on-write 机制允许资源的拷贝在需要写的时候再进行，在此之前，以只读的方式与父进程共享同一地址空间，这种延迟拷贝机制节省了很多时间，避免了大量的拷贝。</p>
<h2 id="fork"><a href="#fork" class="headerlink" title="fork()"></a>fork()</h2><p>fork()函数的实现是通过调用 clone()系统调用来实现的。实际上 fork、vfork 还有线程的创建都是通过向 clone 系统调用传送不同的参数进行的，clone() 函数会调用 do_fork() 函数，它定义在 kernel/fork.c 中。do_fork()中的主要工作由 copy_process() 来完成，具体创建流程如下：</p>
<ul>
<li>调用 dup_task_struct() 为新进程分配内核栈、thread_info、task_struct 等，其中的内容与父进程相同</li>
<li>清理新进程 task_struct 结构字段，很多字段清 0 或设为初始值，使之与父进程区别开</li>
<li>新进程状态置为 TASK_UNINTERRUPTIBLE，保证不会投入运行</li>
<li>调用 copy_flags() 更新 task_struct 的 flags 成员。</li>
<li>调用 alloc_pid() 为新进程分配一个有效的 PID</li>
<li>根据 clone() 的参数标志，拷贝共享的打开文件、文件系统信息、信号处理函数、进程地址空间、命名空间等</li>
<li>做一些扫尾工作并返回子进程的指针</li>
</ul>
<p>返回 do_fork() 子进程被唤醒，并投入运行，一般来说内核有意选择子进程先执行。</p>
<h2 id="vfork"><a href="#vfork" class="headerlink" title="vfork()"></a>vfork()</h2><p>类似与 fork() 函数，只是调用 clone() 系统调用时传递的参数不同，通过 vfork()创建子进程，父进程会被阻塞，直到子进程退出或执行 exec() 函数</p>
<h2 id="线程的创建"><a href="#线程的创建" class="headerlink" title="线程的创建"></a>线程的创建</h2><p>Linux 并区分进程和线程，线程的创建与进程的创建类似，都是抵用 clone() 系统调用，传入一些参数指明需要共享的资源。<br><code>clone(CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND, 0);</code>，产生的结构与 fork() 类似，只是父子进程共享地址空间、文件系统资源、文件描述符和信号处理程序。</p>
<p>普通的 fork() 通过 <code>clone(SIGCHLD, 0)</code>实现，vfork() 通过 <code>clone(CLONE_VFORK | CLONE_VM | SIGCHLD, 0)</code>实现。</p>
<h2 id="内核线程的创建"><a href="#内核线程的创建" class="headerlink" title="内核线程的创建"></a>内核线程的创建</h2><p>内核线程和普通线程区别在于内核线程没有独立的地址空间（task_struct 中 mm 字段为NULL）。只在内核空间运行，从不切换到用户空间。</p>
<p>内核线程是由 kthread 内核线程通过调用 clone() 系统调用创建。<br><code>struct task_struct *kthread_create(int (*threadfn)(void *data), void *data, const char namefmt[], ...)</code><br>新的进程将运行 threadfn 函数， 参数为 data，进程名为 namefmt，新创建的线程处于不可运行状态，需要调用 wake_up_process() 明确的唤醒它。</p>
<h3 id="常见的内核线程"><a href="#常见的内核线程" class="headerlink" title="常见的内核线程"></a>常见的内核线程</h3><ul>
<li>keventd 执行 keventd_wq 工作队列当</li>
<li>kapmd 处理高级电源管理事件</li>
<li>kswapd 执行内存回收</li>
<li>pdflush 刷新缓存脏数据到磁盘</li>
</ul>
<h2 id="进程的终止"><a href="#进程的终止" class="headerlink" title="进程的终止"></a>进程的终止</h2><p>当一个进程终止时，内核必须释放它所占有的资源并向其父进程发送 SIGCHLD 信号，告知其父进程。<br>进程的析构发生在进程调用 exit() 系统调用时，既可能显示的调用也可能隐式的调用，比如从某个函数的主函数返回(c编译器会在main函数的返回点后面放置 exit() 的代码)当进程接收到它既不能处理也不能忽略的信号或异常时，也可能被动的终止。进程终止的大部分工作由 do_exit() 函数(定义在kernel/exit.c文件中)来完成，其流程如下：</p>
<ul>
<li>将task_struct flags字段设为 PF_EXITING</li>
<li>调用 edl_timer_sync() 删除任一定时器</li>
<li>调用 acct_update_integrals() 输出记账信息</li>
<li>调用 exit_mm() 释放占用的 mm_struct ，如果没有进程使用它则直接释放</li>
<li>调用 sem_exit() 释放用户空间的“信号量”</li>
<li>调用 exit_files() 递减文件描述符，调用 exit_fs() 递减文件系统数据引用计数，计数为 0 则释放<br>将 task_struct 中的 exit_code 字段设置为 exit() 函数的参数</li>
<li>调用 exit_notify() 函数通知父进程，若父进程已经退出，则会寻找新的父进程，并把task_struct 中exit_state 字段设置为 EXIT_ZOMBIE</li>
<li>调用 schedule() 切换到新进程（处于 EXIT_ZOMBIE 状态的进程将会被忽略）</li>
</ul>
<h2 id="孤儿进程"><a href="#孤儿进程" class="headerlink" title="孤儿进程"></a>孤儿进程</h2><p>如果父进程比子进程先退出，子进程就会成为孤儿进程，在子进程退出的时候没有相应的父进程来获取其退出状态，这些孤儿进程就会永远处于僵死状态，白白消耗内存。所以 Linux 的机制是先尝试在同一线程组中找一个线程作为其父进程，如果不行，则这些孤儿进程由 init 进程收养。</p>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="http://blog.csdn.net/brucexu1978/article/details/7721313" target="_blank" rel="external">http://blog.csdn.net/brucexu1978/article/details/7721313</a><br><a href="https://book.douban.com/subject/6097773/" target="_blank" rel="external">https://book.douban.com/subject/6097773/</a><br>（完）</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;进程不同于存储在存储介质上的程序，它是处于执行期的程序和与之相关的资源的总称。&lt;br&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://github.com/Sword2G/sword2g.github.io/categories/Linux/"/>
    
    
      <category term="Linux Kernel" scheme="https://github.com/Sword2G/sword2g.github.io/tags/Linux-Kernel/"/>
    
  </entry>
  
  <entry>
    <title>Linux 下静/动态链接库的使用</title>
    <link href="https://github.com/Sword2G/sword2g.github.io/2016/07/11/build-lib/"/>
    <id>https://github.com/Sword2G/sword2g.github.io/2016/07/11/build-lib/</id>
    <published>2016-07-11T14:31:02.000Z</published>
    <updated>2017-03-03T05:36:04.713Z</updated>
    
    <content type="html"><![CDATA[<p>静/动态链接库文件都是obj目标文件的集合，静态链接库以”.a”为后缀，动态链接库以”.so”为后缀。<br><a id="more"></a></p>
<h1 id="静态链接库"><a href="#静态链接库" class="headerlink" title="静态链接库"></a>静态链接库</h1><p>静态链接库为后缀为”.a”，有 ar 生成，由于动态链接库的使用，静态链接库的使用已经没有原来那么普遍。</p>
<h2 id="静态链接库的优点"><a href="#静态链接库的优点" class="headerlink" title="静态链接库的优点"></a>静态链接库的优点</h2><ul>
<li>不用重新编译库代码的情况下，重新进行程序链接，节省了编译时间</li>
<li>库开发者可以通过提供库文件给使用者使用，而不开源代码</li>
<li>使程序的开发模块化</li>
</ul>
<h2 id="静态链接库的生成"><a href="#静态链接库的生成" class="headerlink" title="静态链接库的生成"></a>静态链接库的生成</h2><p>静态链接库由 ar 程序来生成，命令格式为 <code>ar libname objfile1 objfile2</code></p>
<h2 id="静态链接库的使用"><a href="#静态链接库的使用" class="headerlink" title="静态链接库的使用"></a>静态链接库的使用</h2><p>gcc 在链接静态链接库时可以像使用obj目标文件一样链接”.a”文件，也可以通过”-llibname”的形式使用库文件。</p>
<h1 id="动态链接库"><a href="#动态链接库" class="headerlink" title="动态链接库"></a>动态链接库</h1><p>动态链接库不同于静态链接库，静态链接库在链接时直接将库文件代码链接进程序，而动态链接库是在程序运行时加载的库，库中函数和变量的地址是相对地址不是绝对地址，其真实地址是在调用动态库的程序加载时形成的。</p>
<h2 id="动态链接库的别名、真名、链接名"><a href="#动态链接库的别名、真名、链接名" class="headerlink" title="动态链接库的别名、真名、链接名"></a>动态链接库的别名、真名、链接名</h2><p>动态链接库的别名形如 <strong>libXXX.so</strong>，真名一般是在别名的基础上加上主版本号、次版本号等；程序链接时使用的库名为链接名。在安装动态链接库的时候，总是要复制库文件到某个目录下，然后用软连接生成别名，在库文件更新的时候只用更新新的软链接即可。</p>
<h2 id="动态链接库的生成"><a href="#动态链接库的生成" class="headerlink" title="动态链接库的生成"></a>动态链接库的生成</h2><p>动态链接库的生成需要用到 gcc 的 <strong>-fPIC(-fpic) -shared</strong> 选项 <strong>-fPIC(-fpic)</strong> 的作用是使得 gcc 生成的代码是位置无关的；<strong>-share </strong>告诉编译器生成动态链接库。</p>
<h2 id="动态链接库的安装"><a href="#动态链接库的安装" class="headerlink" title="动态链接库的安装"></a>动态链接库的安装</h2><p>一般将生成的动态链接库复制到默认的动态链接库搜索路径下，如<strong>/lib、/usr/lib、/usr/local/lib</strong>,放到任意目录即可。</p>
<h2 id="动态链接库的使用"><a href="#动态链接库的使用" class="headerlink" title="动态链接库的使用"></a>动态链接库的使用</h2><p>与静态链接库的使用方法一样，通过”-l库名”的方式使用，在生成可执行文件的时候链接库文件。</p>
<p>但是程序在编译时链接动态链接库和运行时使用动态链接库概念是不同的，运行时程序链接的动态链接库需要在动态链接库的搜索路径中。</p>
<p>可以使用以下三种方式告诉系统到哪里去找动态链接库：</p>
<ul>
<li><p>把库文件拷贝到<strong>/usr/lib</strong>和<strong>/lib</strong>目录下</p>
</li>
<li><p>在<strong>LD_LIBRARY_PATH</strong>环境变量中加上库所在路径。例如动态库 libhello.so 在/home/speedy/test/lib目录下，以 bash 为例，使用命令：<br><code>$export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/home/speedy/test/lib</code><br>在环境变量LD_LIBRARY_PATH后添加/home/speedy/test/lib(<a href="http://prefetch.net/articles/linkers.badldlibrary.html" target="_blank" rel="external">不提倡这种用法</a>)</p>
</li>
<li><p><code>ldconfig path</code>将指定目录中的动态链接库放入<strong>/etc/ld.so.cache</strong>中，从而被共享。（运行该命令后再次运行不带参数的 ldconfig 会更新<strong>/etc/ld.so.cache</strong>，这是上述命令加入的库可能不在共享了）</p>
</li>
<li><p>修改<strong>/etc/ld.so.conf</strong>文件，把库所在的路径加到文件末尾，并执行<code>sudo ldconfig</code>刷新(需要超级用户权限)，或者在<strong>/etc/ld.so.conf.d/</strong>下建立单独的 xx.conf 文件，文件内容为库文件路径</p>
</li>
</ul>
<h2 id="动态链接库的管理"><a href="#动态链接库的管理" class="headerlink" title="动态链接库的管理"></a>动态链接库的管理</h2><p>为了让新增的动态链接库能够被系统共享，需要运行动态链接库的管理命令 ldconfig。ldconfig 的作用是搜索系统默认动态链接库路径(/lib、/usr/lib、/usr/local/lib)和动态链接库配置文件(/etc/ld.so.conf)中列出的搜素路径，创建动态链接库装入程序需要的链接 和缓存文件，并写入 /etc/ld.so.cache(其中保存的是已排好序的动态链接库名字列表)</p>
<p><strong>/etc/ld.so.conf</strong>是动态链接库的搜索配置文件。在这个文件中存放着可被 Linux共享的动态链接库所在目录的名称。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cat /etc/ld<span class="selector-class">.so</span><span class="selector-class">.conf</span></div><div class="line">include /etc/ld<span class="selector-class">.so</span><span class="selector-class">.conf</span><span class="selector-class">.d</span><span class="comment">/*.conf</span></div></pre></td></tr></table></figure>
<h1 id="ldd命令"><a href="#ldd命令" class="headerlink" title="ldd命令"></a>ldd命令</h1><p>通过ldd命令可以查看某程序当前对动态链接库的依赖情况<br><img src="http://7xum8m.com1.z0.glb.clouddn.com/ldd.jpg" alt="ldd"></p>
<h1 id="链接库实例"><a href="#链接库实例" class="headerlink" title="链接库实例"></a>链接库实例</h1><h2 id="代码组织结构"><a href="#代码组织结构" class="headerlink" title="代码组织结构"></a>代码组织结构</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">test/include/hello.h</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _HELLO_H_</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> _HELLO_H_</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div></pre></td></tr></table></figure>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">libtest/<span class="class"><span class="keyword">lib</span>/<span class="title">hello</span>.<span class="title">c</span></span></div><div class="line"></div><div class="line"><span class="comment">#include "hello.h"</span></div><div class="line"><span class="comment">#include &lt;stdio.h&gt;</span></div><div class="line"></div><div class="line">void hello()</div><div class="line">&#123;</div><div class="line">	printf(<span class="string">"hello world!\n"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">libtest/src/testlib.c</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"hello.h"</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span>* argv[])</span></span></div><div class="line">&#123;</div><div class="line">	hello();</div><div class="line"></div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="静态链接库-1"><a href="#静态链接库-1" class="headerlink" title="静态链接库"></a>静态链接库</h2><h3 id="静态链接库生成"><a href="#静态链接库生成" class="headerlink" title="静态链接库生成"></a>静态链接库生成</h3><figure class="highlight crystal"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">cd /test/<span class="class"><span class="keyword">lib</span></span></div><div class="line"></div><div class="line">gcc -c -o hello.o -I../<span class="keyword">include</span> hello.c </div><div class="line">ar -rc libhello.a hello.o</div></pre></td></tr></table></figure>
<h3 id="静态链接库使用"><a href="#静态链接库使用" class="headerlink" title="静态链接库使用"></a>静态链接库使用</h3><figure class="highlight crystal"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cd ~<span class="regexp">/test/src</span></div><div class="line">gcc -o testa  testlib.c -I../<span class="keyword">include</span> -L../<span class="class"><span class="keyword">lib</span> -<span class="title">lhello</span></span></div></pre></td></tr></table></figure>
<h3 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h3><p><img src="http://7xum8m.com1.z0.glb.clouddn.com/staticlib.jpg" alt=""></p>
<h2 id="动态链接库-1"><a href="#动态链接库-1" class="headerlink" title="动态链接库"></a>动态链接库</h2><h3 id="动态链接库生成"><a href="#动态链接库生成" class="headerlink" title="动态链接库生成"></a>动态链接库生成</h3><figure class="highlight crystal"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">cd /test/<span class="class"><span class="keyword">lib</span></span></div><div class="line"></div><div class="line">gcc -o libdyhello.so hello.c -I../<span class="keyword">include</span> -fpic -shared</div></pre></td></tr></table></figure>
<h3 id="动态链接库使用"><a href="#动态链接库使用" class="headerlink" title="动态链接库使用"></a>动态链接库使用</h3><figure class="highlight crystal"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">gcc -o testso testlib.c -I../<span class="keyword">include</span> -L../<span class="class"><span class="keyword">lib</span> -<span class="title">ldyhello</span> </span></div><div class="line"></div><div class="line">sudo cp ~<span class="regexp">/test/lib</span><span class="regexp">/libdyhello.so /usr</span><span class="regexp">/lib</span></div></pre></td></tr></table></figure>
<h3 id="运行结果-1"><a href="#运行结果-1" class="headerlink" title="运行结果"></a>运行结果</h3><p><img src="http://7xum8m.com1.z0.glb.clouddn.com/dynamiclib.jpg" alt=""></p>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="http://blog.csdn.net/dongtingzhizi/article/details/8261062" target="_blank" rel="external">http://blog.csdn.net/dongtingzhizi/article/details/8261062</a><br><a href="http://www.cnblogs.com/dyllove98/archive/2013/06/25/3155599.html" target="_blank" rel="external">http://www.cnblogs.com/dyllove98/archive/2013/06/25/3155599.html</a><br>（完）</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;静/动态链接库文件都是obj目标文件的集合，静态链接库以”.a”为后缀，动态链接库以”.so”为后缀。&lt;br&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://github.com/Sword2G/sword2g.github.io/categories/Linux/"/>
    
    
      <category term="PS3" scheme="https://github.com/Sword2G/sword2g.github.io/tags/PS3/"/>
    
      <category term="Games" scheme="https://github.com/Sword2G/sword2g.github.io/tags/Games/"/>
    
  </entry>
  
  <entry>
    <title>Struct 结构与内存对齐</title>
    <link href="https://github.com/Sword2G/sword2g.github.io/2016/07/06/byte-align/"/>
    <id>https://github.com/Sword2G/sword2g.github.io/2016/07/06/byte-align/</id>
    <published>2016-07-06T14:19:59.000Z</published>
    <updated>2016-12-27T14:30:21.656Z</updated>
    
    <content type="html"><![CDATA[<p>sizeof在计算结构体大小的时候并不是简单的将成员变量相加，计算时还需要考虑内存字节对齐的问题。<br><a id="more"></a></p>
<h1 id="字节对齐原因"><a href="#字节对齐原因" class="headerlink" title="字节对齐原因"></a>字节对齐原因</h1><p>1、平台原因(移植原因)：不是所有的硬件平台都能访问任意地址上的任意数据的；某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。</p>
<p>2、性能原因(空间换取时间)：数据结构(尤其是栈)应该尽可能地在自然边界上对齐。原因在于，为了访问未对齐的内存，处理器需要作两次内存访问；而对齐的内存访问仅需要一次访问<br>关于对齐的原因参考：<a href="http://www.ibm.com/developerworks/library/pa-dalign/" target="_blank" rel="external">Data alignment: Straighten up and fly right</a></p>
<h1 id="内存不对齐后果"><a href="#内存不对齐后果" class="headerlink" title="内存不对齐后果"></a>内存不对齐后果</h1><blockquote>
<p>If you don’t understand and address alignment issues in your software, the following scenarios, in increasing order of severity, are all possible:</p>
<pre><code>* Your software will run slower.
* Your application will lock up.
* Your operating system will crash.
* Your software will silently fail, yielding incorrect results.
</code></pre></blockquote>
<h1 id="字节对齐的规则"><a href="#字节对齐的规则" class="headerlink" title="字节对齐的规则"></a>字节对齐的规则</h1><p>内存字节对齐的具体规则是由编译器决定的，不同的编译环境，内存对齐的方式略有不同。<br>总的来说，内存对齐分两个方面。（都要与#pragma pack(n)中的 n 作比较，都不能大于 n）</p>
<h2 id="成员首地址对齐"><a href="#成员首地址对齐" class="headerlink" title="成员首地址对齐"></a>成员首地址对齐</h2><p>结构体每个成员存放首地址相对结构体首地址的偏移量是(最终)自身对齐参数的整数倍。<br>(最终)自身对齐参数 = min( 自身对齐参数，#pragma pack(n) )<br><img src="http://7xum8m.com1.z0.glb.clouddn.com/align_%E5%AF%B9%E9%BD%90.png" alt="对齐参数表"></p>
<p>在 windows(32)/VC6.0 下各种类型的变量的自身对齐参数就是该类型变量所占字节数的大小，而在 linux(32)/GCC 下 double 类型的变量自身对齐参数是 4 ，是因为 linux(32)/GCC 下如果该类型变量的长度没有超过 CPU 的字长，则以该类型变量的长度作为自身对齐参数，如果该类型变量的长度超过 CPU 字长，则自身对齐参数为 CPU 字长，而 32 位系统其 CPU 字长是 4，所以linux(32)/GCC 下 double 类型的变量自身对齐参数是 4。</p>
<h2 id="结构体所占空间对齐"><a href="#结构体所占空间对齐" class="headerlink" title="结构体所占空间对齐"></a>结构体所占空间对齐</h2><p>整个结构体变量所占空间的大小是（整体）对齐参数大小的整数倍。<br>（整体）对齐参数 = min( max( 所有成员(最终)自身对齐参数）, #pragma pack(n) )</p>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p>计算步骤：</p>
<ul>
<li>是否有#pragma pack(n)<br>没有==&gt; 首地址自身对齐，整个结构按最大成员对齐<br>有====&gt; 首地址自身对齐,整个结构大小对齐都要考虑 n 的大小</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//没有设置#pragma pack进行对齐时</span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">st1</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> a; <span class="comment">// 4</span></div><div class="line">    <span class="keyword">char</span> b; <span class="comment">//1 + 1(填充供下一个short两字节对齐)</span></div><div class="line">    short c; <span class="comment">// 2</span></div><div class="line">&#125;;</div><div class="line"><span class="comment">// 4 + 2 + 2 = 8 (已经两字节对齐)</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">st2</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">char</span> a; <span class="comment">// 1 + 3(填充供下一个int 四字节对齐)</span></div><div class="line">    <span class="keyword">int</span> b; <span class="comment">// 4</span></div><div class="line">    short c; <span class="comment">// 2</span></div><div class="line">&#125;;</div><div class="line"><span class="comment">// 4 + 4 + 2 = 10(不满足4字节对齐)+ 2 = 12</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">st3</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> a; <span class="comment">//4</span></div><div class="line">    short b;<span class="comment">// 2</span></div><div class="line">    <span class="keyword">static</span> <span class="keyword">int</span> c; <span class="comment">//静态不在结构中占空间</span></div><div class="line">&#125;;</div><div class="line"><span class="comment">// 4 + 2 = 6(不满足4字节对齐)+2 = 8</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">st4</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">bool</span> a; <span class="comment">//1 + 3(供struct st1对齐，struct st14字节对齐，成员中最大的自身对齐参数)</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">st1</span></span> s; <span class="comment">// 8</span></div><div class="line">    short b;<span class="comment">//2</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">//4 + 8 + 2 = 14(不满足4字节对齐)+ 2 = 16</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">st5</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">bool</span> a; <span class="comment">//1 + 3(供struct st1对齐，struct st1 4字节对齐，成员中最大的自身对齐参数)</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">st1</span></span> s;<span class="comment">// 8 + 4 (填充供下一个double 8字节对齐)</span></div><div class="line">    double b; <span class="comment">// 8</span></div><div class="line">    <span class="keyword">int</span> c;<span class="comment">//4</span></div><div class="line">&#125;;</div><div class="line"><span class="comment">//4 + 12 + 8 + 4 = 28(不满足8字节对齐) + 4 = 32</span></div></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(2)  </span></div><div class="line"></div><div class="line"><span class="keyword">struct</span> st1</div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> a; <span class="comment">// 4</span></div><div class="line">    <span class="keyword">char</span> b; <span class="comment">//1 + 1(填充供下一个int 2字节对齐)</span></div><div class="line">    <span class="keyword">short</span> c; <span class="comment">// 2</span></div><div class="line">&#125;;</div><div class="line"><span class="comment">// 4 + 1 + 2 = 8 (已经满足1字节对齐)</span></div><div class="line"></div><div class="line"><span class="keyword">struct</span> st2</div><div class="line">&#123;</div><div class="line">    <span class="keyword">char</span> a; <span class="comment">// 1 + 1(填充供下一个int 2字节对齐)</span></div><div class="line">    <span class="keyword">int</span> b; <span class="comment">// 4</span></div><div class="line">    <span class="keyword">short</span> c; <span class="comment">// 2</span></div><div class="line">&#125;;</div><div class="line"><span class="comment">// 2 + 4 + 2 = 8(已经满足2字节对齐)</span></div><div class="line"></div><div class="line"><span class="keyword">struct</span> st3</div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> a; <span class="comment">//4</span></div><div class="line">    <span class="keyword">short</span> b;<span class="comment">// 2</span></div><div class="line">    <span class="keyword">static</span> <span class="keyword">int</span> c; <span class="comment">//静态不在结构中占空间</span></div><div class="line">&#125;;</div><div class="line"><span class="comment">// 4 + 2 = 6(满足2字节对齐)</span></div><div class="line"></div><div class="line"><span class="keyword">struct</span> st4</div><div class="line">&#123;</div><div class="line">    <span class="keyword">bool</span> a; <span class="comment">//1 + 1(供struct st1 2 )</span></div><div class="line">    <span class="keyword">struct</span> st1 s; <span class="comment">// 8</span></div><div class="line">    <span class="keyword">short</span> b;<span class="comment">//2</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">//2 + 8 + 2 = 12(满足2字节对齐)</span></div><div class="line"></div><div class="line"><span class="keyword">struct</span> st5</div><div class="line">&#123;</div><div class="line">    <span class="keyword">bool</span> a; <span class="comment">//1 + 1(供struct st1 2 字节对齐)</span></div><div class="line">    <span class="keyword">struct</span> st1 s;<span class="comment">// 8 </span></div><div class="line">    <span class="keyword">double</span> b; <span class="comment">// 8</span></div><div class="line">    <span class="keyword">int</span> c;<span class="comment">//4</span></div><div class="line">&#125;;</div><div class="line"><span class="comment">//2 + 8 + 8 + 4 = 22(满足2字节对齐)</span></div></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(4)  </span></div><div class="line"></div><div class="line"><span class="keyword">struct</span> st1</div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> a; <span class="comment">// 4</span></div><div class="line">    <span class="keyword">char</span> b; <span class="comment">//1 + 1(填充供下一个int 2字节对齐)</span></div><div class="line">    <span class="keyword">short</span> c; <span class="comment">// 2</span></div><div class="line">&#125;;</div><div class="line"><span class="comment">// 4 + 1 + 2 = 8 (已经满足4字节对齐)</span></div><div class="line"></div><div class="line"><span class="keyword">struct</span> st2</div><div class="line">&#123;</div><div class="line">    <span class="keyword">char</span> a; <span class="comment">// 1 + 3(填充供下一个int 4字节对齐)</span></div><div class="line">    <span class="keyword">int</span> b; <span class="comment">// 4</span></div><div class="line">    <span class="keyword">short</span> c; <span class="comment">// 2</span></div><div class="line">&#125;;</div><div class="line"><span class="comment">// 4 + 4 + 2 = 8(不满足4字节对齐) + 4 = 12</span></div><div class="line"></div><div class="line"><span class="keyword">struct</span> st3</div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> a; <span class="comment">//4</span></div><div class="line">    <span class="keyword">short</span> b;<span class="comment">// 2</span></div><div class="line">    <span class="keyword">static</span> <span class="keyword">int</span> c; <span class="comment">//静态不在结构中占空间</span></div><div class="line">&#125;;</div><div class="line"><span class="comment">// 4 + 2 = 6(不满足4字节对齐) + 2 = 8</span></div><div class="line"></div><div class="line"><span class="keyword">struct</span> st4</div><div class="line">&#123;</div><div class="line">    <span class="keyword">bool</span> a; <span class="comment">//1 + 3(供struct st1对齐，struct st1 4字节对齐，成员中最大的自身对齐参数)</span></div><div class="line">    <span class="keyword">struct</span> st1 s; <span class="comment">// 8</span></div><div class="line">    <span class="keyword">short</span> b;<span class="comment">//2</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">//4 + 8 + 2 = 14(满足4字节对齐) + 2 = 16</span></div><div class="line"></div><div class="line"><span class="keyword">struct</span> st5</div><div class="line">&#123;</div><div class="line">    <span class="keyword">bool</span> a; <span class="comment">//1 + 3(填充,供struct st1对齐，struct st1 4字节对齐，成员中最大的自身对齐参数)</span></div><div class="line">    <span class="keyword">struct</span> st1 s;<span class="comment">// 8 (满足double 4 字节对齐)</span></div><div class="line">    <span class="keyword">double</span> b; <span class="comment">// 8</span></div><div class="line">    <span class="keyword">int</span> c;<span class="comment">//4</span></div><div class="line">&#125;;</div><div class="line"><span class="comment">//4 + 8 + 8 + 4 = 24(满足4字节对齐)</span></div></pre></td></tr></table></figure>
<h1 id="特殊的sizeof"><a href="#特殊的sizeof" class="headerlink" title="特殊的sizeof"></a>特殊的sizeof</h1><ul>
<li>sizeof(void) gcc=1/vc 6.0编译不通过</li>
<li>sizeof(void *) 指针的大小</li>
<li>传字符数组到函数 sizeof,字符数组退化成指针 结果为指针大小</li>
<li>sizeof(空类) = 1</li>
<li>sizeof(类中有虚函数) 加上虚指针</li>
</ul>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="http://www.cnblogs.com/dolphin0520/archive/2011/09/17/2179466.html" target="_blank" rel="external">http://www.cnblogs.com/dolphin0520/archive/2011/09/17/2179466.html</a><br><a href="http://www.ibm.com/developerworks/library/pa-dalign/" target="_blank" rel="external">http://www.ibm.com/developerworks/library/pa-dalign/</a><br>（完）</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;sizeof在计算结构体大小的时候并不是简单的将成员变量相加，计算时还需要考虑内存字节对齐的问题。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>HTTPie</title>
    <link href="https://github.com/Sword2G/sword2g.github.io/2016/06/21/HTTPie/"/>
    <id>https://github.com/Sword2G/sword2g.github.io/2016/06/21/HTTPie/</id>
    <published>2016-06-21T12:57:19.000Z</published>
    <updated>2016-12-27T14:18:27.320Z</updated>
    
    <content type="html"><![CDATA[<p>HTTPie 是一个开源的 HTTP 的命令行客户端。其目标是让 CLI 和 web 服务之间的交互尽可能的人性化。<br><a id="more"></a></p>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p><code>apt-get install httpie</code></p>
<h1 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h1><p>配置文件路径为 ~/.httpie/config.json</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="attr">"__meta__"</span>: &#123;</div><div class="line">        <span class="attr">"about"</span>: <span class="string">"HTTPie configuration file"</span>,</div><div class="line">        <span class="attr">"help"</span>: <span class="string">"https://github.com/jkbr/httpie#config"</span>,</div><div class="line">        <span class="attr">"httpie"</span>: <span class="string">"0.8.0"</span></div><div class="line">    &#125;,</div><div class="line">    <span class="attr">"default_options"</span>: [],</div><div class="line">    <span class="attr">"implicit_content_type"</span>: <span class="string">"json"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><p><strong>meta</strong><br>HTTPie 元数据，一般不要更改</p>
</li>
<li><p>default_options<br>HTTPie 发送数据包时的默认选项<br>如可以设置输出样式”default_options”: [“–style=fruity”, “–body”],设置默认session为default，”–session=default”,可以使用–no-OPTION撤销默认选项，如 –no-style or –no-session</p>
</li>
<li><p>“implicit_content_type”: “json”<br>默认请求的 content_type 类型为 application/json</p>
</li>
</ul>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p><code>http [flags] [METHOD] URL [ITEM [ITEM]]</code></p>
<h3 id="输出选项"><a href="#输出选项" class="headerlink" title="输出选项"></a>输出选项</h3><ul>
<li>–headers, -h 只输出响应headers</li>
<li>–body, -b 只输出响应body</li>
<li>–verbose, -v 输出响应headers和body</li>
<li>–print, -p 可以选择如下输出部分<ul>
<li>H request headers</li>
<li>B request body</li>
<li>h response headers</li>
<li>b response body</li>
</ul>
</li>
</ul>
<h3 id="shorthand"><a href="#shorthand" class="headerlink" title="shorthand"></a>shorthand</h3><p><code>http :80 -pH</code> 将被扩展成 <code>http http://localhost:80 -pH</code></p>
<p>GET /foo HTTP/1.1<br>Host: localhost</p>
<p><code>http :/foo -pH</code> 将被扩展成 <code>http http://localhost/foo -pH</code><br>GET /foo HTTP/1.1<br>Host: localhost:</p>
<p><code>http :80/foo -pH</code> 将被扩展成 <code>http http://localhost:80/foo -pH</code><br>GET /bar HTTP/1.1<br>Host: localhost:80<br><img src="http://7xum8m.com1.z0.glb.clouddn.com/extendHeaders.jpg" alt=""></p>
<p>http :<br>GET /bar HTTP/1.1<br>Host: localhost</p>
<h3 id="Http-Headers"><a href="#Http-Headers" class="headerlink" title="Http Headers"></a>Http Headers</h3><p><code>Name:Value</code><br><code>http http://example.com User-Agent:test_agent -pH</code><br><img src="http://7xum8m.com1.z0.glb.clouddn.com/headers.jpg" alt="Headers"></p>
<p><code>http example.org User-Agent:Bacon/1.0 &#39;Cookie:valued-visitor=yes;foo=bar&#39; X-Foo:Bar Referer:http://httpie.org/ -pH</code><br><img src="http://7xum8m.com1.z0.glb.clouddn.com/headeres2.jpg" alt=""></p>
<h3 id="Querying-String"><a href="#Querying-String" class="headerlink" title="Querying String"></a>Querying String</h3><p><code>name==value</code><br><code>http example.org name==123 age==24 -pH</code><br><img src="http://7xum8m.com1.z0.glb.clouddn.com/QueryingString.jpg" alt=""></p>
<h3 id="Post-Data"><a href="#Post-Data" class="headerlink" title="Post Data"></a>Post Data</h3><h4 id="post"><a href="#post" class="headerlink" title="post"></a>post</h4><p><code>http example.org name=123 age=456 -pH</code><br><img src="http://7xum8m.com1.z0.glb.clouddn.com/postjson.jpg" alt=""></p>
<h2 id="json"><a href="#json" class="headerlink" title="json"></a>json</h2><p><code>http example.org description:=&#39;{&quot;name&quot;:&quot;sword2g&quot;,&quot;age&quot;:24}&#39; -pHB</code><br><img src="http://7xum8m.com1.z0.glb.clouddn.com/JSOn.jpg" alt="json"></p>
<h2 id="data-from-file"><a href="#data-from-file" class="headerlink" title="data from file"></a>data from file</h2><h3 id="text-string-json"><a href="#text-string-json" class="headerlink" title="text string/json"></a>text string/json</h3><p><code>http example.org name==sword2g age=@age.txt</code><br><img src="http://7xum8m.com1.z0.glb.clouddn.com/txt.jpg" alt="txtfile"></p>
<p><code>http example.org description:=@description.json</code><br><img src="http://7xum8m.com1.z0.glb.clouddn.com/json2.jpg" alt="jsonfile"></p>
<h2 id="upload-file"><a href="#upload-file" class="headerlink" title="upload file"></a>upload file</h2><p><code>http -f POST example.com/ name=sword2g cv@~/test.txt</code><br><img src="http://7xum8m.com1.z0.glb.clouddn.com/uploadfile.jpg" alt="uploadfle"></p>
<h2 id="认证"><a href="#认证" class="headerlink" title="认证"></a>认证</h2><p><code>http -a username:password example.org</code></p>
<h2 id="自动重定向"><a href="#自动重定向" class="headerlink" title="自动重定向"></a>自动重定向</h2><p><code>--follow</code><br><code>http httpbin.org/redirect/3</code><br><img src="http://7xum8m.com1.z0.glb.clouddn.com/noredirect.jpg" alt=""></p>
<p><code>http --follow --all --max-redirects=5 httpbin.org/redirect/3</code><br><img src="http://7xum8m.com1.z0.glb.clouddn.com/redirect.jpg" alt=""></p>
<h2 id="下载文件"><a href="#下载文件" class="headerlink" title="下载文件"></a>下载文件</h2><p><code>--download -d</code><br><code>http --download example.com</code><br><img src="http://7xum8m.com1.z0.glb.clouddn.com/download.jpg" alt=""></p>
<h2 id="Sessions"><a href="#Sessions" class="headerlink" title="Sessions"></a>Sessions</h2><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">http</span> <span class="comment">--session=user1 -a user1:password example.org X-Foo:Bar</span></div><div class="line"><span class="keyword">http</span> <span class="comment">--session=user1 example.org</span></div></pre></td></tr></table></figure>
<h1 id="More-details-on-Github"><a href="#More-details-on-Github" class="headerlink" title="More details on Github"></a><a href="https://github.com/jkbrzt/httpie">More details on Github</a></h1><p>（完）</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;HTTPie 是一个开源的 HTTP 的命令行客户端。其目标是让 CLI 和 web 服务之间的交互尽可能的人性化。&lt;br&gt;
    
    </summary>
    
      <category term="WAF" scheme="https://github.com/Sword2G/sword2g.github.io/categories/WAF/"/>
    
    
      <category term="HTTPie" scheme="https://github.com/Sword2G/sword2g.github.io/tags/HTTPie/"/>
    
  </entry>
  
  <entry>
    <title>WAF 之 Modsecurity</title>
    <link href="https://github.com/Sword2G/sword2g.github.io/2016/06/20/WAF-Modsecurity/"/>
    <id>https://github.com/Sword2G/sword2g.github.io/2016/06/20/WAF-Modsecurity/</id>
    <published>2016-06-20T13:42:26.000Z</published>
    <updated>2017-03-25T05:09:26.932Z</updated>
    
    <content type="html"><![CDATA[<p>WAF（Web Application Firewall）,Web 应用防火墙是通过执行一系列针对 HTTP/HTTPS 的安全策略来专门为 Web 应用提供保护的一款产品。<br><a id="more"></a></p>
<h1 id="WAF-与传统防火墙"><a href="#WAF-与传统防火墙" class="headerlink" title="WAF 与传统防火墙"></a>WAF 与传统防火墙</h1><p>传统的防火墙可以根据 IP 地址或服务端口过滤数据包。但是，它对于利用合法IP地址和端口而从事的破坏活动则无能为力。而 WAF 是一种工作在应用层的、通过特定的安全策略来专门为 Web 应用提供安全防护的产品。主要是对 Web 特有入侵方式（如 DDOS 防护、SQL 注入、XML 注入、XSS 等）进行加强防护。</p>
<h1 id="WAF-特点"><a href="#WAF-特点" class="headerlink" title="WAF 特点"></a>WAF 特点</h1><h2 id="异常协议检测"><a href="#异常协议检测" class="headerlink" title="异常协议检测"></a>异常协议检测</h2><p>Web 应用防火墙会对 HTTP 的请求进行异常检测，拒绝不符合 HTTP 标准的请求。并且，它也可以只允许 HTTP 协议的部分选项通过，从而减少攻击的影响范围。甚至，一些 Web 应用防火墙还可以严格限定 HTTP 协议中那些过于松散或未被完全制定的选项。</p>
<h2 id="增强的输入验证"><a href="#增强的输入验证" class="headerlink" title="增强的输入验证"></a>增强的输入验证</h2><p>增强输入验证，可以有效防止网页篡改、信息泄露、木马植入等恶意网络入侵行为。从而减小 Web 服务器被攻击的可能性</p>
<h2 id="及时补丁"><a href="#及时补丁" class="headerlink" title="及时补丁"></a>及时补丁</h2><p>可以针对漏洞及时充当虚拟补丁，及时屏蔽漏洞</p>
<h2 id="基于规则的保护和基于异常的保护"><a href="#基于规则的保护和基于异常的保护" class="headerlink" title="基于规则的保护和基于异常的保护"></a>基于规则的保护和基于异常的保护</h2><p>基于规则的保护可以提供各种Web应用的安全规则，WAF生产商会维护这个规则库，并时时为其更新。用户可以按照这些规则对应用进行全方面检测。还有的产品可以基于合法应用数据建立模型，并以此为依据判断应用数据的异常</p>
<h2 id="状态管理"><a href="#状态管理" class="headerlink" title="状态管理"></a>状态管理</h2><p>WAF 能够判断用户是否是第一次访问并且将请求重定向到默认登录页面并且记录事件。通过检测用户的整个操作行为我们可以更容易识别攻击。状态管理模式还能检测出异常事件（比如登陆失败），并且在达到极限值时进行处理。这对暴力攻击的识别和响应是十分有利的。</p>
<h1 id="WAF-分类"><a href="#WAF-分类" class="headerlink" title="WAF 分类"></a>WAF 分类</h1><h2 id="硬件-WAF"><a href="#硬件-WAF" class="headerlink" title="硬件 WAF"></a>硬件 WAF</h2><p>目前安全市场上，大多数的 WAF 都属于此类。它们以一个独立的硬件设备的形态存在，支持以多种方式（如透明桥接模式、旁路模式、反向代理等）部署到网络中为后端的Web应用提供安全防护。相对于软件产品类的 WAF，这类产品的优点是性能好、功能全面、支持多种模式部署等，但它的价格通常比较贵。国内的绿盟、安恒、启明星辰等厂商生产的WAF 都属于此类。</p>
<h2 id="软件-WAF"><a href="#软件-WAF" class="headerlink" title="软件 WAF"></a>软件 WAF</h2><p>采用纯软件的方式实现,安装在 Web 应用服务器上。这类WAF的代表有ModSecurity、Naxsi、网站安全狗等。</p>
<h2 id="云-WAF"><a href="#云-WAF" class="headerlink" title="云 WAF"></a>云 WAF</h2><p>随着云计算技术的快速发展，使得其于云的WAF实现成为可能。国内创新工场旗下的安全宝、360的网站宝是这类WAF的典型代表。</p>
<h1 id="ModSecurity"><a href="#ModSecurity" class="headerlink" title="ModSecurity"></a>ModSecurity</h1><p><a href="https://github.com/SpiderLabs/ModSecurity">ModSecurity</a> 是一个开源的入侵侦测与防护引擎，它主要是用于 Web 应用程序，属于 WAF，它可以作为 Apache Web 服务器的模块或是单独的应用程序来运作。</p>
<h1 id="ModSecurity-安装"><a href="#ModSecurity-安装" class="headerlink" title="ModSecurity 安装"></a>ModSecurity 安装</h1><h2 id="安装环境"><a href="#安装环境" class="headerlink" title="安装环境"></a>安装环境</h2><pre><code>OS : Ubuntu 14.04.1 LTS
Apache : Apache/2.4.7 (Ubuntu)
</code></pre><h2 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h2><p>1 安装 apache2<br><code>sudo apt-get install apache2</code></p>
<p>2 安装 libapache2-modsecurity 模块及其依赖包<code>sudo apt-get install libxml2 libxml2-dev libxml2-utils libaprutil1 libaprutil1-dev libapache2-modsecurity</code>，安装完成后可查看安装的 ModSecurity 版本 <code>dpkg -s libapache2-modsecurity | grep Version</code>。</p>
<p>3 配置文件，命令<code>sudo cp /etc/modsecurity/modsecurity.conf-recommended /etc/modsecurity/modsecurity.conf</code>,重命名 <code>/etc/modsecurity/modsecurity.conf-recommended</code> 为 <code>/etc/modsecurity/modsecurity.conf</code>。</p>
<p>4 查看日志文件<br>查看 apache2 的日志目录<code>list /var/log/apache2</code>，可以看到目录下有 access.log, error.log, other_vhosts_access.log,执行 <code>sudo service apache2 reload</code> 重启 apache2 后，查看 apache2 日志目录，可以看到新生成的日志文件 modsec_audit.log。</p>
<p>5 添加到激活规则集<br>在 /usr/share/modsecurity-crs/ 下可以看到有如下目录 activated_rules, base_rules, experimental_rules 和 optional_rules,激活的规则集都放在 /usr/share/modsecurity-crs/activated_rules/ 中，只需在该目录下建立待启用的规则集目录的符号链接即可。</p>
<p>如：要激活 base_rules 和 ptional_rules 中的规则集可以执行如下脚本</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">cd</span> /usr/share/modsecurity-crs/base_rules  </div><div class="line"><span class="keyword">for</span> f <span class="keyword">in</span> * ;    </div><div class="line"><span class="keyword">do</span> sudo ln <span class="_">-s</span> /usr/share/modsecurity-crs/base_rules/<span class="variable">$f</span> </div><div class="line">/usr/share/modsecurity-crs/activated_rules/<span class="variable">$f</span>;   </div><div class="line"><span class="keyword">done</span></div><div class="line"></div><div class="line"><span class="built_in">cd</span> /usr/share/modsecurity-crs/optional_rules</div><div class="line"><span class="keyword">for</span> f <span class="keyword">in</span> * ;</div><div class="line"><span class="keyword">do</span> sudo ln <span class="_">-s</span> /usr/share/modsecurity-crs/optional_rules/<span class="variable">$f</span> </div><div class="line">/usr/share/modsecurity-crs/activated_rules/<span class="variable">$f</span>;</div><div class="line"><span class="keyword">done</span></div></pre></td></tr></table></figure>
<p>6 开启拦截<br>更改配置文件 /etc/modsecurity/modsecurity.conf 中 SecRuleEngine DetectionOnly 为 On</p>
<p>7 更改 apache2 配置文件<br>更改文件 /etc/apache2/mods-available/security2.conf，在  前添加如下两行（顺序不能弄错）<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">IncludeOptional <span class="regexp">/usr/</span>share<span class="regexp">/modsecurity-crs/</span>*.conf        </div><div class="line">IncludeOptional <span class="regexp">/usr/</span>share<span class="regexp">/modsecurity-crs/</span>activated_rules<span class="regexp">/*.conf</span></div></pre></td></tr></table></figure></p>
<p>告知 apache2 到哪里去查找激活的规则</p>
<p>8 启用 ModSecurity 模块</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">sudo</span> a2enmod headers</div><div class="line">sudo a2enmod security2</div></pre></td></tr></table></figure>
<p>9 重启 apache2<br><code>sudo service apache2 restart</code></p>
<h3 id="ModSecurity-配置"><a href="#ModSecurity-配置" class="headerlink" title="ModSecurity 配置"></a>ModSecurity 配置</h3><p>ModSecurity 中的重要配置选项</p>
<ul>
<li><p>SecRuleEngine On<br>打开过滤引擎开关。如果是 Off，那么下面这些都不起作用了。</p>
</li>
<li><p>SecRequestBodyAccess On<br>允许过滤引擎检查请求体，如果关闭该选项则 modsecurity 无法看到 post 的任何数据</p>
</li>
<li><p>SecRule REQUEST_HEADERS:Content-Type<br>允许解析 xml 格式的请求</p>
</li>
<li><p>SecRequestBodyLimit 13107200</p>
</li>
<li><p>SecRequestBodyNoFilesLimit 131072<br>ModSecurity允许的最大请求体的缓存区大小 SecRequestBodyLimit 为文件大小，SecRequestBodyNoFilesLimit 没有文件请求提大小</p>
</li>
<li><p>SecRequestBodyInMemoryLimit 131072<br>用来保存请求体的最大内存，超过后会使用硬盘空间</p>
</li>
<li><p>SecResponseBodyAccess On<br>允许对请求体进行检查，从而辨识错误、防止数据泄露（可能会消耗内存并且对响应产生延迟）</p>
</li>
<li><p>SecResponseBodyMimeType text/plain text/html text/xml<br>希望被检查的 MIME 类型</p>
</li>
<li><p>SecResponseBodyLimit 524288<br>ModSecurity 允许的最大响应体的缓存区大小</p>
</li>
<li><p>SecTmpDir /tmp/<br>存储临时文件目录</p>
</li>
<li><p>SecDataDir /tmp/<br>存储临时数据目录</p>
</li>
<li><p>SecUploadDir /opt/modsecurity/var/upload/<br>ModSecurity 用来存放拦截的上传文件</p>
</li>
<li><p>SecUploadKeepFiles RelevantOnly<br>配置是否保存事务处理后的拦截文件</p>
</li>
<li><p>SecUploadFileMode 0600<br>设置拦截的文件的 mode</p>
</li>
</ul>
<h3 id="Modsecurity-处理阶段"><a href="#Modsecurity-处理阶段" class="headerlink" title="Modsecurity 处理阶段"></a>Modsecurity 处理阶段</h3><ul>
<li><p>请求头(REQUEST_HEADERS) 阶段（Phase 1 阶段）<br>这个阶段的 modsecurity 规则会在 apache 完成请求头的读取后立即被执行（post-read-request阶段），这时，还没有读取请求体，意味着不是所有的参数都可用。<br>如果你必须让规则尽早运行，应把规则放在这个阶段（在 apache 使用这个请求做某些事前），在请求体被读取前做些事情，从而决定是否缓存这个请求体，或者决定你将希望这个请求体如何被处理（如是否以 XML 格式解析或不解析）。</p>
</li>
<li><p>请求体(REQUEST_BODY) 阶段（Phase 2 阶段）<br>这是通用输入分析阶段，大部分传统的应用规则不会部署在这个阶段，这个阶段你肯定能收到参数（只有读取过请求体后），在请求体阶段，ModSecurity支持三种编码类型。</p>
<ul>
<li><p>application/x-www-form-urlencoded - used to transfer form data</p>
</li>
<li><p>multipart/form-data - used for file transfers</p>
</li>
<li><p>text/xml - used for passing XML data<br>大部分WEB应用还没有使用其它的编码方法。</p>
</li>
</ul>
</li>
<li><p>响应头(RESPONSE_HEADERS) 阶段（Phase 3 阶段）<br>发生在响应头被发送到客户端之前。如果你想观察响应发生前就在这儿运行，如果你想使用响应头来决定你是否想缓存响应体也行。注意一些响应状态码（如 404）在请求环的早期就被 apache 管理着，我也无法触发预期。加上apache在后面的勾子上双增加了一些响应头（如日期、服务器和连接信息等），这些我们无法触发和审查。在代理配置模式下或使用phase:5(logging)工作的较好。</p>
</li>
<li><p>响应体(RESPONSE_BODY) 阶段（Phase 4 阶段）<br>这是通用输出分析阶段，这里你能运行规则截断响应体（当然提供缓存）。这个阶段你想检查输出的HTML信息公布、错误消息和失败的验证文字。</p>
</li>
<li><p>记录(LOGGING) 阶段（Phase 5 阶段）<br>在日志发生前运行的一个阶段，放在这个阶段的规则只能影响日志记录器如何执行，这个阶段可以检测 apache 记录的错误消息，在这个阶段你不能拒绝或阻断连接，因为太迟了。</p>
</li>
</ul>
<h3 id="ModSecurity-测试"><a href="#ModSecurity-测试" class="headerlink" title="ModSecurity 测试"></a>ModSecurity 测试</h3><p>使用 HTTPie 发包工具测试</p>
<p>1 <code>http http://localhost/ a==&#39;select 0x123 from user&#39;</code><br>打开 ModSecurity 日志文件/var/log/apache2/modsec_audit.log查看具体拦截情况。<br><img src="http://7xum8m.com1.z0.glb.clouddn.com/ModSecuritysql.jpg" alt=""></p>
<p>2 测试自定义规则<br><code>sudo vim /usr/share/modsecurity-crs/activated_rules/TestRules.conf</code><br>添加如下规则,值允许上传图片</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">SecRule FILES <span class="string">"!\\.(?i:jpe?g|gif|png|bmp)$"</span> <span class="comment">"deny,tag:'WEB_ATTACK/    </span></div><div class="line">FILEUPLOAD<span class="string">',msg:'</span>upload <span class="keyword">no</span>-picture <span class="keyword">file</span><span class="string">',id:0000001,phase:2"</span></div></pre></td></tr></table></figure>
<p>上传文件名中不允许含有0</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">SecRule</span> FILES <span class="string">"<span class="variable">@contains</span> 0"</span> <span class="string">"deny,tag:'WEB_ATTACK/      </span></div><div class="line">FILEUPLOAD',msg:'filename has null character',id:0000002,phase:2"</div></pre></td></tr></table></figure>
<p>在 /var/www/html 下新建 upload.html</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;<span class="keyword">form</span> enctype=<span class="string">"multipart/form-data"</span> method=<span class="string">"post"</span> action=<span class="string">"http://example.com/jobs"</span>&gt;</div><div class="line">    &lt;<span class="keyword">input</span> <span class="keyword">type</span>=<span class="string">"text"</span> name=<span class="string">"name"</span> /&gt;</div><div class="line">    &lt;<span class="keyword">input</span> <span class="keyword">type</span>=<span class="string">"file"</span> name=<span class="string">"cv"</span> /&gt;</div><div class="line">    &lt;<span class="keyword">input</span> <span class="keyword">type</span>=<span class="string">"submit"</span>/&gt;</div><div class="line">&lt;/<span class="keyword">form</span>&gt;</div></pre></td></tr></table></figure>
<p><code>http -f POST http://localhost/upload.html name=&#39;testfile&#39; cv@~/testMod/a.php</code><br>上传php文件，相关拦截日志如下<br><img src="http://7xum8m.com1.z0.glb.clouddn.com/ModSecurityphp.jpg" alt=""></p>
<p><code>http -f POST http://localhost/upload.html name=&#39;testfile&#39; cv@~/testModSeciurity/0.png</code><br>上传0.png，相关拦截日志如下<br><img src="http://7xum8m.com1.z0.glb.clouddn.com/ModSecuritynull.jpg" alt=""></p>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="http://netsecurity.51cto.com/art/201004/195250_all.htm" target="_blank" rel="external">http://netsecurity.51cto.com/art/201004/195250_all.htm</a><br><a href="http://ubuntuforums.org/showthread.php?t=2219109" target="_blank" rel="external">http://ubuntuforums.org/showthread.php?t=2219109</a><br><a href="http://www.freebuf.com/articles/web/43559.html" target="_blank" rel="external">http://www.freebuf.com/articles/web/43559.html</a><br>（完）</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;WAF（Web Application Firewall）,Web 应用防火墙是通过执行一系列针对 HTTP/HTTPS 的安全策略来专门为 Web 应用提供保护的一款产品。&lt;br&gt;
    
    </summary>
    
      <category term="WAF" scheme="https://github.com/Sword2G/sword2g.github.io/categories/WAF/"/>
    
    
      <category term="Modsecurity" scheme="https://github.com/Sword2G/sword2g.github.io/tags/Modsecurity/"/>
    
  </entry>
  
  <entry>
    <title>C Standard I/O</title>
    <link href="https://github.com/Sword2G/sword2g.github.io/2016/06/01/C-standard-io/"/>
    <id>https://github.com/Sword2G/sword2g.github.io/2016/06/01/C-standard-io/</id>
    <published>2016-06-01T13:23:45.000Z</published>
    <updated>2016-12-26T13:41:49.545Z</updated>
    
    <content type="html"><![CDATA[<p>C/C++ 的输入输出并不是以其语言本身为基础实现的，换句话说，C 和 C++ 本身都没有为输入和输出提供专门的语句结构。输入输出留给了编译器来实现。C 语言的输入输出是由标准 I/O 函数库（stdio.h）来实现的，C++ 是由标准类库（iostream 和 fstream）来实现的。<br><a id="more"></a></p>
<h1 id="流"><a href="#流" class="headerlink" title="流"></a>流</h1><p>C 程序把输入输出看做流，所有的 I/O 操作可以看作是简单的把字节移入或者移出程序。输入流中的字节可能来自键盘、其他存储设备或其他程序，输出流可以流向屏幕、 打印机、存储设备或其他程序。流充当了程序和流源或流目标之间的桥梁，因此，特定I/O设备的细节对程序来说是透明的。</p>
<h1 id="缓冲"><a href="#缓冲" class="headerlink" title="缓冲"></a>缓冲</h1><p>使用缓冲的目的是为了提高输入输出的效率，减少read、write调用的次数。缓冲区其实就是一块作为中介的内存块，而“读取” 就是从缓冲区复制数据到程序，“写入”就是将数据从程序复制到缓冲区。通常像磁盘驱动器这样的设备以 512 字节的块为单位来传输信息，而程序通常每次只能处理一个字节信息。逐个字节读取然后处理是十分低效的，因为从磁盘读取一个字节需要大量的硬件活动。缓冲区的目的就是为了帮助匹配这两种不同信息传输效率。有了缓冲区就可以先从磁盘读取大块数据，然后再逐字节传送给程序处理。</p>
<h2 id="键盘缓冲"><a href="#键盘缓冲" class="headerlink" title="键盘缓冲"></a>键盘缓冲</h2><p>键盘每次提供一个字符，事实上无需缓冲，然而对键盘的缓冲可以允许用户在将键入的数据传送给程序之前做更改。这就是为什么很多程序在键入回车以后（刷新输入缓冲区），程序才开始处理输入的数据。</p>
<h2 id="缓冲类型"><a href="#缓冲类型" class="headerlink" title="缓冲类型"></a>缓冲类型</h2><h3 id="全缓冲"><a href="#全缓冲" class="headerlink" title="全缓冲"></a>全缓冲</h3><p>在填满 I/O 缓冲区之后才进行实际的 I/O 操作。对于驻留在磁盘上的文件，通常是由标准 I/O 库实施全缓冲，在一个流上第一次执行 I/O 操作的时候，相关标准 I/O 将调用 malloc 获得所需的缓冲区。缓冲区在填满的时候自动刷新，或者调用 fflush 进行刷新，fflush 迫使缓冲区数据立即写入而不管缓冲区是否已满。</p>
<h3 id="行缓冲"><a href="#行缓冲" class="headerlink" title="行缓冲"></a>行缓冲</h3><p>当输入输出中遇到换行符的时候执行 I/O 操作。当流涉及到终端设备时使用行缓冲。</p>
<h3 id="不缓冲"><a href="#不缓冲" class="headerlink" title="不缓冲"></a>不缓冲</h3><p>不使用缓冲区，直接执行 I/O 操作。标准错误流一般使用不带缓冲的，从而使错误信息尽快的输出。</p>
<h2 id="ISO-C-缓冲特性"><a href="#ISO-C-缓冲特性" class="headerlink" title="ISO C 缓冲特性"></a>ISO C 缓冲特性</h2><ul>
<li><p>标准输入和标准输出不指向交互式设备时，他们才是全缓冲。（通常标注输入设备是键盘，标准输出设备是终端或屏幕，可以通过重定向来改变输入输出指向的设备）</p>
</li>
<li><p>标准错误绝对不是全缓冲</p>
</li>
<li><p>指向终端设备的流是行缓冲，否则是全缓冲</p>
</li>
</ul>
<h2 id="相关函数"><a href="#相关函数" class="headerlink" title="相关函数"></a>相关函数</h2><p><code>void setbuf(FILE *stream, char *buf);</code></p>
<p>setbuf 函数具有打开和关闭缓冲机制。为了带缓冲进行 I/O，参数 buf 必须指向一个长度为 BUFSIZ (定义在 stdio.h 头文件中)的缓冲区。通常在此之后该流就是全缓冲的，但是如果该流与一个终端设备相关，那么某些系统也可以将其设置为行缓冲。为了关闭缓冲，可以将 buf 参数设置为 NULL。</p>
<p><code>int setvbuf(FILE *stream, char *buf, int mode, size_t size);</code></p>
<ul>
<li><p>mode ：期望缓冲区的类型：</p>
<ul>
<li>_IOFBF(满缓冲）：当缓冲区为空时，从流读入数据。或者当缓冲区满时，向流写入数 据。</li>
<li>_IOLBF(行缓冲）：每次从流中读入一行数据或向流中写入一行数据。<br><em>_IONBF(无缓冲）：直接从流中读入数据或直接向流中写入数据，而没有缓冲区。
</em>size ：缓冲区内字节的数量</li>
</ul>
</li>
</ul>
<p>一般而言，应该由系统选择缓冲区的长度并自动分配缓冲区，在关闭流时，标准 I/O 库自动释放缓冲区。</p>
<h1 id="输入输出相关函数"><a href="#输入输出相关函数" class="headerlink" title="输入输出相关函数"></a>输入输出相关函数</h1><h2 id="打开流"><a href="#打开流" class="headerlink" title="打开流"></a>打开流</h2><p><code>FILE * fopen(const char * restrict path, const char * restrict mode);</code><br>打开一个特定的文件，并把一个流和这个文件相关联</p>
<p><strong>Note ：以读写方式（mode+）打开一个流的时候具有以下限制：</strong></p>
<ul>
<li>输出之后跟输入必须调用 flush 、fseek、fsetpos、rewind</li>
<li>输入之后跟输出必须调用 fseek、fsetpos、rewind<br><code>FILE freopen(const char restrict filename, const char restrict mode, FILE * restrict stream);</code><br>打开或重新打开一个特定的流（如stdin、stdout、stderr）。函数首先试图关闭这个流，然后用指定的文件和模式重新打开这个流，失败返回NULL，打开成功返回它的第三个参数值。</li>
</ul>
<h2 id="关闭流"><a href="#关闭流" class="headerlink" title="关闭流"></a>关闭流</h2><p>int fclose( FILE *fp );</p>
<p>关闭一个打开的流，成功返回 0 ,失败返回 EOF(-1)。<br>在文件被关闭之前，刷新输出缓冲区中的数据，丢弃输入缓冲区中的数据。如果标准 I/O 库已经为该流自动分配了一个缓冲区，则释放该缓冲区。</p>
<h2 id="读写流"><a href="#读写流" class="headerlink" title="读写流"></a>读写流</h2><h3 id="非格式化IO"><a href="#非格式化IO" class="headerlink" title="非格式化IO"></a>非格式化IO</h3><h4 id="字符IO"><a href="#字符IO" class="headerlink" title="字符IO"></a>字符IO</h4><h5 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">getc</span><span class="params">(FILE *fp)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">fgetc</span><span class="params">(FILE *fp)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">getchar</span><span class="params">(<span class="keyword">void</span>)</span></span>;</div></pre></td></tr></table></figure>
<p>前两个函数区别在于 getc 可以被实现为宏，fgetc 不可以。因此 getc 调用要快一些。getchar() 等价于 getc(stdin)</p>
<p><strong>Note ：返回值的类型为 int 这样就可以返回所有字符的值加上一个出错或者到达文件尾的指示值EOF 区分 error/eof，也就是说不能将这三个函数的返回值存储在 char 类型的变量中，因为这些函数的返回值以后还要跟 EOF 作比较。</strong></p>
<h5 id="区分-error-eof"><a href="#区分-error-eof" class="headerlink" title="区分 error/eof"></a>区分 error/eof</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">ferror</span><span class="params">(FILE *fp)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">feof</span><span class="params">(FILE *fp)</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">fclearerr</span><span class="params">(FILE *fp)</span></span>;</div></pre></td></tr></table></figure>
<p>fclearerr 函数清除出错标志和文件尾标志。</p>
<h5 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">putc</span><span class="params">(<span class="keyword">int</span> c, FILE *fp)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">fputc</span><span class="params">(<span class="keyword">int</span> c, FILE *fp)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">putchar</span><span class="params">(<span class="keyword">int</span> c)</span></span>;</div></pre></td></tr></table></figure>
<p>和输入类似，putc 可以被实现为宏，fputc 不可以。putchar(c) 等价于 putc(c,stdout)</p>
<h5 id="撤销字符"><a href="#撤销字符" class="headerlink" title="撤销字符"></a>撤销字符</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">ungetc</span><span class="params">(<span class="keyword">int</span> c, FILE *fp)</span></span>;</div></pre></td></tr></table></figure>
<p>将之前读出的字符压送回流中（并没有写到底层文件或者设备中，只是将它写回到流缓冲区中），以后可以重新读取。</p>
<h4 id="行-I-O"><a href="#行-I-O" class="headerlink" title="行 I/O"></a>行 I/O</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">char</span> *<span class="title">fgets</span><span class="params">(<span class="keyword">char</span> *<span class="keyword">restrict</span> buf, <span class="keyword">int</span> n, FILE *fp)</span></span>;</div><div class="line"><span class="function"><span class="keyword">char</span> *<span class="title">gets</span><span class="params">(<span class="keyword">char</span> *buf)</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">fputs</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> buf, FILE *fp)</span></span></div><div class="line"><span class="keyword">int</span> <span class="title">puts</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *buf)</span></div></pre></td></tr></table></figure>
<p><strong>Note ：gtes 在读取一行的时候并不存储换行符，puts在输出的时候会在输出后在添加一个换行符，fgets、fputs 与其不同,推荐使用 fgets、fputs，因为 gets 不安全，可能造成缓冲区溢出。</strong></p>
<h4 id="二进制-I-O"><a href="#二进制-I-O" class="headerlink" title="二进制 I/O"></a>二进制 I/O</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">size_t</span> fread(<span class="keyword">void</span> *buffer, <span class="keyword">size_t</span> size, <span class="keyword">size_t</span> count, FILE *fp);</div><div class="line"><span class="keyword">size_t</span> fwrite(<span class="keyword">void</span> *buffer, <span class="keyword">size_t</span> size , <span class="keyword">size_t</span> count, FILE *fp);</div></pre></td></tr></table></figure>
<p>从（向）fp中读或者写 count 个每个大小为 size 的对象<br>对于读，如果返回值小于 count 则需要使用 feof 或 ferror 判断是哪种情况<br>对于写，如果返回值小于 count 则出错</p>
<h3 id="格式化IO"><a href="#格式化IO" class="headerlink" title="格式化IO"></a>格式化IO</h3><h4 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">scanf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> format, ...)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">fscanf</span><span class="params">(FILE *fp, <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> format, ...)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">sscanf</span><span class="params">(<span class="keyword">char</span> *<span class="keyword">restrict</span> buf, <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> format, ...)</span></span>;</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">printf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> format, ...)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">fprintf</span><span class="params">(FILE *fp, <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> format, ...)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">sprintf</span><span class="params">(<span class="keyword">char</span> *<span class="keyword">restrict</span> buf, <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> format, ...)</span></span>;</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdarg.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">vprintf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> format, va_list arg)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">vfprintf</span><span class="params">(FILE *fp,<span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> format, va_list arg)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">vsprintf</span><span class="params">(<span class="keyword">char</span> *<span class="keyword">restrict</span> buf, <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> format, va_list arg)</span></span>;</div></pre></td></tr></table></figure>
<h4 id="定位流"><a href="#定位流" class="headerlink" title="定位流"></a>定位流</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">long</span> <span class="title">ftell</span><span class="params">(FILE *fp)</span></span>;</div><div class="line"><span class="function"><span class="keyword">long</span> <span class="title">fseek</span><span class="params">(FILE *fp, <span class="keyword">long</span> offset, <span class="keyword">int</span> whence)</span></span>;</div></pre></td></tr></table></figure>
<ul>
<li><p>对于二进制文件 以字节为度量单位<br>fseek 的 whence 字段可以为</p>
<ul>
<li>SEEK_SET 文件起始位置</li>
<li>SEEK_CUR 文件当前位置</li>
<li>SEEK_END 文件结束位置</li>
</ul>
</li>
<li><p>对于文本文件 可能不以字节为单位<br>whence 的值只能为SEEK_SET，而且 offset 的值只能为</p>
<ul>
<li>0 后退到文件的起始位置</li>
<li>对该文件的ftell返回的值</li>
</ul>
</li>
</ul>
<p><code>void rewind(FILE *fp);</code><br>将一个流设置到文件的起始位置。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">getpos</span><span class="params">(FILE *<span class="keyword">restrict</span> fp, <span class="keyword">fpos_t</span> *<span class="keyword">restrict</span> pos)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">setpos</span><span class="params">(FILE *<span class="keyword">restrict</span> fp, <span class="keyword">const</span> <span class="keyword">fpos_t</span> *pos)</span></span>;</div></pre></td></tr></table></figure>
<p>将当前位置指示器的值存入由pos指向的对象中，在以后的fsetpos调用时，可以使用此值将流重新定位至该位置。</p>
<h1 id="参考书籍"><a href="#参考书籍" class="headerlink" title="参考书籍"></a>参考书籍</h1><p><a href="https://book.douban.com/subject/25900403/" target="_blank" rel="external">UNIX环境高级编程（第3版）</a><br><a href="https://book.douban.com/subject/3012360/" target="_blank" rel="external">C和指针</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;C/C++ 的输入输出并不是以其语言本身为基础实现的，换句话说，C 和 C++ 本身都没有为输入和输出提供专门的语句结构。输入输出留给了编译器来实现。C 语言的输入输出是由标准 I/O 函数库（stdio.h）来实现的，C++ 是由标准类库（iostream 和 fstream）来实现的。&lt;br&gt;
    
    </summary>
    
      <category term="C/C++" scheme="https://github.com/Sword2G/sword2g.github.io/categories/C-C/"/>
    
    
      <category term="standard I/O" scheme="https://github.com/Sword2G/sword2g.github.io/tags/standard-I-O/"/>
    
  </entry>
  
  <entry>
    <title>Syslog</title>
    <link href="https://github.com/Sword2G/sword2g.github.io/2016/05/26/syslog/"/>
    <id>https://github.com/Sword2G/sword2g.github.io/2016/05/26/syslog/</id>
    <published>2016-05-26T13:00:55.000Z</published>
    <updated>2016-12-28T14:59:10.565Z</updated>
    
    <content type="html"><![CDATA[<p>在类 Unix 操作系统上，syslog 广泛应用于系统日志。该机制负责发送、记录系统内核、守护进程及应用程序所产生的信息，它由 syslogd 守护进程、syslog 调用和配置文件 /etc/syslog.conf 三部分组成。<br><a id="more"></a></p>
<h1 id="syslogd-守护进程"><a href="#syslogd-守护进程" class="headerlink" title="syslogd 守护进程"></a>syslogd 守护进程</h1><p>syslog协议分为客户端和服务器端，客户端是产生日志消息的一方，而服务器端负责接收客户端发送来的日志消息，并做出保存到特定的日志文件中或者其他方式的处理。<br>在Unix中，常见的 syslog 服务器端程序是 syslogd 守护程序。</p>
<h2 id="syslogd-启动方式"><a href="#syslogd-启动方式" class="headerlink" title="syslogd 启动方式"></a>syslogd 启动方式</h2><p>Unix 系统中的 syslogd 守护进程通常由某个系统初始化脚本启动，在工作期间一直运行。</p>
<h2 id="syslogd-启动步骤"><a href="#syslogd-启动步骤" class="headerlink" title="syslogd 启动步骤"></a>syslogd 启动步骤</h2><p>1 读取配置文件。默认的配置文件为 /etc/syslog.conf，该配置文件指定了本守护进程可能收取的各种日志消息应该如何处理（如添加到一个文件、输出到控制台、写到指定用户的登录窗口，转发到另一个主机的 syslogd 进程）。<br>2 创建一个 Unix 域套接字，给他捆绑路径名 /dev/log<br>3 创建一个 UDP 套接字，给他捆绑端口 514<br>4 打开路径名 /dev/klog，记录来自内核的日志消息</p>
<h1 id="syslog-接口调用"><a href="#syslog-接口调用" class="headerlink" title="syslog 接口调用"></a>syslog 接口调用</h1><h2 id="函数原型"><a href="#函数原型" class="headerlink" title="函数原型"></a>函数原型</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;syslog.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;syslog.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">openlog</span> <span class="params">(<span class="keyword">char</span>*ident, <span class="keyword">int</span> option, <span class="keyword">int</span> facility)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">syslog</span><span class="params">(<span class="keyword">int</span> priority, <span class="keyword">char</span>* format, ……)</span></span></div><div class="line"><span class="keyword">void</span> <span class="title">closelog</span><span class="params">(<span class="keyword">void</span>)</span>;</div></pre></td></tr></table></figure>
<h2 id="openlog"><a href="#openlog" class="headerlink" title="openlog"></a>openlog</h2><p>openlog 是可选择的。如果不调用 openlog ，则在第一次调用 syslog 的时候自动调用 openlog</p>
<h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p>ident 参数是一个由 syslog 冠于每个日志消息之前的字符串，一般是程序名称；<br>options 参数由LOG_CONS、LOG_NDELAY、LOG_PERROR、LOG_PID中的一个或者多个标志位逻辑或构成；</p>
<pre><code>LOG_CONS 若无法发送到 syslogd 守护进程则登记到控制台
LOG_NDELAY openlog 被调用时，通常不立即打开 UNIX 域套接字，直到 syslog 函数调用时才打开，该参数指定立即打开
LOG_PERROR 既发送到 syslogd，又登记到标准错误输出
LOG_PID 每条消息都登记进程pid
</code></pre><p>facility 为没有指定设施的后续 syslog() 调用指定一个默认值。</p>
<h2 id="syslog"><a href="#syslog" class="headerlink" title="syslog"></a>syslog</h2><p>syslog 产生一个日志消息，priority 参数是 facility（标识消息发送进程） 和 level（标识消息级别）的组合。<br><strong>P.S.默认的 level 是 LOG_NOTICE，默认的 facility 是 LOG_USER<br>syslog 中的 format 类似于 printf，增设了 %m ，它被替换成当前 errno 对应的出错消息</strong><br><img src="http://7xum8m.com1.z0.glb.clouddn.com/hexo_syslog_syslog_level.jpg" alt="facility"><br><img src="http://7xum8m.com1.z0.glb.clouddn.com/hexo_syslog_syslog_level.jpg" alt="level"></p>
<h2 id="closelog"><a href="#closelog" class="headerlink" title="closelog"></a>closelog</h2><p>应用进程不再需要发送日志消息是关闭</p>
<h1 id="配置文件-etc-syslog-conf"><a href="#配置文件-etc-syslog-conf" class="headerlink" title="配置文件 /etc/syslog.conf"></a>配置文件 /etc/syslog.conf</h1><p>对每类消息提供一个选择域和一个动作域，选择域指明消息的类型和优先级（syslogd 将记录一个拥有相同或更高优先级的消息），动作域指明syslogd 接收到一个与选择标准相匹配的消息时所执行的动作，这些域由 tab 隔开。<br>syslog.conf 行的基本语法是：消息类型.优先级 动作域</p>
<h2 id="消息类型"><a href="#消息类型" class="headerlink" title="消息类型"></a>消息类型</h2><p><img src="http://7xum8m.com1.z0.glb.clouddn.com/hexo_syslog_log_type.jpg" alt="log_type"></p>
<h2 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h2><p><img src="http://7xum8m.com1.z0.glb.clouddn.com/hexo_syslog_log_priority.jpg" alt="log_priority"></p>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><pre><code>kern.* /dev/console
local17.debug /var/log/cisco.log
所有的内核消息登记到控制台，来自 local17 的所有 debug 消息添加到 /var/log/cisco.log
</code></pre><h1 id="syslog-应用场景"><a href="#syslog-应用场景" class="headerlink" title="syslog 应用场景"></a>syslog 应用场景</h1><p>网络管理工具<br>安全管理系统<br>日志审计系统<br>可以让任何事件都以网络行为日志的方式登记到一台或多台服务器上，以备后台数据库用off-line(离线) 方式分析远端设备事件，追踪掌握与设备和网络有关的状况并作响应<br>大多数守护进程的日志信息都使用 syslog 设施</p>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="http://blog.chinaunix.net/uid-25120309-id-3359929.html" target="_blank" rel="external">http://blog.chinaunix.net/uid-25120309-id-3359929.html</a><br><a href="http://blog.csdn.net/tonyxf121/article/details/7934824" target="_blank" rel="external">http://blog.csdn.net/tonyxf121/article/details/7934824</a><br>（完）</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在类 Unix 操作系统上，syslog 广泛应用于系统日志。该机制负责发送、记录系统内核、守护进程及应用程序所产生的信息，它由 syslogd 守护进程、syslog 调用和配置文件 /etc/syslog.conf 三部分组成。&lt;br&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://github.com/Sword2G/sword2g.github.io/categories/Linux/"/>
    
    
      <category term="Syslog 协议" scheme="https://github.com/Sword2G/sword2g.github.io/tags/Syslog-%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>套接字选项</title>
    <link href="https://github.com/Sword2G/sword2g.github.io/2016/05/17/socket-options/"/>
    <id>https://github.com/Sword2G/sword2g.github.io/2016/05/17/socket-options/</id>
    <published>2016-05-17T02:30:49.000Z</published>
    <updated>2017-03-03T12:32:54.510Z</updated>
    
    <content type="html"><![CDATA[<p>通过套接字选项可以获得、设置套接字的行为属性。<br><a id="more"></a></p>
<h1 id="getsockopt-和-setsockopt-函数"><a href="#getsockopt-和-setsockopt-函数" class="headerlink" title="getsockopt 和 setsockopt 函数"></a>getsockopt 和 setsockopt 函数</h1><h2 id="函数原型"><a href="#函数原型" class="headerlink" title="函数原型"></a>函数原型</h2><p>int getsockopt(int sockfd, int level,<br>int optname, void <em>optval, socklen_t </em>optlen);</p>
<p>int setsockopt(int sockfd, int level,<br>int optname, const void <em>optval, socklen_t </em>optlen);</p>
<h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><blockquote>
<p>sockfd： 已打开的套接字描述符<br>level：  指定系统中解释选项的代码。（通用套接字代码，特定于协议的代码）<br>optname：套接字选项名称<br>optval： 指向某个变量的指针，setsockopt从<em>optval（值参数）中取得选项待设置的新值，getsockopt把已获得的选项的当前值存入</em>optval（值-结果参数）中。<br>optlen： 选项类型的长度</p>
</blockquote>
<h1 id="套接字选项"><a href="#套接字选项" class="headerlink" title="套接字选项"></a>套接字选项</h1><p>套接字选项粗分为两大类：</p>
<ul>
<li>启用和禁止某个特性的二元选项</li>
<li>取得并返回我们可以设置或检查的特定值选项</li>
</ul>
<h2 id="常见的套接字选项"><a href="#常见的套接字选项" class="headerlink" title="常见的套接字选项"></a>常见的套接字选项</h2><p><img src="http://7xum8m.com1.z0.glb.clouddn.com/socket_optssockets_options.jpg" alt="套接字选项"></p>
<h2 id="SOL-SOCKET（通用套接字选项）"><a href="#SOL-SOCKET（通用套接字选项）" class="headerlink" title="SOL_SOCKET（通用套接字选项）"></a>SOL_SOCKET（通用套接字选项）</h2><h3 id="SO-BROADCAST"><a href="#SO-BROADCAST" class="headerlink" title="SO_BROADCAST"></a>SO_BROADCAST</h3><p>开启或禁止进程发送广播消息的能力，默认情况下，本选项关闭。只有数据报套接字（SOCK_DGRAM）支持广播，并且还必须在支持广播消息的网络上（以太网、令牌环网），不可能在p2p网络上广播，也不可能在基于链连接的网络上广播。</p>
<h3 id="SO-DEBUG"><a href="#SO-DEBUG" class="headerlink" title="SO_DEBUG"></a>SO_DEBUG</h3><p>开启或禁止套接字调试功能，仅支持TCP协议。该选项打开时，内核跟踪此套接字上发送和接收的数据，并将调试信息保存到一个环形缓冲区中。可使用trpt程序进行检查。</p>
<h3 id="SO-ERROR"><a href="#SO-ERROR" class="headerlink" title="SO_ERROR"></a>SO_ERROR</h3><p>通过该套接字获得套接字错误。<br>当套接字发生错误时，源自 Berkeley 的内核将内核中该套接字的 so_error 变量设置为标准的 Unix_Exxx 的值。<br>内核以两种方式通知用户进程：</p>
<ul>
<li>使用 select，进程阻塞在 select，函数返回 -1,。无论是检查可读还是可写条件，select 均会返回并设置其中一个或两个条件</li>
<li>使用信号驱动 I/O，给进程或进程组发送一个 SIGIO 信号</li>
</ul>
<h3 id="SO-DONTROUTE"><a href="#SO-DONTROUTE" class="headerlink" title="SO_DONTROUTE"></a>SO_DONTROUTE</h3><p>规定底层的分组将绕过底层协议的正常路由机制。。分组将按照发送数据的目的地址和子网掩码选择一个合适的网络接口进行发送。</p>
<h3 id="SO-KEEPALIVE"><a href="#SO-KEEPALIVE" class="headerlink" title="SO_KEEPALIVE"></a>SO_KEEPALIVE</h3><p>如果在 2 小时内该套接字的任一方向没有数据交换，TCP就发送探测报文。<br>对端可能有一下三种情况发生：</p>
<ul>
<li>对端以期望的ACK响应</li>
<li>对端以RST响应</li>
<li>对端没有响应 ==&gt; 两两相隔 75s 另外发送 8 个探测报文</li>
</ul>
<h3 id="SO-LINGER"><a href="#SO-LINGER" class="headerlink" title="SO_LINGER"></a>SO_LINGER</h3><p>指定close函数对面向连接的协议如何操作。</p>
<h4 id="linger数据结构"><a href="#linger数据结构" class="headerlink" title="linger数据结构"></a>linger数据结构</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">struct</span> linger&#123;</div><div class="line">	<span class="keyword">int</span> l_onoff;</div><div class="line">	<span class="keyword">int</span> l_linger;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>l_onoff 为 0，套接字该选项关闭，默认情况。close函数立即返回，如果套接字发送缓冲区中还有数据，系统试着把数据发送给对端。存在无法确认是否发送成功的问题。</li>
<li>l_onoff 非 0 且 l_linger 为 0 。丢弃发送缓冲区中的数据，并发送 RST 给对端。 </li>
<li>l_onoff 非 0 且 l_linger 非 0 。内核将拖延一段时间，如果发送缓冲区中仍然残留数据，进程投入睡眠（ close 阻塞），直到数据发送完成<strong>并且被对方确认</strong>或者超时。如果在数据发送完并确认之前超时，close 返回 EWOULDBLOCK ，close成功仅仅代表先前发送的数据已经被对端TCP确认，但是依然存在无法确认应用程序是否成功读取数据的问题。需要使用应用级的 ACK。</li>
</ul>
<h3 id="SO-RCVBUF-和-SO-SNDBUF"><a href="#SO-RCVBUF-和-SO-SNDBUF" class="headerlink" title="SO_RCVBUF 和 SO_SNDBUF"></a>SO_RCVBUF 和 SO_SNDBUF</h3><p>设置套接字接收发送缓冲区大小（在内核中）。</p>
<ul>
<li>UDP 发送缓冲区中的数据，发送后就可以丢弃，接收缓冲区中的数据需要等待应用程序读取，UDP 没有流量控制，如果发送的数据量大于缓冲区大小，则丢弃数据。</li>
<li>TCP 有流量控制，接收缓冲区大小就是滑动窗口大小。接受缓冲区不可能溢出，因为不允许对端发送超过本端所通告窗口的大小，对于对端无视通知大小发送的数据，直接丢弃。</li>
</ul>
<p>该选项，客户端在 connect 之前设置，服务器端在 listen 之前给监听套接字设置。</p>
<h3 id="SO-RCVLOWAT-和-SO-SNDLOWAT"><a href="#SO-RCVLOWAT-和-SO-SNDLOWAT" class="headerlink" title="SO_RCVLOWAT 和 SO_SNDLOWAT"></a>SO_RCVLOWAT 和 SO_SNDLOWAT</h3><p>设置每个套接字的接收低水位线和发送低水位线。它们由 select 函数使用</p>
<h3 id="SO-REUSEADDR"><a href="#SO-REUSEADDR" class="headerlink" title="SO_REUSEADDR"></a>SO_REUSEADDR</h3><p>允许重复使用本地地址和端口。</p>
<h2 id="IPPROTO-IP（IPv4套接字选项）"><a href="#IPPROTO-IP（IPv4套接字选项）" class="headerlink" title="IPPROTO_IP（IPv4套接字选项）"></a>IPPROTO_IP（IPv4套接字选项）</h2><h3 id="IP-HDRINCL"><a href="#IP-HDRINCL" class="headerlink" title="IP_HDRINCL"></a>IP_HDRINCL</h3><p>一般情况下，Linux内黑会自动计算和填充IP头部数据。如果套接字是一个原始套接字，则IP头部需要用户手动填充。通常在用户自定义数据包格式的时候使用。注意，一旦该选项生效，用户发送的IP数据包将不在进行分片。因此用户的数据包不能太大，否则网卡不能发送。</p>
<h2 id="IPPROTO-TCP（TCP套接字选项）"><a href="#IPPROTO-TCP（TCP套接字选项）" class="headerlink" title="IPPROTO_TCP（TCP套接字选项）"></a>IPPROTO_TCP（TCP套接字选项）</h2><h3 id="TCP-MAXSEG"><a href="#TCP-MAXSEG" class="headerlink" title="TCP_MAXSEG"></a>TCP_MAXSEG</h3><p>获得/设置 TCP 连接的最大分节大小（MSS）</p>
<h3 id="TCP-NODELY"><a href="#TCP-NODELY" class="headerlink" title="TCP_NODELY"></a>TCP_NODELY</h3><p>开启本选项将禁止Nagle算法</p>
<p>####　Nagle算法<br>Nagle算法的目的在于减少广域网上的小分组（小于MSS的分组）数目。<br>Nagle算法的基本原理如下：</p>
<ul>
<li><p>尽可能的发送最大大小分组，防止一个连接在任何时刻有多个小分组待确认。<br><img src="http://7xum8m.com1.z0.glb.clouddn.com/ocket_optsnagle1.jpg" alt="Nagle算法"><br><img src="http://7xum8m.com1.z0.glb.clouddn.com/socket_optsnagle0.jpg" alt="禁止Nagle算法"></p>
</li>
<li><p>ACK 延迟算法（捎带确认）。TCP 在接收到数据后并不马上发送 ACK 确认，而是等待一小段时间，然后才发送 ACK<br>以期待这一小段时间内自己有数据发送到对端，被延迟的 ACK 就可以由这段数据捎带，从而省略一个 TCP 报文</p>
</li>
</ul>
<h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><p>对于服务器不在相反方向产生数据以携带 ACK 的客户来说，ACK 延迟算法存在明显的延迟，因为客户需要等到 ACK 延迟定时器超时才会收到 ACK 确认，从而继续发送数据，此时需要禁止Nagle算法。</p>
<h1 id="参考书籍"><a href="#参考书籍" class="headerlink" title="参考书籍"></a>参考书籍</h1><p><a href="https://book.douban.com/subject/1500149/" target="_blank" rel="external">UNIX 网络编程</a><br><a href="https://book.douban.com/subject/4189500/" target="_blank" rel="external">Linux 网络编程</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;通过套接字选项可以获得、设置套接字的行为属性。&lt;br&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://github.com/Sword2G/sword2g.github.io/categories/Linux/"/>
    
    
      <category term="Socket" scheme="https://github.com/Sword2G/sword2g.github.io/tags/Socket/"/>
    
  </entry>
  
</feed>
